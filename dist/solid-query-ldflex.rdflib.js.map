{"version":3,"sources":["webpack://solid.data/webpack/bootstrap","webpack://solid.data/./node_modules/@rdfjs/data-model/index.js","webpack://solid.data/./node_modules/jsonld-context-parser/index.js","webpack://solid.data/external \"$rdf\"","webpack://solid.data/external [\"solid\",\"auth\"]","webpack://solid.data/./node_modules/jsonld-context-parser/lib/ErrorCoded.js","webpack://solid.data/./node_modules/jsonld-context-parser/lib/Util.js","webpack://solid.data/./node_modules/jsonld-context-parser/lib/ContextParser.js","webpack://solid.data/./node_modules/isomorphic-fetch/fetch-npm-browserify.js","webpack://solid.data/./node_modules/relative-to-absolute-iri/index.js","webpack://solid.data/./node_modules/jsonld-context-parser/lib/FetchDocumentLoader.js","webpack://solid.data/./node_modules/jsonld-context-parser/lib/JsonLdContextNormalized.js","webpack://solid.data/./node_modules/@rdfjs/data-model/lib/default-graph.js","webpack://solid.data/./node_modules/@rdfjs/data-model/lib/named-node.js","webpack://solid.data/./node_modules/whatwg-fetch/fetch.js","webpack://solid.data/./node_modules/relative-to-absolute-iri/lib/Resolve.js","webpack://solid.data/./node_modules/canonicalize/lib/canonicalize.js","webpack://solid.data/./node_modules/@rdfjs/data-model/lib/data-factory.js","webpack://solid.data/./node_modules/@rdfjs/data-model/lib/blank-node.js","webpack://solid.data/./node_modules/@rdfjs/data-model/lib/literal.js","webpack://solid.data/./node_modules/@rdfjs/data-model/lib/quad.js","webpack://solid.data/./node_modules/@rdfjs/data-model/lib/variable.js","webpack://solid.data/./node_modules/ldflex/module/iterableUtils.js","webpack://solid.data/./node_modules/ldflex/module/DataHandler.js","webpack://solid.data/./node_modules/ldflex/module/promiseUtils.js","webpack://solid.data/./node_modules/ldflex/module/valueUtils.js","webpack://solid.data/./node_modules/ldflex/module/MutationFunctionHandler.js","webpack://solid.data/./node_modules/ldflex/module/DeleteFunctionHandler.js","webpack://solid.data/./node_modules/ldflex/module/ExecuteQueryHandler.js","webpack://solid.data/./node_modules/ldflex/module/PreloadHandler.js","webpack://solid.data/./node_modules/ldflex/module/PropertiesHandler.js","webpack://solid.data/./node_modules/ldflex/module/SortHandler.js","webpack://solid.data/./node_modules/ldflex/module/SparqlHandler.js","webpack://solid.data/./node_modules/ldflex/module/defaultHandlers.js","webpack://solid.data/./node_modules/ldflex/module/ThenHandler.js","webpack://solid.data/./node_modules/ldflex/module/AsyncIteratorHandler.js","webpack://solid.data/./node_modules/ldflex/module/GetFunctionHandler.js","webpack://solid.data/./node_modules/ldflex/module/SubjectHandler.js","webpack://solid.data/./node_modules/ldflex/module/PredicateHandler.js","webpack://solid.data/./node_modules/ldflex/module/PredicatesHandler.js","webpack://solid.data/./node_modules/ldflex/module/PathExpressionHandler.js","webpack://solid.data/./node_modules/ldflex/module/SubjectsHandler.js","webpack://solid.data/./node_modules/ldflex/module/MutationExpressionsHandler.js","webpack://solid.data/./node_modules/ldflex/module/InsertFunctionHandler.js","webpack://solid.data/./node_modules/ldflex/module/SetFunctionHandler.js","webpack://solid.data/./node_modules/ldflex/module/ReplaceFunctionHandler.js","webpack://solid.data/./node_modules/ldflex/module/ToArrayHandler.js","webpack://solid.data/./node_modules/ldflex/module/StringToLDflexHandler.js","webpack://solid.data/./node_modules/ldflex/module/PathProxy.js","webpack://solid.data/./node_modules/ldflex/module/JSONLDResolver.js","webpack://solid.data/./node_modules/ldflex/module/PathFactory.js","webpack://solid.data/./src/handlers/ActivityHandler.js","webpack://solid.data/./src/util.js","webpack://solid.data/./node_modules/uuid/dist/esm-browser/rng.js","webpack://solid.data/./node_modules/uuid/dist/esm-browser/bytesToUuid.js","webpack://solid.data/./node_modules/uuid/dist/esm-browser/v4.js","webpack://solid.data/./src/handlers/CreateActivityHandler.js","webpack://solid.data/./src/handlers/DeleteActivityHandler.js","webpack://solid.data/./src/resolvers/SubjectPathResolver.js","webpack://solid.data/./src/handlers/SourcePathHandler.js","webpack://solid.data/./src/handlers/UserPathHandler.js","webpack://solid.data/./src/RootPath.js","webpack://solid.data/./src/resolvers/ContextResolver.js","webpack://solid.data/./src/handlers/SolidDeleteFunctionHandler.js","webpack://solid.data/./src/handlers/FindActivityHandler.js","webpack://solid.data/./src/SolidUpdateEngine.js","webpack://solid.data/./node_modules/@ldflex/rdflib/src/index.js","webpack://solid.data/./node_modules/@ldflex/rdflib/src/RdflibQueryEngine.js","webpack://solid.data/./src/exports/rdflib.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","DataFactory","__export","$rdf","solid","ErrorCoded","Error","message","code","super","this","ERROR_CODES","Util","term","indexOf","context","separatorPos","length","charAt","prefix","substr","contextValue","id","options","isPotentialKeyword","allowPrefixNonGenDelims","isPrefixIriEndingWithGenDelim","keyword","KEYWORD_REGEX","test","prefixIri","ENDS_WITH_GEN_DELIM","iri","IRI_REGEX","IRI_REGEX_WEAK","VALID_KEYWORDS","keys","isTermProtected","startsWith","REGEX_LANGUAGE_TAG","REGEX_DIRECTION_TAG","EXPAND_KEYS_BLACKLIST","ALIAS_DOMAIN_BLACKLIST","ALIAS_RANGE_BLACKLIST","CONTAINERS","CONTAINERS_1_0","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","result","done","then","apply","relative_to_absolute_iri_1","ErrorCoded_1","FetchDocumentLoader_1","JsonLdContextNormalized_1","Util_1","canonicalizeJson","ContextParser","documentLoader","FetchDocumentLoader","documentCache","validateContext","skipValidation","expandContentTypeToBase","remoteContextsDepthLimit","strictRange","errorCode","JSON","stringify","strictValues","INVALID_BASE_DIRECTION","isValidKeyword","INVALID_IRI_MAPPING","contextRaw","getContextRaw","isReservedInternalKeyword","keyValue","KEYWORD_REDEFINITION","getContextValueId","INVALID_KEYWORD_ALIAS","INVALID_TERM_DEFINITION","isPrefixValue","changed","expandTerm","type","canAddIdEntry","isValidIri","newId","processingMode","normalizeLanguageTags","toLowerCase","Array","isArray","newValue","containerValue","contextBefore","contextAfter","expandOptions","isPrefix","isSimpleTermDefinitionPrefix","valueBefore","PROTECTED_TERM_REDEFINITION","valueType","INVALID_VOCAB_MAPPING","INVALID_BASE_IRI","validateLanguage","INVALID_DEFAULT_LANGUAGE","INVALID_VERSION_VALUE","validateDirection","INVALID_CONTEXT_ENTRY","INVALID_PROPAGATE_VALUE","getPrefix","CYCLIC_IRI_MAPPING","isValidIriWeak","JsonLdContextNormalized","isCompactIri","objectKey","objectValue","INVALID_TYPE_MAPPING","INVALID_REVERSE_PROPERTY","join","INVALID_CONTAINER_MAPPING","INVALID_LANGUAGE_MAPPING","INVALID_PREFIX_VALUE","INVALID_NEST_VALUE","inheritFromParent","parentContext","baseIRI","external","contextIri","assign","parse","ignoreProtection","ignoreRemoteScopedContexts","INVALID_SCOPED_CONTEXT","minimalProcessing","DEFAULT_PROCESSING_MODE","parentContextInitial","remoteContexts","CONTEXT_OVERFLOW","hasProtectedTerms","INVALID_CONTEXT_NULLIFICATION","applyBaseEntry","normalizeContextIri","overriddenLoad","getOverriddenLoad","parsedStringContext","load","contextIris","contexts","all","map","subContext","reducedContexts","reduce","accContextPromise","contextEntry","accContext","newContext","containersToHash","importContext","INVALID_IMPORT_VALUE","loadImportContext","newContextWrapped","parseInnerContexts","validateKeywordRedefinitions","defaultExpandOptions","idifyReverseTerms","expandPrefixedTerms","normalize","applyScopedProtected","validate","INVALID_LOCAL_CONTEXT","url","cached","slice","document","LOADING_REMOTE_CONTEXT_FAILED","INVALID_REMOTE_CONTEXT","RECURSIVE_CONTEXT_INCLUSION","importContextIri","allowPrefixForcing","allowVocabRelativeToBase","self","fetch","response","headers","accept","ok","json","statusText","status","ContextParser_1","expandVocab","validIriMapping","vocab","vocabRelative","base","potentialKeyword","contextPrefixValue","shortestPrefixing","suffix","DefaultGraph","equals","other","termType","NamedNode","support","Blob","viewClasses","isArrayBufferView","ArrayBuffer","isView","obj","toString","normalizeName","String","TypeError","normalizeValue","iteratorFor","items","iterator","shift","undefined","Headers","forEach","append","header","getOwnPropertyNames","consumed","body","bodyUsed","fileReaderReady","reader","onload","onerror","error","readBlobAsArrayBuffer","blob","FileReader","promise","readAsArrayBuffer","bufferClone","buf","view","Uint8Array","byteLength","set","buffer","Body","_initBody","_bodyInit","_bodyText","isPrototypeOf","_bodyBlob","FormData","_bodyFormData","URLSearchParams","DataView","_bodyArrayBuffer","arrayBuffer","text","readAsText","chars","fromCharCode","readArrayBufferAsText","formData","decode","oldValue","has","callback","push","values","entries","methods","Request","input","method","upcased","credentials","signal","toUpperCase","referrer","form","trim","split","bytes","replace","decodeURIComponent","Response","bodyInit","clone","redirectStatuses","redirect","RangeError","location","DOMException","err","stack","constructor","init","request","aborted","xhr","XMLHttpRequest","abortXhr","abort","rawHeaders","getAllResponseHeaders","line","parts","responseURL","responseText","ontimeout","onabort","open","withCredentials","responseType","setRequestHeader","addEventListener","onreadystatechange","readyState","removeEventListener","send","polyfill","removeDotSegments","path","segmentBuffers","isCharacterAllowedAfterRelativePathSegment","pop","removeDotSegmentsOfPath","colonPosition","searchOffset","pathSeparator","character","relativeIRI","baseFragmentPos","baseQueryPos","valueColonPos","baseColonPos","baseIRIScheme","baseSlashAfterColonPos","baseIRIPath","baseIRILastSlashPos","lastIndexOf","serialize","toJSON","cv","ci","sort","BlankNode","Literal","Quad","Variable","namedNode","blankNode","literal","languageOrDatatype","defaultGraph","defaultGraphInstance","variable","triple","subject","predicate","quad","graph","nextId","language","datatype","stringDatatype","langStringDatatype","async","iterableToArray","iterable","_iteratorError","_iteratorNormalCompletion","_didIteratorError","_step","_value","_iterator","asyncIterator","_asyncIterator","item","return","getFirstItem","DataHandler","dataProperties","_isAsync","_isFunction","function","_dataProperties","pathData","_resolveDataPath","data","_resolveAsyncDataPath","_resolveSyncDataPath","lazyThenable","createPromise","getThen","onResolved","onRejected","toIterablePromise","cache","memoizeIterable","finally","isAsyncIterable","isPlainObject","hasPlainObjectArgs","args","allowMultiple","hasPlainObject","some","valueToTerm","ownKeys","enumerableOnly","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","_objectSpread","target","arguments","source","_defineProperty","getOwnPropertyDescriptors","defineProperties","configurable","writable","mutationType","allowZeroArgs","_mutationType","_allowZeroArgs","mutationExpressions","createMutationExpressions","extendPath","createMutationExpression","pairs","expressions","predicateObjects","arrays","concat","conditions","pathExpression","reverse","objects","extractObjects","_awaitAsyncGenerator","_AwaitValue","_AsyncGenerator","gen","front","back","resume","arg","wrappedAwait","wrapped","settle","_invoke","throw","VARIABLE","QUERY_TAIL","hashTerm","SortHandler","order","pathProxy","properties","rest","childData","childPath","NEEDS_ESCAPE","ESCAPE_ALL","ESCAPED_CHARS","SparqlHandler","mutationExpressionToQuery","Boolean","pathExpressionToQuery","finalClause","queryVar","sorts","clauses","createVar","expressionToTriplePatterns","select","distinct","where","orderClauses","scope","termToString","lastPredicate","mutations","objectStrings","triplePatterns","mutationClauses","root","lastVar","lastIndex","skolemized","skolemId","skolemize","allowValues","segment","index","suggestion","counter","label","match","escapeCharacter","subjectString","predicateTerm","subjectStrings","charCodeAt","results","readProperties","wrapSingleValues","parent","_handle","fn","settings","parsedContext","predicates","compactIri","segments","current","unshift","sparql","subjects","_this","resultsCache","queryEngine","query","execute","bindings","extractTerm","binding","size","sortDesc","preload","createResultsCache","vars","resultVar","createQuery","propertyCaches","hash","propertyCache","resultData","valuePath","parentQuery","variableMatch","exec","preloadClauses","add","previousPath","delete","newValues","termPropertyHandler","canonical","sync","syncFunction","toPrimitive","toArray","termTypes","handler","_","datatypes","languages","expression","ldflex","evaluator","Function","handle","subjectValue","_objectWithoutProperties","excluded","sourceKeys","_objectWithoutPropertiesLoose","sourceSymbolKeys","propertyIsEnumerable","EMPTY","PathProxy","handlers","resolvers","_handlers","_resolvers","rawData","proxy","Proxy","newData","createPath","resolver","supports","_context","extendContext","expandProperty","getResultsCache","expandedProperty","_settings","_data","defaultHandlers","toHandler","toResolver","_pathProxy","as","ActivityHandler","activitiesPath","requireUser","user","storage","pim$storage","URL","href","actor","activity","createResults","processResults","replaceVariables","template","terms","RegExp","asList","getRandomValues","crypto","msCrypto","rnds8","rng","byteToHex","offset","bth","rnds","random","ii","xsd","components","SubjectPathResolver","pathFactory","_paths","_source","_createSubjectPath","createQueryEngine","catch","SourcePathHandler","PathFactory","UserPathHandler","getWebId","session","auth","currentSession","webId","contextResolver","JSONLDResolver","exposedContext","_exposedContext","ctx","subjectHandlers","DeleteFunctionHandler","existing","findActivity","likes","dislikes","follows","createActivity","uuidv4","published","Date","toISOString","insert","executeUpdate","like","dislike","follow","deleteActivity","unlike","undislike","unfollow","SolidUpdateEngine","sources","baseEngine","getUpdateSource","_engine","clearCache","noop","defaultSources","_defaultStore","readSources","store","fetcher","Set","v","Map","sourceList","addQuad","finish","removeListener","on","defaultSettings","rootPath","subjectPathFactory","from","doc","RdflibQueryEngine"],"mappings":"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","file":"solid-query-ldflex.rdflib.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 23);\n","var DataFactory = require('./lib/data-factory')\n\nmodule.exports = DataFactory\n","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./lib/ContextParser\"));\n__export(require(\"./lib/ErrorCoded\"));\n__export(require(\"./lib/FetchDocumentLoader\"));\n__export(require(\"./lib/JsonLdContextNormalized\"));\n__export(require(\"./lib/Util\"));\n//# sourceMappingURL=index.js.map","module.exports = $rdf;","module.exports = solid[\"auth\"];","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * An error that has a certain error code.\n *\n * The error code can be any string.\n * All standardized error codes are listed in {@link ERROR_CODES}.\n */\nclass ErrorCoded extends Error {\n    /* istanbul ignore next */\n    constructor(message, code) {\n        super(message);\n        this.code = code;\n    }\n}\nexports.ErrorCoded = ErrorCoded;\n/**\n * All standardized JSON-LD error codes.\n * @see https://w3c.github.io/json-ld-api/#dom-jsonlderrorcode\n */\n// tslint:disable:object-literal-sort-keys\nvar ERROR_CODES;\n(function (ERROR_CODES) {\n    ERROR_CODES[\"COLLIDING_KEYWORDS\"] = \"colliding keywords\";\n    ERROR_CODES[\"CONFLICTING_INDEXES\"] = \"conflicting indexes\";\n    ERROR_CODES[\"CYCLIC_IRI_MAPPING\"] = \"cyclic IRI mapping\";\n    ERROR_CODES[\"INVALID_ID_VALUE\"] = \"invalid @id value\";\n    ERROR_CODES[\"INVALID_INDEX_VALUE\"] = \"invalid @index value\";\n    ERROR_CODES[\"INVALID_NEST_VALUE\"] = \"invalid @nest value\";\n    ERROR_CODES[\"INVALID_PREFIX_VALUE\"] = \"invalid @prefix value\";\n    ERROR_CODES[\"INVALID_PROPAGATE_VALUE\"] = \"invalid @propagate value\";\n    ERROR_CODES[\"INVALID_REVERSE_VALUE\"] = \"invalid @reverse value\";\n    ERROR_CODES[\"INVALID_IMPORT_VALUE\"] = \"invalid @import value\";\n    ERROR_CODES[\"INVALID_VERSION_VALUE\"] = \"invalid @version value\";\n    ERROR_CODES[\"INVALID_BASE_IRI\"] = \"invalid base IRI\";\n    ERROR_CODES[\"INVALID_CONTAINER_MAPPING\"] = \"invalid container mapping\";\n    ERROR_CODES[\"INVALID_CONTEXT_ENTRY\"] = \"invalid context entry\";\n    ERROR_CODES[\"INVALID_CONTEXT_NULLIFICATION\"] = \"invalid context nullification\";\n    ERROR_CODES[\"INVALID_DEFAULT_LANGUAGE\"] = \"invalid default language\";\n    ERROR_CODES[\"INVALID_INCLUDED_VALUE\"] = \"invalid @included value\";\n    ERROR_CODES[\"INVALID_IRI_MAPPING\"] = \"invalid IRI mapping\";\n    ERROR_CODES[\"INVALID_JSON_LITERAL\"] = \"invalid JSON literal\";\n    ERROR_CODES[\"INVALID_KEYWORD_ALIAS\"] = \"invalid keyword alias\";\n    ERROR_CODES[\"INVALID_LANGUAGE_MAP_VALUE\"] = \"invalid language map value\";\n    ERROR_CODES[\"INVALID_LANGUAGE_MAPPING\"] = \"invalid language mapping\";\n    ERROR_CODES[\"INVALID_LANGUAGE_TAGGED_STRING\"] = \"invalid language-tagged string\";\n    ERROR_CODES[\"INVALID_LANGUAGE_TAGGED_VALUE\"] = \"invalid language-tagged value\";\n    ERROR_CODES[\"INVALID_LOCAL_CONTEXT\"] = \"invalid local context\";\n    ERROR_CODES[\"INVALID_REMOTE_CONTEXT\"] = \"invalid remote context\";\n    ERROR_CODES[\"INVALID_REVERSE_PROPERTY\"] = \"invalid reverse property\";\n    ERROR_CODES[\"INVALID_REVERSE_PROPERTY_MAP\"] = \"invalid reverse property map\";\n    ERROR_CODES[\"INVALID_REVERSE_PROPERTY_VALUE\"] = \"invalid reverse property value\";\n    ERROR_CODES[\"INVALID_SCOPED_CONTEXT\"] = \"invalid scoped context\";\n    ERROR_CODES[\"INVALID_SCRIPT_ELEMENT\"] = \"invalid script element\";\n    ERROR_CODES[\"INVALID_SET_OR_LIST_OBJECT\"] = \"invalid set or list object\";\n    ERROR_CODES[\"INVALID_TERM_DEFINITION\"] = \"invalid term definition\";\n    ERROR_CODES[\"INVALID_TYPE_MAPPING\"] = \"invalid type mapping\";\n    ERROR_CODES[\"INVALID_TYPE_VALUE\"] = \"invalid type value\";\n    ERROR_CODES[\"INVALID_TYPED_VALUE\"] = \"invalid typed value\";\n    ERROR_CODES[\"INVALID_VALUE_OBJECT\"] = \"invalid value object\";\n    ERROR_CODES[\"INVALID_VALUE_OBJECT_VALUE\"] = \"invalid value object value\";\n    ERROR_CODES[\"INVALID_VOCAB_MAPPING\"] = \"invalid vocab mapping\";\n    ERROR_CODES[\"IRI_CONFUSED_WITH_PREFIX\"] = \"IRI confused with prefix\";\n    ERROR_CODES[\"KEYWORD_REDEFINITION\"] = \"keyword redefinition\";\n    ERROR_CODES[\"LOADING_DOCUMENT_FAILED\"] = \"loading document failed\";\n    ERROR_CODES[\"LOADING_REMOTE_CONTEXT_FAILED\"] = \"loading remote context failed\";\n    ERROR_CODES[\"MULTIPLE_CONTEXT_LINK_HEADERS\"] = \"multiple context link headers\";\n    ERROR_CODES[\"PROCESSING_MODE_CONFLICT\"] = \"processing mode conflict\";\n    ERROR_CODES[\"PROTECTED_TERM_REDEFINITION\"] = \"protected term redefinition\";\n    ERROR_CODES[\"CONTEXT_OVERFLOW\"] = \"context overflow\";\n    ERROR_CODES[\"INVALID_BASE_DIRECTION\"] = \"invalid base direction\";\n    ERROR_CODES[\"RECURSIVE_CONTEXT_INCLUSION\"] = \"recursive context inclusion\";\n    ERROR_CODES[\"INVALID_STREAMING_KEY_ORDER\"] = \"invalid streaming key order\";\n})(ERROR_CODES = exports.ERROR_CODES || (exports.ERROR_CODES = {}));\n//# sourceMappingURL=ErrorCoded.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Util {\n    /**\n     * Check if the given term is a valid compact IRI.\n     * Otherwise, it may be an IRI.\n     * @param {string} term A term.\n     * @return {boolean} If it is a compact IRI.\n     */\n    static isCompactIri(term) {\n        return term.indexOf(':') > 0 && !(term && term[0] === '#');\n    }\n    /**\n     * Get the prefix from the given term.\n     * @see https://json-ld.org/spec/latest/json-ld/#compact-iris\n     * @param {string} term A term that is an URL or a prefixed URL.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @return {string} The prefix or null.\n     */\n    static getPrefix(term, context) {\n        // Do not consider relative IRIs starting with a hash as compact IRIs\n        if (term && term[0] === '#') {\n            return null;\n        }\n        const separatorPos = term.indexOf(':');\n        if (separatorPos >= 0) {\n            // Suffix can not begin with two slashes\n            if (term.length > separatorPos + 1\n                && term.charAt(separatorPos + 1) === '/'\n                && term.charAt(separatorPos + 2) === '/') {\n                return null;\n            }\n            const prefix = term.substr(0, separatorPos);\n            // Prefix can not be an underscore (this is a blank node)\n            if (prefix === '_') {\n                return null;\n            }\n            // Prefix must match a term in the active context\n            if (context[prefix]) {\n                return prefix;\n            }\n        }\n        return null;\n    }\n    /**\n     * From a given context entry value, get the string value, or the @id field.\n     * @param contextValue A value for a term in a context.\n     * @return {string} The id value, or null.\n     */\n    static getContextValueId(contextValue) {\n        if (contextValue === null || typeof contextValue === 'string') {\n            return contextValue;\n        }\n        const id = contextValue['@id'];\n        return id ? id : null;\n    }\n    /**\n     * Check if the given simple term definition (string-based value of a context term)\n     * should be considered a prefix.\n     * @param value A simple term definition value.\n     * @param options Options that define the way how expansion must be done.\n     */\n    static isSimpleTermDefinitionPrefix(value, options) {\n        return !Util.isPotentialKeyword(value)\n            && (value[0] === '_' || options.allowPrefixNonGenDelims || Util.isPrefixIriEndingWithGenDelim(value));\n    }\n    /**\n     * Check if the given keyword is of the keyword format \"@\"1*ALPHA.\n     * @param {string} keyword A potential keyword.\n     * @return {boolean} If the given keyword is of the keyword format.\n     */\n    static isPotentialKeyword(keyword) {\n        return typeof keyword === 'string' && Util.KEYWORD_REGEX.test(keyword);\n    }\n    /**\n     * Check if the given prefix ends with a gen-delim character.\n     * @param {string} prefixIri A prefix IRI.\n     * @return {boolean} If the given prefix IRI is valid.\n     */\n    static isPrefixIriEndingWithGenDelim(prefixIri) {\n        return Util.ENDS_WITH_GEN_DELIM.test(prefixIri);\n    }\n    /**\n     * Check if the given context value can be a prefix value.\n     * @param value A context value.\n     * @return {boolean} If it can be a prefix value.\n     */\n    static isPrefixValue(value) {\n        return value && (typeof value === 'string' || (value && typeof value === 'object'));\n    }\n    /**\n     * Check if the given IRI is valid.\n     * @param {string} iri A potential IRI.\n     * @return {boolean} If the given IRI is valid.\n     */\n    static isValidIri(iri) {\n        return Util.IRI_REGEX.test(iri);\n    }\n    /**\n     * Check if the given IRI is valid, this includes the possibility of being a relative IRI.\n     * @param {string} iri A potential IRI.\n     * @return {boolean} If the given IRI is valid.\n     */\n    static isValidIriWeak(iri) {\n        return !!iri && iri[0] !== ':' && Util.IRI_REGEX_WEAK.test(iri);\n    }\n    /**\n     * Check if the given keyword is a defined according to the JSON-LD specification.\n     * @param {string} keyword A potential keyword.\n     * @return {boolean} If the given keyword is valid.\n     */\n    static isValidKeyword(keyword) {\n        return Util.VALID_KEYWORDS[keyword];\n    }\n    /**\n     * Check if the given term is protected in the context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {string} key A context term.\n     * @return {boolean} If the given term has an @protected flag.\n     */\n    static isTermProtected(context, key) {\n        const value = context[key];\n        return !(typeof value === 'string') && value && value['@protected'];\n    }\n    /**\n     * Check if the given context has at least one protected term.\n     * @param context A context.\n     * @return If the context has a protected term.\n     */\n    static hasProtectedTerms(context) {\n        for (const key of Object.keys(context)) {\n            if (Util.isTermProtected(context, key)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Check if the given key is an internal reserved keyword.\n     * @param key A context key.\n     */\n    static isReservedInternalKeyword(key) {\n        return key.startsWith('@__');\n    }\n}\n// Regex for valid IRIs\nUtil.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ \"<>{}|\\\\\\[\\]`#]*(#[^#]*)?$/;\n// Weaker regex for valid IRIs, this includes relative IRIs\nUtil.IRI_REGEX_WEAK = /(?::[^:])|\\//;\n// Regex for keyword form\nUtil.KEYWORD_REGEX = /^@[a-z]+$/i;\n// Regex to see if an IRI ends with a gen-delim character (see RFC 3986)\nUtil.ENDS_WITH_GEN_DELIM = /[:/?#\\[\\]@]$/;\n// Regex for language tags\nUtil.REGEX_LANGUAGE_TAG = /^[a-zA-Z]+(-[a-zA-Z0-9]+)*$/;\n// Regex for base directions\nUtil.REGEX_DIRECTION_TAG = /^(ltr)|(rtl)$/;\n// All known valid JSON-LD keywords\n// @see https://www.w3.org/TR/json-ld11/#keywords\nUtil.VALID_KEYWORDS = {\n    '@base': true,\n    '@container': true,\n    '@context': true,\n    '@direction': true,\n    '@graph': true,\n    '@id': true,\n    '@import': true,\n    '@included': true,\n    '@index': true,\n    '@json': true,\n    '@language': true,\n    '@list': true,\n    '@nest': true,\n    '@none': true,\n    '@prefix': true,\n    '@propagate': true,\n    '@protected': true,\n    '@reverse': true,\n    '@set': true,\n    '@type': true,\n    '@value': true,\n    '@version': true,\n    '@vocab': true,\n};\n// Keys in the contexts that will not be expanded based on the base IRI\nUtil.EXPAND_KEYS_BLACKLIST = [\n    '@base',\n    '@vocab',\n    '@language',\n    '@version',\n    '@direction',\n];\n// Keys in the contexts that may not be aliased from\nUtil.ALIAS_DOMAIN_BLACKLIST = [\n    '@container',\n    '@graph',\n    '@id',\n    '@index',\n    '@list',\n    '@nest',\n    '@none',\n    '@prefix',\n    '@reverse',\n    '@set',\n    '@type',\n    '@value',\n    '@version',\n];\n// Keys in the contexts that may not be aliased to\nUtil.ALIAS_RANGE_BLACKLIST = [\n    '@context',\n    '@preserve',\n];\n// All valid @container values\nUtil.CONTAINERS = [\n    '@list',\n    '@set',\n    '@index',\n    '@language',\n    '@graph',\n    '@id',\n    '@type',\n];\n// All valid @container values under processing mode 1.0\nUtil.CONTAINERS_1_0 = [\n    '@list',\n    '@set',\n    '@index',\n];\nexports.Util = Util;\n//# sourceMappingURL=Util.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nrequire(\"isomorphic-fetch\");\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\nconst ErrorCoded_1 = require(\"./ErrorCoded\");\nconst FetchDocumentLoader_1 = require(\"./FetchDocumentLoader\");\nconst JsonLdContextNormalized_1 = require(\"./JsonLdContextNormalized\");\nconst Util_1 = require(\"./Util\");\n// tslint:disable-next-line:no-var-requires\nconst canonicalizeJson = require('canonicalize');\n/**\n * Parses JSON-LD contexts.\n */\nclass ContextParser {\n    constructor(options) {\n        options = options || {};\n        this.documentLoader = options.documentLoader || new FetchDocumentLoader_1.FetchDocumentLoader();\n        this.documentCache = {};\n        this.validateContext = !options.skipValidation;\n        this.expandContentTypeToBase = !!options.expandContentTypeToBase;\n        this.remoteContextsDepthLimit = options.remoteContextsDepthLimit || 32;\n    }\n    /**\n     * Validate the given @language value.\n     * An error will be thrown if it is invalid.\n     * @param value An @language value.\n     * @param {boolean} strictRange If the string value should be strictly checked against a regex.\n     * @param {string} errorCode The error code to emit on errors.\n     * @return {boolean} If validation passed.\n     *                   Can only be false if strictRange is false and the string value did not pass the regex.\n     */\n    static validateLanguage(value, strictRange, errorCode) {\n        if (typeof value !== 'string') {\n            throw new ErrorCoded_1.ErrorCoded(`The value of an '@language' must be a string, got '${JSON.stringify(value)}'`, errorCode);\n        }\n        if (!Util_1.Util.REGEX_LANGUAGE_TAG.test(value)) {\n            if (strictRange) {\n                throw new ErrorCoded_1.ErrorCoded(`The value of an '@language' must be a valid language tag, got '${JSON.stringify(value)}'`, errorCode);\n            }\n            else {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Validate the given @direction value.\n     * An error will be thrown if it is invalid.\n     * @param value An @direction value.\n     * @param {boolean} strictValues If the string value should be strictly checked against a regex.\n     * @return {boolean} If validation passed.\n     *                   Can only be false if strictRange is false and the string value did not pass the regex.\n     */\n    static validateDirection(value, strictValues) {\n        if (typeof value !== 'string') {\n            throw new ErrorCoded_1.ErrorCoded(`The value of an '@direction' must be a string, got '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_DIRECTION);\n        }\n        if (!Util_1.Util.REGEX_DIRECTION_TAG.test(value)) {\n            if (strictValues) {\n                throw new ErrorCoded_1.ErrorCoded(`The value of an '@direction' must be 'ltr' or 'rtl', got '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_DIRECTION);\n            }\n            else {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Add an @id term for all @reverse terms.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @return {IJsonLdContextNormalizedRaw} The mutated input context.\n     */\n    idifyReverseTerms(context) {\n        for (const key of Object.keys(context)) {\n            const value = context[key];\n            if (value && typeof value === 'object') {\n                if (value['@reverse'] && !value['@id']) {\n                    if (typeof value['@reverse'] !== 'string' || Util_1.Util.isValidKeyword(value['@reverse'])) {\n                        throw new ErrorCoded_1.ErrorCoded(`Invalid @reverse value, must be absolute IRI or blank node: '${value['@reverse']}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                    }\n                    value['@id'] = value['@reverse'];\n                    if (Util_1.Util.isPotentialKeyword(value['@reverse'])) {\n                        delete value['@reverse'];\n                    }\n                    else {\n                        value['@reverse'] = true;\n                    }\n                }\n            }\n        }\n        return context;\n    }\n    /**\n     * Expand all prefixed terms in the given context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {boolean} expandContentTypeToBase If @type inside the context may be expanded\n     *                                          via @base if @vocab is set to null.\n     */\n    expandPrefixedTerms(context, expandContentTypeToBase) {\n        const contextRaw = context.getContextRaw();\n        for (const key of Object.keys(contextRaw)) {\n            // Only expand allowed keys\n            if (Util_1.Util.EXPAND_KEYS_BLACKLIST.indexOf(key) < 0 && !Util_1.Util.isReservedInternalKeyword(key)) {\n                // Error if we try to alias a keyword to something else.\n                const keyValue = contextRaw[key];\n                if (Util_1.Util.isPotentialKeyword(key) && Util_1.Util.ALIAS_DOMAIN_BLACKLIST.indexOf(key) >= 0) {\n                    if (key !== '@type' || typeof contextRaw[key] === 'object'\n                        && !(contextRaw[key]['@protected'] || contextRaw[key]['@container'] === '@set')) {\n                        throw new ErrorCoded_1.ErrorCoded(`Keywords can not be aliased to something else.\nTried mapping ${key} to ${JSON.stringify(keyValue)}`, ErrorCoded_1.ERROR_CODES.KEYWORD_REDEFINITION);\n                    }\n                }\n                // Error if we try to alias to an illegal keyword\n                if (Util_1.Util.ALIAS_RANGE_BLACKLIST.indexOf(Util_1.Util.getContextValueId(keyValue)) >= 0) {\n                    throw new ErrorCoded_1.ErrorCoded(`Aliasing to certain keywords is not allowed.\nTried mapping ${key} to ${JSON.stringify(keyValue)}`, ErrorCoded_1.ERROR_CODES.INVALID_KEYWORD_ALIAS);\n                }\n                // Error if this term was marked as prefix as well\n                if (keyValue && Util_1.Util.isPotentialKeyword(Util_1.Util.getContextValueId(keyValue))\n                    && keyValue['@prefix'] === true) {\n                    throw new ErrorCoded_1.ErrorCoded(`Tried to use keyword aliases as prefix: '${key}': '${JSON.stringify(keyValue)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                }\n                // Loop because prefixes might be nested\n                while (Util_1.Util.isPrefixValue(contextRaw[key])) {\n                    const value = contextRaw[key];\n                    let changed = false;\n                    if (typeof value === 'string') {\n                        contextRaw[key] = context.expandTerm(value, true);\n                        changed = changed || value !== contextRaw[key];\n                    }\n                    else {\n                        const id = value['@id'];\n                        const type = value['@type'];\n                        // If @id is missing, don't allow @id to be added if @prefix: true and key not being a valid IRI.\n                        const canAddIdEntry = !('@prefix' in value) || Util_1.Util.isValidIri(key);\n                        if ('@id' in value) {\n                            // Use @id value for expansion\n                            if (id !== undefined && id !== null && typeof id === 'string') {\n                                contextRaw[key]['@id'] = context.expandTerm(id, true);\n                                changed = changed || id !== contextRaw[key]['@id'];\n                            }\n                        }\n                        else if (!Util_1.Util.isPotentialKeyword(key) && canAddIdEntry) {\n                            // Add an explicit @id value based on the expanded key value\n                            const newId = context.expandTerm(key, true);\n                            if (newId !== key) {\n                                // Don't set @id if expansion failed\n                                contextRaw[key]['@id'] = newId;\n                                changed = true;\n                            }\n                        }\n                        if (type && typeof type === 'string' && type !== '@vocab'\n                            && (!value['@container'] || !value['@container']['@type'])\n                            && canAddIdEntry) {\n                            // First check @vocab, then fallback to @base\n                            contextRaw[key]['@type'] = context.expandTerm(type, true);\n                            if (expandContentTypeToBase && type === contextRaw[key]['@type']) {\n                                contextRaw[key]['@type'] = context.expandTerm(type, false);\n                            }\n                            changed = changed || type !== contextRaw[key]['@type'];\n                        }\n                    }\n                    if (!changed) {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Normalize the @language entries in the given context to lowercase.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {IParseOptions} parseOptions The parsing options.\n     */\n    normalize(context, { processingMode, normalizeLanguageTags }) {\n        // Lowercase language keys in 1.0\n        if (normalizeLanguageTags || processingMode === 1.0) {\n            for (const key of Object.keys(context)) {\n                if (key === '@language' && typeof context[key] === 'string') {\n                    context[key] = context[key].toLowerCase();\n                }\n                else {\n                    const value = context[key];\n                    if (value && typeof value === 'object') {\n                        if (typeof value['@language'] === 'string') {\n                            value['@language'] = value['@language'].toLowerCase();\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Convert all @container strings and array values to hash-based values.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     */\n    containersToHash(context) {\n        for (const key of Object.keys(context)) {\n            const value = context[key];\n            if (value && typeof value === 'object') {\n                if (typeof value['@container'] === 'string') {\n                    value['@container'] = { [value['@container']]: true };\n                }\n                else if (Array.isArray(value['@container'])) {\n                    const newValue = {};\n                    for (const containerValue of value['@container']) {\n                        newValue[containerValue] = true;\n                    }\n                    value['@container'] = newValue;\n                }\n            }\n        }\n    }\n    /**\n     * Normalize and apply context-levevl @protected terms onto each term separately.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {number} processingMode The processing mode.\n     */\n    applyScopedProtected(context, { processingMode }) {\n        if (processingMode && processingMode >= 1.1) {\n            if (context['@protected']) {\n                for (const key of Object.keys(context)) {\n                    if (Util_1.Util.isReservedInternalKeyword(key)) {\n                        continue;\n                    }\n                    if (!Util_1.Util.isPotentialKeyword(key) && !Util_1.Util.isTermProtected(context, key)) {\n                        const value = context[key];\n                        if (value && typeof value === 'object') {\n                            if (!('@protected' in context[key])) {\n                                // Mark terms with object values as protected if they don't have an @protected: false annotation\n                                context[key]['@protected'] = true;\n                            }\n                        }\n                        else {\n                            // Convert string-based term values to object-based values with @protected: true\n                            context[key] = {\n                                '@id': value,\n                                '@protected': true,\n                            };\n                        }\n                    }\n                }\n                delete context['@protected'];\n            }\n        }\n    }\n    /**\n     * Check if the given context inheritance does not contain any overrides of protected terms.\n     * @param {IJsonLdContextNormalizedRaw} contextBefore The context that may contain some protected terms.\n     * @param {IJsonLdContextNormalizedRaw} contextAfter A new context that is being applied on the first one.\n     * @param {IExpandOptions} expandOptions Options that are needed for any expansions during this validation.\n     */\n    validateKeywordRedefinitions(contextBefore, contextAfter, expandOptions) {\n        for (const key of Object.keys(contextAfter)) {\n            if (Util_1.Util.isTermProtected(contextBefore, key)) {\n                // The entry in the context before will always be in object-mode\n                // If the new entry is in string-mode, convert it to object-mode\n                // before checking if it is identical.\n                if (typeof contextAfter[key] === 'string') {\n                    const isPrefix = Util_1.Util.isSimpleTermDefinitionPrefix(contextAfter[key], expandOptions);\n                    contextAfter[key] = { '@id': contextAfter[key] };\n                    // If the simple term def was a prefix, explicitly mark the term as a prefix in the expanded term definition,\n                    // because otherwise we loose this information due to JSON-LD interpreting prefixes differently\n                    // in simple vs expanded term definitions.\n                    if (isPrefix) {\n                        contextAfter[key]['@prefix'] = true;\n                        contextBefore[key]['@prefix'] = true; // Also on before, to make sure the next step still considers them ==\n                    }\n                }\n                // Convert term values to strings for each comparison\n                const valueBefore = canonicalizeJson(contextBefore[key]);\n                // We modify this deliberately,\n                // as we need it for the value comparison (they must be identical modulo '@protected')),\n                // and for the fact that this new value will override the first one.\n                contextAfter[key]['@protected'] = true;\n                const valueAfter = canonicalizeJson(contextAfter[key]);\n                // Error if they are not identical\n                if (valueBefore !== valueAfter) {\n                    throw new ErrorCoded_1.ErrorCoded(`Attempted to override the protected keyword ${key} from ${JSON.stringify(Util_1.Util.getContextValueId(contextBefore[key]))} to ${JSON.stringify(Util_1.Util.getContextValueId(contextAfter[key]))}`, ErrorCoded_1.ERROR_CODES.PROTECTED_TERM_REDEFINITION);\n                }\n            }\n        }\n    }\n    /**\n     * Validate the entries of the given context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {IParseOptions} options The parse options.\n     */\n    validate(context, { processingMode }) {\n        for (const key of Object.keys(context)) {\n            // Ignore reserved internal keywords.\n            if (Util_1.Util.isReservedInternalKeyword(key)) {\n                continue;\n            }\n            // Do not allow empty term\n            if (key === '') {\n                throw new ErrorCoded_1.ErrorCoded(`The empty term is not allowed, got: '${key}': '${JSON.stringify(context[key])}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n            }\n            const value = context[key];\n            const valueType = typeof value;\n            // First check if the key is a keyword\n            if (Util_1.Util.isPotentialKeyword(key)) {\n                switch (key.substr(1)) {\n                    case 'vocab':\n                        if (value !== null && valueType !== 'string') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @vocab IRI: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_VOCAB_MAPPING);\n                        }\n                        break;\n                    case 'base':\n                        if (value !== null && valueType !== 'string') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @base IRI: ${context[key]}`, ErrorCoded_1.ERROR_CODES.INVALID_BASE_IRI);\n                        }\n                        break;\n                    case 'language':\n                        if (value !== null) {\n                            ContextParser.validateLanguage(value, true, ErrorCoded_1.ERROR_CODES.INVALID_DEFAULT_LANGUAGE);\n                        }\n                        break;\n                    case 'version':\n                        if (value !== null && valueType !== 'number') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @version number: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_VERSION_VALUE);\n                        }\n                        break;\n                    case 'direction':\n                        if (value !== null) {\n                            ContextParser.validateDirection(value, true);\n                        }\n                        break;\n                    case 'propagate':\n                        if (processingMode === 1.0) {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an illegal @propagate keyword: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);\n                        }\n                        if (value !== null && valueType !== 'boolean') {\n                            throw new ErrorCoded_1.ErrorCoded(`Found an invalid @propagate value: ${value}`, ErrorCoded_1.ERROR_CODES.INVALID_PROPAGATE_VALUE);\n                        }\n                        break;\n                }\n                // Don't allow keywords to be overridden\n                if (Util_1.Util.isValidKeyword(key) && Util_1.Util.isValidKeyword(Util_1.Util.getContextValueId(value))) {\n                    throw new ErrorCoded_1.ErrorCoded(`Illegal keyword alias in term value, found: '${key}': '${Util_1.Util\n                        .getContextValueId(value)}'`, ErrorCoded_1.ERROR_CODES.KEYWORD_REDEFINITION);\n                }\n                continue;\n            }\n            // Otherwise, consider the key a term\n            if (value !== null) {\n                switch (valueType) {\n                    case 'string':\n                        if (Util_1.Util.getPrefix(value, context) === key) {\n                            throw new ErrorCoded_1.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${key}': '${JSON\n                                .stringify(value)}'`, ErrorCoded_1.ERROR_CODES.CYCLIC_IRI_MAPPING);\n                        }\n                        if (Util_1.Util.isValidIriWeak(key)) {\n                            if (value === '@type') {\n                                throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to @type, found: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                            }\n                            else if (Util_1.Util.isValidIri(value) && value !== new JsonLdContextNormalized_1.JsonLdContextNormalized(context).expandTerm(key)) {\n                                throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                            }\n                        }\n                        break;\n                    case 'object':\n                        if (!Util_1.Util.isCompactIri(key) && !('@id' in value)\n                            && (value['@type'] === '@id' ? !context['@base'] : !context['@vocab'])) {\n                            throw new ErrorCoded_1.ErrorCoded(`Missing @id in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                        }\n                        for (const objectKey of Object.keys(value)) {\n                            const objectValue = value[objectKey];\n                            if (!objectValue) {\n                                continue;\n                            }\n                            switch (objectKey) {\n                                case '@id':\n                                    if (Util_1.Util.isValidKeyword(objectValue)\n                                        && objectValue !== '@type' && objectValue !== '@id' && objectValue !== '@graph') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Illegal keyword alias in term value, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                    }\n                                    if (Util_1.Util.isValidIriWeak(key)) {\n                                        if (objectValue === '@type') {\n                                            throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to @type, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                        }\n                                        else if (Util_1.Util.isValidIri(objectValue)\n                                            && objectValue !== new JsonLdContextNormalized_1.JsonLdContextNormalized(context).expandTerm(key)) {\n                                            throw new ErrorCoded_1.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                        }\n                                    }\n                                    if (typeof objectValue !== 'string') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Detected non-string @id in context entry: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n                                    }\n                                    if (Util_1.Util.getPrefix(objectValue, context) === key) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${key}': '${JSON\n                                            .stringify(value)}'`, ErrorCoded_1.ERROR_CODES.CYCLIC_IRI_MAPPING);\n                                    }\n                                    break;\n                                case '@type':\n                                    if (value['@container'] === '@type' && objectValue !== '@id' && objectValue !== '@vocab') {\n                                        throw new ErrorCoded_1.ErrorCoded(`@container: @type only allows @type: @id or @vocab, but got: '${key}': '${objectValue}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);\n                                    }\n                                    if (objectValue !== '@id' && objectValue !== '@vocab'\n                                        && (processingMode === 1.0 || objectValue !== '@json')\n                                        && (processingMode === 1.0 || objectValue !== '@none')\n                                        && (objectValue[0] === '_' || !Util_1.Util.isValidIri(objectValue))) {\n                                        throw new ErrorCoded_1.ErrorCoded(`A context @type must be an absolute IRI, found: '${key}': '${objectValue}'`, ErrorCoded_1.ERROR_CODES.INVALID_TYPE_MAPPING);\n                                    }\n                                    break;\n                                case '@reverse':\n                                    if (typeof objectValue === 'string' && value['@id'] && value['@id'] !== objectValue) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Found non-matching @id and @reverse term values in '${key}':\\\n'${objectValue}' and '${value['@id']}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);\n                                    }\n                                    if ('@nest' in value) {\n                                        throw new ErrorCoded_1.ErrorCoded(`@nest is not allowed in the reverse property '${key}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);\n                                    }\n                                    break;\n                                case '@container':\n                                    if (processingMode === 1.0) {\n                                        if (Object.keys(objectValue).length > 1\n                                            || Util_1.Util.CONTAINERS_1_0.indexOf(Object.keys(objectValue)[0]) < 0) {\n                                            throw new ErrorCoded_1.ErrorCoded(`Invalid term @container for '${key}' ('${Object.keys(objectValue)}') in 1.0, \\\nmust be only one of ${Util_1.Util.CONTAINERS_1_0.join(', ')}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTAINER_MAPPING);\n                                        }\n                                    }\n                                    for (const containerValue of Object.keys(objectValue)) {\n                                        if (containerValue === '@list' && value['@reverse']) {\n                                            throw new ErrorCoded_1.ErrorCoded(`Term value can not be @container: @list and @reverse at the same time on '${key}'`, ErrorCoded_1.ERROR_CODES.INVALID_REVERSE_PROPERTY);\n                                        }\n                                        if (Util_1.Util.CONTAINERS.indexOf(containerValue) < 0) {\n                                            throw new ErrorCoded_1.ErrorCoded(`Invalid term @container for '${key}' ('${containerValue}'), \\\nmust be one of ${Util_1.Util.CONTAINERS.join(', ')}`, ErrorCoded_1.ERROR_CODES.INVALID_CONTAINER_MAPPING);\n                                        }\n                                    }\n                                    break;\n                                case '@language':\n                                    ContextParser.validateLanguage(objectValue, true, ErrorCoded_1.ERROR_CODES.INVALID_LANGUAGE_MAPPING);\n                                    break;\n                                case '@direction':\n                                    ContextParser.validateDirection(objectValue, true);\n                                    break;\n                                case '@prefix':\n                                    if (objectValue !== null && typeof objectValue !== 'boolean') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Found an invalid term @prefix boolean in: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_PREFIX_VALUE);\n                                    }\n                                    if (!('@id' in value) && !Util_1.Util.isValidIri(key)) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Invalid @prefix definition for '${key}' ('${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                                    }\n                                    break;\n                                case '@index':\n                                    if (processingMode === 1.0 || !value['@container'] || !value['@container']['@index']) {\n                                        throw new ErrorCoded_1.ErrorCoded(`Attempt to add illegal key to value object: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                                    }\n                                    break;\n                                case '@nest':\n                                    if (Util_1.Util.isPotentialKeyword(objectValue) && objectValue !== '@nest') {\n                                        throw new ErrorCoded_1.ErrorCoded(`Found an invalid term @nest value in: '${key}': '${JSON.stringify(value)}'`, ErrorCoded_1.ERROR_CODES.INVALID_NEST_VALUE);\n                                    }\n                            }\n                        }\n                        break;\n                    default:\n                        throw new ErrorCoded_1.ErrorCoded(`Found an invalid term value: '${key}': '${value}'`, ErrorCoded_1.ERROR_CODES.INVALID_TERM_DEFINITION);\n                }\n            }\n        }\n    }\n    /**\n     * Apply the @base context entry to the given context under certain circumstances.\n     * @param context A context.\n     * @param options Parsing options.\n     * @param inheritFromParent If the @base value from the parent context can be inherited.\n     * @return The given context.\n     */\n    applyBaseEntry(context, options, inheritFromParent) {\n        // In some special cases, this can be a string, so ignore those.\n        if (typeof context === 'string') {\n            return context;\n        }\n        // Give priority to @base in the parent context\n        if (inheritFromParent && !('@base' in context) && options.parentContext && '@base' in options.parentContext) {\n            context['@base'] = options.parentContext['@base'];\n            if (options.parentContext['@__baseDocument']) {\n                context['@__baseDocument'] = true;\n            }\n        }\n        // Override the base IRI if provided.\n        if (options.baseIRI && !options.external) {\n            if (!('@base' in context)) {\n                // The context base is the document base\n                context['@base'] = options.baseIRI;\n                context['@__baseDocument'] = true;\n            }\n            else if (context['@base'] !== null && typeof context['@base'] === 'string'\n                && !Util_1.Util.isValidIri(context['@base'])) {\n                // The context base is relative to the document base\n                context['@base'] = relative_to_absolute_iri_1.resolve(context['@base'], options.parentContext && options.parentContext['@base'] || options.baseIRI);\n            }\n        }\n        return context;\n    }\n    /**\n     * Resolve relative context IRIs, or return full IRIs as-is.\n     * @param {string} contextIri A context IRI.\n     * @param {string} baseIRI A base IRI.\n     * @return {string} The normalized context IRI.\n     */\n    normalizeContextIri(contextIri, baseIRI) {\n        if (!Util_1.Util.isValidIri(contextIri)) {\n            contextIri = relative_to_absolute_iri_1.resolve(contextIri, baseIRI);\n            if (!Util_1.Util.isValidIri(contextIri)) {\n                throw new Error(`Invalid context IRI: ${contextIri}`);\n            }\n        }\n        return contextIri;\n    }\n    /**\n     * Parse scoped contexts in the given context.\n     * @param {IJsonLdContextNormalizedRaw} context A context.\n     * @param {IParseOptions} options Parsing options.\n     * @return {IJsonLdContextNormalizedRaw} The mutated input context.\n     */\n    parseInnerContexts(context, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const key of Object.keys(context)) {\n                const value = context[key];\n                if (value && typeof value === 'object') {\n                    if ('@context' in value && value['@context'] !== null) {\n                        // Simulate a processing based on the parent context to check if there are any (potential errors).\n                        // Honestly, I find it a bit weird to do this here, as the context may be unused,\n                        // and the final effective context may differ based on any other embedded/scoped contexts.\n                        // But hey, it's part of the spec, so we have no choice...\n                        // https://w3c.github.io/json-ld-api/#h-note-10\n                        if (this.validateContext) {\n                            try {\n                                const parentContext = Object.assign({}, context);\n                                parentContext[key] = Object.assign({}, parentContext[key]);\n                                delete parentContext[key]['@context'];\n                                yield this.parse(value['@context'], Object.assign({}, options, { parentContext, ignoreProtection: true, ignoreRemoteScopedContexts: true }));\n                            }\n                            catch (e) {\n                                throw new ErrorCoded_1.ErrorCoded(e.message, ErrorCoded_1.ERROR_CODES.INVALID_SCOPED_CONTEXT);\n                            }\n                        }\n                        value['@context'] = (yield this.parse(value['@context'], Object.assign({}, options, { minimalProcessing: true, ignoreRemoteScopedContexts: true, parentContext: context })))\n                            .getContextRaw();\n                    }\n                }\n            }\n            return context;\n        });\n    }\n    /**\n     * Parse a JSON-LD context in any form.\n     * @param {JsonLdContext} context A context, URL to a context, or an array of contexts/URLs.\n     * @param {IParseOptions} options Optional parsing options.\n     * @return {Promise<JsonLdContextNormalized>} A promise resolving to the context.\n     */\n    parse(context, options = {\n        processingMode: ContextParser.DEFAULT_PROCESSING_MODE,\n    }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { baseIRI, parentContext: parentContextInitial, external, processingMode, normalizeLanguageTags, ignoreProtection, minimalProcessing, } = options;\n            let parentContext = parentContextInitial;\n            const remoteContexts = options.remoteContexts || {};\n            // Avoid remote context overflows\n            if (Object.keys(remoteContexts).length >= this.remoteContextsDepthLimit) {\n                throw new ErrorCoded_1.ErrorCoded('Detected an overflow in remote context inclusions: ' + Object.keys(remoteContexts), ErrorCoded_1.ERROR_CODES.CONTEXT_OVERFLOW);\n            }\n            if (context === null || context === undefined) {\n                // Don't allow context nullification and there are protected terms\n                if (!ignoreProtection && parentContext && Util_1.Util.hasProtectedTerms(parentContext)) {\n                    throw new ErrorCoded_1.ErrorCoded('Illegal context nullification when terms are protected', ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_NULLIFICATION);\n                }\n                // Context that are explicitly set to null are empty.\n                return new JsonLdContextNormalized_1.JsonLdContextNormalized(this.applyBaseEntry({}, options, false));\n            }\n            else if (typeof context === 'string') {\n                const contextIri = this.normalizeContextIri(context, baseIRI);\n                const overriddenLoad = this.getOverriddenLoad(contextIri, options);\n                if (overriddenLoad) {\n                    return new JsonLdContextNormalized_1.JsonLdContextNormalized(overriddenLoad);\n                }\n                const parsedStringContext = yield this.parse(yield this.load(contextIri), Object.assign({}, options, { baseIRI: contextIri, external: true, remoteContexts: Object.assign({}, remoteContexts, { [contextIri]: true }) }));\n                this.applyBaseEntry(parsedStringContext.getContextRaw(), options, true);\n                return parsedStringContext;\n            }\n            else if (Array.isArray(context)) {\n                // As a performance consideration, first load all external contexts in parallel.\n                const contextIris = [];\n                const contexts = yield Promise.all(context.map((subContext, i) => {\n                    if (typeof subContext === 'string') {\n                        const contextIri = this.normalizeContextIri(subContext, baseIRI);\n                        contextIris[i] = contextIri;\n                        const overriddenLoad = this.getOverriddenLoad(contextIri, options);\n                        if (overriddenLoad) {\n                            return overriddenLoad;\n                        }\n                        return this.load(contextIri);\n                    }\n                    else {\n                        return subContext;\n                    }\n                }));\n                // Don't apply inheritance logic on minimal processing\n                if (minimalProcessing) {\n                    return new JsonLdContextNormalized_1.JsonLdContextNormalized(contexts);\n                }\n                const reducedContexts = yield contexts.reduce((accContextPromise, contextEntry, i) => accContextPromise\n                    .then((accContext) => this.parse(contextEntry, Object.assign({}, options, { baseIRI: contextIris[i] || options.baseIRI, external: !!contextIris[i] || options.external, parentContext: accContext.getContextRaw(), remoteContexts: contextIris[i] ? Object.assign({}, remoteContexts, { [contextIris[i]]: true }) : remoteContexts }))), Promise.resolve(new JsonLdContextNormalized_1.JsonLdContextNormalized(parentContext || {})));\n                // Override the base IRI if provided.\n                this.applyBaseEntry(reducedContexts.getContextRaw(), options, true);\n                return reducedContexts;\n            }\n            else if (typeof context === 'object') {\n                if ('@context' in context) {\n                    return yield this.parse(context['@context'], options);\n                }\n                // Make a deep clone of the given context, to avoid modifying it.\n                context = JSON.parse(JSON.stringify(context)); // No better way in JS at the moment.\n                if (parentContext) {\n                    parentContext = JSON.parse(JSON.stringify(parentContext));\n                }\n                // We have an actual context object.\n                let newContext = {};\n                // According to the JSON-LD spec, @base must be ignored from external contexts.\n                if (external) {\n                    delete context['@base'];\n                }\n                // Override the base IRI if provided.\n                this.applyBaseEntry(context, options, true);\n                // Hashify container entries\n                // Do this before protected term validation as that influences term format\n                this.containersToHash(context);\n                // Don't perform any other modifications if only minimal processing is needed.\n                if (minimalProcessing) {\n                    return new JsonLdContextNormalized_1.JsonLdContextNormalized(context);\n                }\n                // In JSON-LD 1.1, load @import'ed context prior to processing.\n                let importContext = {};\n                if ('@import' in context) {\n                    if (processingMode && processingMode >= 1.1) {\n                        // Only accept string values\n                        if (typeof context['@import'] !== 'string') {\n                            throw new ErrorCoded_1.ErrorCoded('An @import value must be a string, but got ' + typeof context['@import'], ErrorCoded_1.ERROR_CODES.INVALID_IMPORT_VALUE);\n                        }\n                        // Load context\n                        importContext = yield this.loadImportContext(this.normalizeContextIri(context['@import'], baseIRI));\n                        delete context['@import'];\n                    }\n                    else {\n                        throw new ErrorCoded_1.ErrorCoded('Context importing is not supported in JSON-LD 1.0', ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);\n                    }\n                }\n                // Merge different parts of the final context in order\n                newContext = Object.assign({}, newContext, parentContext, importContext, context);\n                const newContextWrapped = new JsonLdContextNormalized_1.JsonLdContextNormalized(newContext);\n                // Parse inner contexts with minimal processing\n                yield this.parseInnerContexts(newContext, options);\n                // In JSON-LD 1.1, check if we are not redefining any protected keywords\n                if (!ignoreProtection && parentContext && processingMode && processingMode >= 1.1) {\n                    this.validateKeywordRedefinitions(parentContext, newContext, exports.defaultExpandOptions);\n                }\n                // In JSON-LD 1.1, @vocab can be relative to @vocab in the parent context.\n                if ((newContext && newContext['@version'] || processingMode || ContextParser.DEFAULT_PROCESSING_MODE) >= 1.1\n                    && ((context['@vocab'] && typeof context['@vocab'] === 'string') || context['@vocab'] === '')\n                    && context['@vocab'].indexOf(':') < 0 && parentContext && '@vocab' in parentContext) {\n                    newContext['@vocab'] = parentContext['@vocab'] + context['@vocab'];\n                }\n                this.idifyReverseTerms(newContext);\n                this.expandPrefixedTerms(newContextWrapped, this.expandContentTypeToBase);\n                this.normalize(newContext, { processingMode, normalizeLanguageTags });\n                this.applyScopedProtected(newContext, { processingMode });\n                if (this.validateContext) {\n                    this.validate(newContext, { processingMode });\n                }\n                return newContextWrapped;\n            }\n            else {\n                throw new ErrorCoded_1.ErrorCoded(`Tried parsing a context that is not a string, array or object, but got ${context}`, ErrorCoded_1.ERROR_CODES.INVALID_LOCAL_CONTEXT);\n            }\n        });\n    }\n    /**\n     * Fetch the given URL as a raw JSON-LD context.\n     * @param url An URL.\n     * @return A promise resolving to a raw JSON-LD context.\n     */\n    load(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // First try to retrieve the context from cache\n            const cached = this.documentCache[url];\n            if (cached) {\n                return typeof cached === 'string' ? cached : Array.isArray(cached) ? cached.slice() : Object.assign({}, cached);\n            }\n            // If not in cache, load it\n            let document;\n            try {\n                document = yield this.documentLoader.load(url);\n            }\n            catch (e) {\n                throw new ErrorCoded_1.ErrorCoded(`Failed to load remote context ${url}: ${e.message}`, ErrorCoded_1.ERROR_CODES.LOADING_REMOTE_CONTEXT_FAILED);\n            }\n            // Validate the context\n            if (!('@context' in document)) {\n                throw new ErrorCoded_1.ErrorCoded(`Missing @context in remote context at ${url}`, ErrorCoded_1.ERROR_CODES.INVALID_REMOTE_CONTEXT);\n            }\n            return this.documentCache[url] = document['@context'];\n        });\n    }\n    /**\n     * Override the given context that may be loaded.\n     *\n     * This will check whether or not the url is recursively being loaded.\n     * @param url An URL.\n     * @param options Parsing options.\n     * @return An overridden context, or null.\n     *         Optionally an error can be thrown if a cyclic context is detected.\n     */\n    getOverriddenLoad(url, options) {\n        if (url in (options.remoteContexts || {})) {\n            if (options.ignoreRemoteScopedContexts) {\n                return url;\n            }\n            else {\n                throw new ErrorCoded_1.ErrorCoded('Detected a cyclic context inclusion of ' + url, ErrorCoded_1.ERROR_CODES.RECURSIVE_CONTEXT_INCLUSION);\n            }\n        }\n        return null;\n    }\n    /**\n     * Load an @import'ed context.\n     * @param importContextIri The full URI of an @import value.\n     */\n    loadImportContext(importContextIri) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Load the context\n            const importContext = yield this.load(importContextIri);\n            // Require the context to be a non-array object\n            if (typeof importContext !== 'object' || Array.isArray(importContext)) {\n                throw new ErrorCoded_1.ErrorCoded('An imported context must be a single object: ' + importContextIri, ErrorCoded_1.ERROR_CODES.INVALID_REMOTE_CONTEXT);\n            }\n            // Error if the context contains another @import\n            if ('@import' in importContext) {\n                throw new ErrorCoded_1.ErrorCoded('An imported context can not import another context: ' + importContextIri, ErrorCoded_1.ERROR_CODES.INVALID_CONTEXT_ENTRY);\n            }\n            return importContext;\n        });\n    }\n}\nContextParser.DEFAULT_PROCESSING_MODE = 1.1;\nexports.ContextParser = ContextParser;\nexports.defaultExpandOptions = {\n    allowPrefixForcing: true,\n    allowPrefixNonGenDelims: false,\n    allowVocabRelativeToBase: true,\n};\n//# sourceMappingURL=ContextParser.js.map","// the whatwg-fetch polyfill installs the fetch() function\n// on the global object (window or self)\n//\n// Return that as the export for use in Webpack, Browserify etc.\nrequire('whatwg-fetch');\nmodule.exports = self.fetch.bind(self);\n","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./lib/Resolve\"));\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nrequire(\"isomorphic-fetch\");\n/**\n * Loads documents via the fetch API.\n */\nclass FetchDocumentLoader {\n    load(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch(url, { headers: { accept: 'application/ld+json' } });\n            if (response.ok) {\n                return (yield response.json());\n            }\n            else {\n                throw new Error(response.statusText || `${response.status}`);\n            }\n        });\n    }\n}\nexports.FetchDocumentLoader = FetchDocumentLoader;\n//# sourceMappingURL=FetchDocumentLoader.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\nconst ContextParser_1 = require(\"./ContextParser\");\nconst ErrorCoded_1 = require(\"./ErrorCoded\");\nconst Util_1 = require(\"./Util\");\n/**\n * A class exposing operations over a normalized JSON-LD context.\n */\nclass JsonLdContextNormalized {\n    constructor(contextRaw) {\n        this.contextRaw = contextRaw;\n    }\n    /**\n     * @return The raw inner context.\n     */\n    getContextRaw() {\n        return this.contextRaw;\n    }\n    /**\n     * Expand the term or prefix of the given term if it has one,\n     * otherwise return the term as-is.\n     *\n     * This will try to expand the IRI as much as possible.\n     *\n     * Iff in vocab-mode, then other references to other terms in the context can be used,\n     * such as to `myTerm`:\n     * ```\n     * {\n     *   \"myTerm\": \"http://example.org/myLongTerm\"\n     * }\n     * ```\n     *\n     * @param {string} term A term that is an URL or a prefixed URL.\n     * @param {boolean} expandVocab If the term is a predicate or type and should be expanded based on @vocab,\n     *                              otherwise it is considered a regular term that is expanded based on @base.\n     * @param {IExpandOptions} options Options that define the way how expansion must be done.\n     * @return {string} The expanded term, the term as-is, or null if it was explicitly disabled in the context.\n     * @throws If the term is aliased to an invalid value (not a string, IRI or keyword).\n     */\n    expandTerm(term, expandVocab, options = ContextParser_1.defaultExpandOptions) {\n        const contextValue = this.contextRaw[term];\n        // Immediately return if the term was disabled in the context\n        if (contextValue === null || (contextValue && contextValue['@id'] === null)) {\n            return null;\n        }\n        // Check the @id\n        let validIriMapping = true;\n        if (contextValue && expandVocab) {\n            const value = Util_1.Util.getContextValueId(contextValue);\n            if (value && value !== term) {\n                if (typeof value !== 'string' || (!Util_1.Util.isValidIri(value) && !Util_1.Util.isValidKeyword(value))) {\n                    // Don't mark this mapping as invalid if we have an unknown keyword, but of the correct form.\n                    if (!Util_1.Util.isPotentialKeyword(value)) {\n                        validIriMapping = false;\n                    }\n                }\n                else {\n                    return value;\n                }\n            }\n        }\n        // Check if the term is prefixed\n        const prefix = Util_1.Util.getPrefix(term, this.contextRaw);\n        const vocab = this.contextRaw['@vocab'];\n        const vocabRelative = (!!vocab || vocab === '') && vocab.indexOf(':') < 0;\n        const base = this.contextRaw['@base'];\n        const potentialKeyword = Util_1.Util.isPotentialKeyword(term);\n        if (prefix) {\n            const contextPrefixValue = this.contextRaw[prefix];\n            const value = Util_1.Util.getContextValueId(contextPrefixValue);\n            if (value) {\n                if (typeof contextPrefixValue === 'string' || !options.allowPrefixForcing) {\n                    // If we have a simple term definition,\n                    // check the last character of the prefix to determine whether or not it is a prefix.\n                    // Validate that prefix ends with gen-delim character, unless @prefix is true\n                    if (!Util_1.Util.isSimpleTermDefinitionPrefix(value, options)) {\n                        // Treat the term as an absolute IRI\n                        return term;\n                    }\n                }\n                else {\n                    // If we have an expanded term definition, default to @prefix: false\n                    if (value[0] !== '_' && !potentialKeyword && !contextPrefixValue['@prefix'] && !(term in this.contextRaw)) {\n                        // Treat the term as an absolute IRI\n                        return term;\n                    }\n                }\n                return value + term.substr(prefix.length + 1);\n            }\n        }\n        else if (expandVocab && ((vocab || vocab === '') || (options.allowVocabRelativeToBase && (base && vocabRelative)))\n            && !potentialKeyword && !Util_1.Util.isCompactIri(term)) {\n            if (vocabRelative) {\n                if (options.allowVocabRelativeToBase) {\n                    return relative_to_absolute_iri_1.resolve(vocab, base) + term;\n                }\n                else {\n                    throw new ErrorCoded_1.ErrorCoded(`Relative vocab expansion for term '${term}' with vocab '${vocab}' is not allowed.`, ErrorCoded_1.ERROR_CODES.INVALID_VOCAB_MAPPING);\n                }\n            }\n            else {\n                return vocab + term;\n            }\n        }\n        else if (!expandVocab && base && !potentialKeyword && !Util_1.Util.isCompactIri(term)) {\n            return relative_to_absolute_iri_1.resolve(term, base);\n        }\n        // Return the term as-is, unless we discovered an invalid IRI mapping for this term in the context earlier.\n        if (validIriMapping) {\n            return term;\n        }\n        else {\n            throw new ErrorCoded_1.ErrorCoded(`Invalid IRI mapping found for context entry '${term}': '${JSON.stringify(contextValue)}'`, ErrorCoded_1.ERROR_CODES.INVALID_IRI_MAPPING);\n        }\n    }\n    /**\n     * Compact the given term using @base, @vocab, an aliased term, or a prefixed term.\n     *\n     * This will try to compact the IRI as much as possible.\n     *\n     * @param {string} iri An IRI to compact.\n     * @param {boolean} vocab If the term is a predicate or type and should be compacted based on @vocab,\n     *                        otherwise it is considered a regular term that is compacted based on @base.\n     * @return {string} The compacted term or the IRI as-is.\n     */\n    compactIri(iri, vocab) {\n        // Try @vocab compacting\n        if (vocab && this.contextRaw['@vocab'] && iri.startsWith(this.contextRaw['@vocab'])) {\n            return iri.substr(this.contextRaw['@vocab'].length);\n        }\n        // Try @base compacting\n        if (!vocab && this.contextRaw['@base'] && iri.startsWith(this.contextRaw['@base'])) {\n            return iri.substr(this.contextRaw['@base'].length);\n        }\n        // Loop over all terms in the context\n        // This will try to prefix as short as possible.\n        // Once a fully compacted alias is found, return immediately, as we can not go any shorter.\n        const shortestPrefixing = { prefix: '', suffix: iri };\n        for (const key in this.contextRaw) {\n            const value = this.contextRaw[key];\n            if (value && !Util_1.Util.isPotentialKeyword(key)) {\n                const contextIri = Util_1.Util.getContextValueId(value);\n                if (iri.startsWith(contextIri)) {\n                    const suffix = iri.substr(contextIri.length);\n                    if (!suffix) {\n                        if (vocab) {\n                            // Immediately return on compacted alias\n                            return key;\n                        }\n                    }\n                    else if (suffix.length < shortestPrefixing.suffix.length) {\n                        // Overwrite the shortest prefix\n                        shortestPrefixing.prefix = key;\n                        shortestPrefixing.suffix = suffix;\n                    }\n                }\n            }\n        }\n        // Return the shortest prefix\n        if (shortestPrefixing.prefix) {\n            return shortestPrefixing.prefix + ':' + shortestPrefixing.suffix;\n        }\n        return iri;\n    }\n}\nexports.JsonLdContextNormalized = JsonLdContextNormalized;\n//# sourceMappingURL=JsonLdContextNormalized.js.map","function DefaultGraph () {\n  this.value = ''\n}\n\nDefaultGraph.prototype.equals = function (other) {\n  return !!other && other.termType === this.termType\n}\n\nDefaultGraph.prototype.termType = 'DefaultGraph'\n\nmodule.exports = DefaultGraph\n","function NamedNode (iri) {\n  this.value = iri\n}\n\nNamedNode.prototype.equals = function (other) {\n  return !!other && other.termType === this.termType && other.value === this.value\n}\n\nNamedNode.prototype.termType = 'NamedNode'\n\nmodule.exports = NamedNode\n","var support = {\n  searchParams: 'URLSearchParams' in self,\n  iterable: 'Symbol' in self && 'iterator' in Symbol,\n  blob:\n    'FileReader' in self &&\n    'Blob' in self &&\n    (function() {\n      try {\n        new Blob()\n        return true\n      } catch (e) {\n        return false\n      }\n    })(),\n  formData: 'FormData' in self,\n  arrayBuffer: 'ArrayBuffer' in self\n}\n\nfunction isDataView(obj) {\n  return obj && DataView.prototype.isPrototypeOf(obj)\n}\n\nif (support.arrayBuffer) {\n  var viewClasses = [\n    '[object Int8Array]',\n    '[object Uint8Array]',\n    '[object Uint8ClampedArray]',\n    '[object Int16Array]',\n    '[object Uint16Array]',\n    '[object Int32Array]',\n    '[object Uint32Array]',\n    '[object Float32Array]',\n    '[object Float64Array]'\n  ]\n\n  var isArrayBufferView =\n    ArrayBuffer.isView ||\n    function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n}\n\nfunction normalizeName(name) {\n  if (typeof name !== 'string') {\n    name = String(name)\n  }\n  if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n    throw new TypeError('Invalid character in header field name')\n  }\n  return name.toLowerCase()\n}\n\nfunction normalizeValue(value) {\n  if (typeof value !== 'string') {\n    value = String(value)\n  }\n  return value\n}\n\n// Build a destructive iterator for the value list\nfunction iteratorFor(items) {\n  var iterator = {\n    next: function() {\n      var value = items.shift()\n      return {done: value === undefined, value: value}\n    }\n  }\n\n  if (support.iterable) {\n    iterator[Symbol.iterator] = function() {\n      return iterator\n    }\n  }\n\n  return iterator\n}\n\nexport function Headers(headers) {\n  this.map = {}\n\n  if (headers instanceof Headers) {\n    headers.forEach(function(value, name) {\n      this.append(name, value)\n    }, this)\n  } else if (Array.isArray(headers)) {\n    headers.forEach(function(header) {\n      this.append(header[0], header[1])\n    }, this)\n  } else if (headers) {\n    Object.getOwnPropertyNames(headers).forEach(function(name) {\n      this.append(name, headers[name])\n    }, this)\n  }\n}\n\nHeaders.prototype.append = function(name, value) {\n  name = normalizeName(name)\n  value = normalizeValue(value)\n  var oldValue = this.map[name]\n  this.map[name] = oldValue ? oldValue + ', ' + value : value\n}\n\nHeaders.prototype['delete'] = function(name) {\n  delete this.map[normalizeName(name)]\n}\n\nHeaders.prototype.get = function(name) {\n  name = normalizeName(name)\n  return this.has(name) ? this.map[name] : null\n}\n\nHeaders.prototype.has = function(name) {\n  return this.map.hasOwnProperty(normalizeName(name))\n}\n\nHeaders.prototype.set = function(name, value) {\n  this.map[normalizeName(name)] = normalizeValue(value)\n}\n\nHeaders.prototype.forEach = function(callback, thisArg) {\n  for (var name in this.map) {\n    if (this.map.hasOwnProperty(name)) {\n      callback.call(thisArg, this.map[name], name, this)\n    }\n  }\n}\n\nHeaders.prototype.keys = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push(name)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.values = function() {\n  var items = []\n  this.forEach(function(value) {\n    items.push(value)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.entries = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push([name, value])\n  })\n  return iteratorFor(items)\n}\n\nif (support.iterable) {\n  Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n}\n\nfunction consumed(body) {\n  if (body.bodyUsed) {\n    return Promise.reject(new TypeError('Already read'))\n  }\n  body.bodyUsed = true\n}\n\nfunction fileReaderReady(reader) {\n  return new Promise(function(resolve, reject) {\n    reader.onload = function() {\n      resolve(reader.result)\n    }\n    reader.onerror = function() {\n      reject(reader.error)\n    }\n  })\n}\n\nfunction readBlobAsArrayBuffer(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsArrayBuffer(blob)\n  return promise\n}\n\nfunction readBlobAsText(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsText(blob)\n  return promise\n}\n\nfunction readArrayBufferAsText(buf) {\n  var view = new Uint8Array(buf)\n  var chars = new Array(view.length)\n\n  for (var i = 0; i < view.length; i++) {\n    chars[i] = String.fromCharCode(view[i])\n  }\n  return chars.join('')\n}\n\nfunction bufferClone(buf) {\n  if (buf.slice) {\n    return buf.slice(0)\n  } else {\n    var view = new Uint8Array(buf.byteLength)\n    view.set(new Uint8Array(buf))\n    return view.buffer\n  }\n}\n\nfunction Body() {\n  this.bodyUsed = false\n\n  this._initBody = function(body) {\n    this._bodyInit = body\n    if (!body) {\n      this._bodyText = ''\n    } else if (typeof body === 'string') {\n      this._bodyText = body\n    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n      this._bodyBlob = body\n    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n      this._bodyFormData = body\n    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n      this._bodyText = body.toString()\n    } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n      this._bodyArrayBuffer = bufferClone(body.buffer)\n      // IE 10-11 can't handle a DataView body.\n      this._bodyInit = new Blob([this._bodyArrayBuffer])\n    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n      this._bodyArrayBuffer = bufferClone(body)\n    } else {\n      this._bodyText = body = Object.prototype.toString.call(body)\n    }\n\n    if (!this.headers.get('content-type')) {\n      if (typeof body === 'string') {\n        this.headers.set('content-type', 'text/plain;charset=UTF-8')\n      } else if (this._bodyBlob && this._bodyBlob.type) {\n        this.headers.set('content-type', this._bodyBlob.type)\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n      }\n    }\n  }\n\n  if (support.blob) {\n    this.blob = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return Promise.resolve(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as blob')\n      } else {\n        return Promise.resolve(new Blob([this._bodyText]))\n      }\n    }\n\n    this.arrayBuffer = function() {\n      if (this._bodyArrayBuffer) {\n        return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n      } else {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n    }\n  }\n\n  this.text = function() {\n    var rejected = consumed(this)\n    if (rejected) {\n      return rejected\n    }\n\n    if (this._bodyBlob) {\n      return readBlobAsText(this._bodyBlob)\n    } else if (this._bodyArrayBuffer) {\n      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n    } else if (this._bodyFormData) {\n      throw new Error('could not read FormData body as text')\n    } else {\n      return Promise.resolve(this._bodyText)\n    }\n  }\n\n  if (support.formData) {\n    this.formData = function() {\n      return this.text().then(decode)\n    }\n  }\n\n  this.json = function() {\n    return this.text().then(JSON.parse)\n  }\n\n  return this\n}\n\n// HTTP methods whose capitalization should be normalized\nvar methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\nfunction normalizeMethod(method) {\n  var upcased = method.toUpperCase()\n  return methods.indexOf(upcased) > -1 ? upcased : method\n}\n\nexport function Request(input, options) {\n  options = options || {}\n  var body = options.body\n\n  if (input instanceof Request) {\n    if (input.bodyUsed) {\n      throw new TypeError('Already read')\n    }\n    this.url = input.url\n    this.credentials = input.credentials\n    if (!options.headers) {\n      this.headers = new Headers(input.headers)\n    }\n    this.method = input.method\n    this.mode = input.mode\n    this.signal = input.signal\n    if (!body && input._bodyInit != null) {\n      body = input._bodyInit\n      input.bodyUsed = true\n    }\n  } else {\n    this.url = String(input)\n  }\n\n  this.credentials = options.credentials || this.credentials || 'same-origin'\n  if (options.headers || !this.headers) {\n    this.headers = new Headers(options.headers)\n  }\n  this.method = normalizeMethod(options.method || this.method || 'GET')\n  this.mode = options.mode || this.mode || null\n  this.signal = options.signal || this.signal\n  this.referrer = null\n\n  if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n    throw new TypeError('Body not allowed for GET or HEAD requests')\n  }\n  this._initBody(body)\n}\n\nRequest.prototype.clone = function() {\n  return new Request(this, {body: this._bodyInit})\n}\n\nfunction decode(body) {\n  var form = new FormData()\n  body\n    .trim()\n    .split('&')\n    .forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n  return form\n}\n\nfunction parseHeaders(rawHeaders) {\n  var headers = new Headers()\n  // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n  // https://tools.ietf.org/html/rfc7230#section-3.2\n  var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ')\n  preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n    var parts = line.split(':')\n    var key = parts.shift().trim()\n    if (key) {\n      var value = parts.join(':').trim()\n      headers.append(key, value)\n    }\n  })\n  return headers\n}\n\nBody.call(Request.prototype)\n\nexport function Response(bodyInit, options) {\n  if (!options) {\n    options = {}\n  }\n\n  this.type = 'default'\n  this.status = options.status === undefined ? 200 : options.status\n  this.ok = this.status >= 200 && this.status < 300\n  this.statusText = 'statusText' in options ? options.statusText : 'OK'\n  this.headers = new Headers(options.headers)\n  this.url = options.url || ''\n  this._initBody(bodyInit)\n}\n\nBody.call(Response.prototype)\n\nResponse.prototype.clone = function() {\n  return new Response(this._bodyInit, {\n    status: this.status,\n    statusText: this.statusText,\n    headers: new Headers(this.headers),\n    url: this.url\n  })\n}\n\nResponse.error = function() {\n  var response = new Response(null, {status: 0, statusText: ''})\n  response.type = 'error'\n  return response\n}\n\nvar redirectStatuses = [301, 302, 303, 307, 308]\n\nResponse.redirect = function(url, status) {\n  if (redirectStatuses.indexOf(status) === -1) {\n    throw new RangeError('Invalid status code')\n  }\n\n  return new Response(null, {status: status, headers: {location: url}})\n}\n\nexport var DOMException = self.DOMException\ntry {\n  new DOMException()\n} catch (err) {\n  DOMException = function(message, name) {\n    this.message = message\n    this.name = name\n    var error = Error(message)\n    this.stack = error.stack\n  }\n  DOMException.prototype = Object.create(Error.prototype)\n  DOMException.prototype.constructor = DOMException\n}\n\nexport function fetch(input, init) {\n  return new Promise(function(resolve, reject) {\n    var request = new Request(input, init)\n\n    if (request.signal && request.signal.aborted) {\n      return reject(new DOMException('Aborted', 'AbortError'))\n    }\n\n    var xhr = new XMLHttpRequest()\n\n    function abortXhr() {\n      xhr.abort()\n    }\n\n    xhr.onload = function() {\n      var options = {\n        status: xhr.status,\n        statusText: xhr.statusText,\n        headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n      }\n      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n      var body = 'response' in xhr ? xhr.response : xhr.responseText\n      resolve(new Response(body, options))\n    }\n\n    xhr.onerror = function() {\n      reject(new TypeError('Network request failed'))\n    }\n\n    xhr.ontimeout = function() {\n      reject(new TypeError('Network request failed'))\n    }\n\n    xhr.onabort = function() {\n      reject(new DOMException('Aborted', 'AbortError'))\n    }\n\n    xhr.open(request.method, request.url, true)\n\n    if (request.credentials === 'include') {\n      xhr.withCredentials = true\n    } else if (request.credentials === 'omit') {\n      xhr.withCredentials = false\n    }\n\n    if ('responseType' in xhr && support.blob) {\n      xhr.responseType = 'blob'\n    }\n\n    request.headers.forEach(function(value, name) {\n      xhr.setRequestHeader(name, value)\n    })\n\n    if (request.signal) {\n      request.signal.addEventListener('abort', abortXhr)\n\n      xhr.onreadystatechange = function() {\n        // DONE (success or failure)\n        if (xhr.readyState === 4) {\n          request.signal.removeEventListener('abort', abortXhr)\n        }\n      }\n    }\n\n    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n  })\n}\n\nfetch.polyfill = true\n\nif (!self.fetch) {\n  self.fetch = fetch\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Convert the given relative IRI to an absolute IRI\n * by taking into account the given optional baseIRI.\n *\n * @param {string} relativeIRI The relative IRI to convert to an absolute IRI.\n * @param {string} baseIRI The optional base IRI.\n * @return {string} an absolute IRI.\n */\nfunction resolve(relativeIRI, baseIRI) {\n    baseIRI = baseIRI || '';\n    const baseFragmentPos = baseIRI.indexOf('#');\n    // Ignore any fragments in the base IRI\n    if (baseFragmentPos > 0) {\n        baseIRI = baseIRI.substr(0, baseFragmentPos);\n    }\n    // Convert empty value directly to base IRI\n    if (!relativeIRI.length) {\n        return baseIRI;\n    }\n    // If the value starts with a query character, concat directly (but strip the existing query)\n    if (relativeIRI.startsWith('?')) {\n        const baseQueryPos = baseIRI.indexOf('?');\n        if (baseQueryPos > 0) {\n            baseIRI = baseIRI.substr(0, baseQueryPos);\n        }\n        return baseIRI + relativeIRI;\n    }\n    // If the value starts with a fragment character, concat directly\n    if (relativeIRI.startsWith('#')) {\n        return baseIRI + relativeIRI;\n    }\n    // Ignore baseIRI if it is empty\n    if (!baseIRI.length) {\n        return removeDotSegmentsOfPath(relativeIRI, relativeIRI.indexOf(':'));\n    }\n    // Ignore baseIRI if the value is absolute\n    const valueColonPos = relativeIRI.indexOf(':');\n    if (valueColonPos >= 0) {\n        return removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // At this point, the baseIRI MUST be absolute, otherwise we error\n    const baseColonPos = baseIRI.indexOf(':');\n    if (baseColonPos < 0) {\n        throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n    }\n    const baseIRIScheme = baseIRI.substr(0, baseColonPos + 1);\n    // Inherit the baseIRI scheme if the value starts with '//'\n    if (relativeIRI.indexOf('//') === 0) {\n        return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // Check cases where '://' occurs in the baseIRI, and where there is no '/' after a ':' anymore.\n    let baseSlashAfterColonPos;\n    if (baseIRI.indexOf('//', baseColonPos) === baseColonPos + 1) {\n        // If there is no additional '/' after the '//'.\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 3);\n        if (baseSlashAfterColonPos < 0) {\n            // If something other than a '/' follows the '://', append the value after a '/',\n            // otherwise, prefix the value with only the baseIRI scheme.\n            if (baseIRI.length > baseColonPos + 3) {\n                return baseIRI + '/' + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n            else {\n                return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n        }\n    }\n    else {\n        // If there is not even a single '/' after the ':'\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 1);\n        if (baseSlashAfterColonPos < 0) {\n            // If we don't have a '/' after the ':',\n            // prefix the value with only the baseIRI scheme.\n            return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n        }\n    }\n    // If the value starts with a '/', then prefix it with everything before the first effective slash of the base IRI.\n    if (relativeIRI.indexOf('/') === 0) {\n        return baseIRI.substr(0, baseSlashAfterColonPos) + removeDotSegments(relativeIRI);\n    }\n    let baseIRIPath = baseIRI.substr(baseSlashAfterColonPos);\n    const baseIRILastSlashPos = baseIRIPath.lastIndexOf('/');\n    // Ignore everything after the last '/' in the baseIRI path\n    if (baseIRILastSlashPos >= 0 && baseIRILastSlashPos < baseIRIPath.length - 1) {\n        baseIRIPath = baseIRIPath.substr(0, baseIRILastSlashPos + 1);\n        // Also remove the first character of the relative path if it starts with '.' (and not '..' or './')\n        // This change is only allowed if there is something else following the path\n        if (relativeIRI[0] === '.' && relativeIRI[1] !== '.' && relativeIRI[1] !== '/' && relativeIRI[2]) {\n            relativeIRI = relativeIRI.substr(1);\n        }\n    }\n    // Prefix the value with the baseIRI path where\n    relativeIRI = baseIRIPath + relativeIRI;\n    // Remove dot segment from the IRI\n    relativeIRI = removeDotSegments(relativeIRI);\n    // Prefix our transformed value with the part of the baseIRI until the first '/' after the first ':'.\n    return baseIRI.substr(0, baseSlashAfterColonPos) + relativeIRI;\n}\nexports.resolve = resolve;\n/**\n * Remove dot segments from the given path,\n * as described in https://www.ietf.org/rfc/rfc3986.txt (page 32).\n * @param {string} path An IRI path.\n * @return {string} A path, will always start with a '/'.\n */\nfunction removeDotSegments(path) {\n    // Prepare a buffer with segments between each '/.\n    // Each segment represents an array of characters.\n    const segmentBuffers = [];\n    let i = 0;\n    while (i < path.length) {\n        // Remove '/.' or '/..'\n        switch (path[i]) {\n            case '/':\n                if (path[i + 1] === '.') {\n                    if (path[i + 2] === '.') {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 3])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Go to parent directory,\n                        // so we remove a parent segment\n                        segmentBuffers.pop();\n                        // Ensure that we end with a slash if there is a trailing '/..'\n                        if (!path[i + 3]) {\n                            segmentBuffers.push([]);\n                        }\n                        i += 3;\n                    }\n                    else {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 2])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Ensure that we end with a slash if there is a trailing '/.'\n                        if (!path[i + 2]) {\n                            segmentBuffers.push([]);\n                        }\n                        // Go to the current directory,\n                        // so we do nothing\n                        i += 2;\n                    }\n                }\n                else {\n                    // Start a new segment\n                    segmentBuffers.push([]);\n                    i++;\n                }\n                break;\n            case '#':\n            case '?':\n                // Query and fragment string should be appended unchanged\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path.substr(i));\n                // Break the while loop\n                i = path.length;\n                break;\n            default:\n                // Not a special character, just append it to our buffer\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path[i]);\n                i++;\n                break;\n        }\n    }\n    return '/' + segmentBuffers.map((buffer) => buffer.join('')).join('/');\n}\nexports.removeDotSegments = removeDotSegments;\n/**\n * Removes dot segments of the given IRI.\n * @param {string} iri An IRI (or part of IRI).\n * @param {number} colonPosition The position of the first ':' in the IRI.\n * @return {string} The IRI where dot segments were removed.\n */\nfunction removeDotSegmentsOfPath(iri, colonPosition) {\n    // Determine where we should start looking for the first '/' that indicates the start of the path\n    let searchOffset = colonPosition + 1;\n    if (colonPosition >= 0) {\n        if (iri[colonPosition + 1] === '/' && iri[colonPosition + 2] === '/') {\n            searchOffset = colonPosition + 3;\n        }\n    }\n    else {\n        if (iri[0] === '/' && iri[1] === '/') {\n            searchOffset = 2;\n        }\n    }\n    // Determine the path\n    const pathSeparator = iri.indexOf('/', searchOffset);\n    if (pathSeparator < 0) {\n        return iri;\n    }\n    const base = iri.substr(0, pathSeparator);\n    const path = iri.substr(pathSeparator);\n    // Remove dot segments from the path\n    return base + removeDotSegments(path);\n}\nexports.removeDotSegmentsOfPath = removeDotSegmentsOfPath;\nfunction isCharacterAllowedAfterRelativePathSegment(character) {\n    return !character || character === '#' || character === '?' || character === '/';\n}\n//# sourceMappingURL=Resolve.js.map","/* jshint esversion: 6 */\n/* jslint node: true */\n'use strict';\n\nmodule.exports = function (object) {\n  return serialize(object);\n\n  function serialize (object) {\n    if (object === null || typeof object !== 'object' || object.toJSON != null) {\n      return JSON.stringify(object);\n    }\n    if (Array.isArray(object) && object.length === 0) {\n      return '[]';\n    }\n    if (Array.isArray(object) && object.length === 1) {\n      return '[' + serialize(object[0]) + ']';\n    }\n    if (Array.isArray(object)) {\n      return '[' + object.reduce((t, cv, ci) => {\n        t = (ci === 1 ? serialize(t) : t);\n        return t + ',' + serialize(cv);\n      }) + ']';\n    }\n    const keys = Object.keys(object);\n    if (keys.length === 0) {\n      return '{}';\n    }\n    if (keys.length === 1) {\n      return '{' + serialize(keys[0]) + ':' + serialize(object[keys[0]]) + '}';\n    }\n    return '{' + keys.sort().reduce((t, cv, ci) => {\n      t = (ci === 1 ? serialize(t) + ':' + serialize(object[t]) : t);\n      return t + ',' + serialize(cv) + ':' + serialize(object[cv]);\n    }) + '}';\n  }\n};\n","var BlankNode = require('./blank-node')\nvar DefaultGraph = require('./default-graph')\nvar Literal = require('./literal')\nvar NamedNode = require('./named-node')\nvar Quad = require('./quad')\nvar Variable = require('./variable')\n\nfunction DataFactory () {}\n\nDataFactory.namedNode = function (value) {\n  return new NamedNode(value)\n}\n\nDataFactory.blankNode = function (value) {\n  return new BlankNode(value)\n}\n\nDataFactory.literal = function (value, languageOrDatatype) {\n  if (typeof languageOrDatatype === 'string') {\n    if (languageOrDatatype.indexOf(':') === -1) {\n      return new Literal(value, languageOrDatatype)\n    }\n\n    return new Literal(value, null, DataFactory.namedNode(languageOrDatatype))\n  }\n\n  return new Literal(value, null, languageOrDatatype)\n}\n\nDataFactory.defaultGraph = function () {\n  return DataFactory.defaultGraphInstance\n}\n\nDataFactory.variable = function (value) {\n  return new Variable(value)\n}\n\nDataFactory.triple = function (subject, predicate, object) {\n  return DataFactory.quad(subject, predicate, object)\n}\n\nDataFactory.quad = function (subject, predicate, object, graph) {\n  return new Quad(subject, predicate, object, graph || DataFactory.defaultGraphInstance)\n}\n\nDataFactory.defaultGraphInstance = new DefaultGraph()\n\nmodule.exports = DataFactory\n","function BlankNode (id) {\n  this.value = id || ('b' + (++BlankNode.nextId))\n}\n\nBlankNode.prototype.equals = function (other) {\n  return !!other && other.termType === this.termType && other.value === this.value\n}\n\nBlankNode.prototype.termType = 'BlankNode'\n\nBlankNode.nextId = 0\n\nmodule.exports = BlankNode\n","var NamedNode = require('./named-node')\n\nfunction Literal (value, language, datatype) {\n  this.value = value\n  this.datatype = Literal.stringDatatype\n  this.language = ''\n\n  if (language) {\n    this.language = language\n    this.datatype = Literal.langStringDatatype\n  } else if (datatype) {\n    this.datatype = datatype\n  }\n}\n\nLiteral.prototype.equals = function (other) {\n  return !!other && other.termType === this.termType && other.value === this.value &&\n    other.language === this.language && other.datatype.equals(this.datatype)\n}\n\nLiteral.prototype.termType = 'Literal'\nLiteral.langStringDatatype = new NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString')\nLiteral.stringDatatype = new NamedNode('http://www.w3.org/2001/XMLSchema#string')\n\nmodule.exports = Literal\n","var DefaultGraph = require('./default-graph')\n\nfunction Quad (subject, predicate, object, graph) {\n  this.subject = subject\n  this.predicate = predicate\n  this.object = object\n\n  if (graph) {\n    this.graph = graph\n  } else {\n    this.graph = new DefaultGraph()\n  }\n}\n\nQuad.prototype.equals = function (other) {\n  return !!other && other.subject.equals(this.subject) && other.predicate.equals(this.predicate) &&\n    other.object.equals(this.object) && other.graph.equals(this.graph)\n}\n\nmodule.exports = Quad\n","function Variable (name) {\n  this.value = name\n}\n\nVariable.prototype.equals = function (other) {\n  return !!other && other.termType === this.termType && other.value === this.value\n}\n\nVariable.prototype.termType = 'Variable'\n\nmodule.exports = Variable\n","function _asyncIterator(iterable) { var method; if (typeof Symbol !== \"undefined\") { if (Symbol.asyncIterator) { method = iterable[Symbol.asyncIterator]; if (method != null) return method.call(iterable); } if (Symbol.iterator) { method = iterable[Symbol.iterator]; if (method != null) return method.call(iterable); } } throw new TypeError(\"Object is not async iterable\"); }\n\nconst done = {};\n/**\n * Returns the elements of the iterable as an array\n */\n\nexport async function iterableToArray(iterable) {\n  const items = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n\n  var _iteratorError;\n\n  try {\n    for (var _iterator = _asyncIterator(iterable), _step, _value; _step = await _iterator.next(), _iteratorNormalCompletion = _step.done, _value = await _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n      const item = _value;\n      items.push(item);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        await _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return items;\n}\n/**\n * Gets the first element of the iterable.\n */\n\nexport function getFirstItem(iterable) {\n  const iterator = iterable[Symbol.asyncIterator]();\n  return iterator.next().then(item => item.value);\n}\n/**\n * Creates an async iterator with the item as only element.\n */\n\nexport function iteratorFor(item) {\n  return {\n    async next() {\n      if (item !== done) {\n        const value = await item;\n        item = done;\n        return {\n          value\n        };\n      }\n\n      return {\n        done: true\n      };\n    }\n\n  };\n}","/**\n * Resolves to the given item in the path data.\n * For example, new DataHandler({}, 'foo', 'bar')\n * will return pathData.foo.bar.\n *\n * Resolution can optionally be async,\n * and/or be behind a function call.\n */\nexport default class DataHandler {\n  constructor(options, ...dataProperties) {\n    this._isAsync = options.async;\n    this._isFunction = options.function;\n    this._dataProperties = dataProperties;\n  }\n\n  static sync(...dataProperties) {\n    return new DataHandler({\n      async: false\n    }, ...dataProperties);\n  }\n\n  static syncFunction(...dataProperties) {\n    return new DataHandler({\n      async: false,\n      function: true\n    }, ...dataProperties);\n  }\n\n  static async(...dataProperties) {\n    return new DataHandler({\n      async: true\n    }, ...dataProperties);\n  }\n\n  static asyncFunction(...dataProperties) {\n    return new DataHandler({\n      async: true,\n      function: true\n    }, ...dataProperties);\n  } // Resolves the data path, or returns a function that does so\n\n\n  handle(pathData) {\n    return !this._isFunction ? this._resolveDataPath(pathData) : () => this._resolveDataPath(pathData);\n  } // Resolves the data path\n\n\n  _resolveDataPath(data) {\n    return !this._isAsync ? this._resolveSyncDataPath(data) : this._resolveAsyncDataPath(data);\n  } // Resolves synchronous property access\n\n\n  _resolveSyncDataPath(data) {\n    for (const property of this._dataProperties) data = data && data[property];\n\n    return data;\n  } // Resolves asynchronous property access\n\n\n  async _resolveAsyncDataPath(data) {\n    for (const property of this._dataProperties) data = data && (await data[property]);\n\n    return data;\n  }\n\n}","import { getFirstItem } from './iterableUtils';\n/**\n * Returns a lazy thenable to the created promise.\n */\n\nexport function lazyThenable(createPromise) {\n  return {\n    then: getThen(createPromise)\n  };\n}\n/**\n * Lazily returns the `then` function of the created promise.\n */\n\nexport function getThen(createPromise) {\n  return (onResolved, onRejected) => createPromise().then(onResolved, onRejected);\n}\n/**\n * Returns an iterable that is also a promise to the first element.\n */\n\nexport function toIterablePromise(iterable) {\n  // If called with a generator function,\n  // memoize it to enable multiple iterations\n  if (typeof iterable === 'function') iterable = memoizeIterable(iterable()); // Return an object that is iterable and a promise\n\n  return {\n    [Symbol.asyncIterator]() {\n      return iterable[Symbol.asyncIterator]();\n    },\n\n    get then() {\n      return getThen(() => getFirstItem(this));\n    },\n\n    catch(onRejected) {\n      return this.then(null, onRejected);\n    },\n\n    finally(callback) {\n      return this.then().finally(callback);\n    }\n\n  };\n}\n/**\n * Returns a memoized version of the iterable\n * that can be iterated over as many times as needed.\n */\n\nexport function memoizeIterable(iterable) {\n  const cache = [];\n  let iterator = iterable[Symbol.asyncIterator]();\n  return {\n    [Symbol.asyncIterator]() {\n      let i = 0;\n      return {\n        async next() {\n          // Return the item if it has been read already\n          if (i < cache.length) return cache[i++]; // Stop if there are no more items\n\n          if (!iterator) return {\n            done: true\n          }; // Read and cache an item from the iterable otherwise\n\n          const item = cache[i++] = iterator.next();\n          if ((await item).done) iterator = null;\n          return item;\n        }\n\n      };\n    }\n\n  };\n}","import { literal } from '@rdfjs/data-model'; // Checks whether the value is asynchronously iterable\n\nexport function isAsyncIterable(value) {\n  return value && typeof value[Symbol.asyncIterator] === 'function';\n} // Checks whether the value is an object without special meaning to LDflex\n\nexport function isPlainObject(value) {\n  return value !== null && // Ignore non-objects\n  typeof value === 'object' && // Ignore arrays\n  !Array.isArray(value) && // Ignore Promise instances\n  typeof value.then !== 'function' && // Ignore RDF/JS Term instances\n  typeof value.termType !== 'string' && // Ignore LDflex paths\n  !isAsyncIterable(value);\n} // Checks whether the arguments consist of exactly one plain object\n\nexport function hasPlainObjectArgs(args, allowMultiple = false) {\n  const hasPlainObject = args.some(isPlainObject);\n  if (hasPlainObject && !allowMultiple && args.length !== 1) throw new Error(`Expected only 1 plain object, but got ${args.length} arguments`);\n  return hasPlainObject;\n} // Ensures that the value is an array\n\nexport function ensureArray(value) {\n  if (Array.isArray(value)) return value;\n  return value ? [value] : [];\n} // Joins the arrays into a single array\n\nexport function joinArrays(arrays) {\n  return [].concat(...arrays);\n} // Ensures the value is an RDF/JS term\n\nexport function valueToTerm(value) {\n  if (typeof value === 'string') return literal(value);\n  if (value && typeof value.termType === 'string') return value;\n  throw new Error(`Invalid object: ${value}`);\n}","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { lazyThenable } from './promiseUtils';\nimport { iterableToArray } from './iterableUtils';\nimport { ensureArray, joinArrays, valueToTerm, hasPlainObjectArgs, isAsyncIterable } from './valueUtils';\n/**\n * Returns a function that, when called with arguments,\n * extends the path with mutationExpressions.\n *\n * Mutation functions can be called in two equivalent ways:\n * - path.property.set(object, object)\n * - path.set({ property: [object, object] })\n * Objects can be strings, terms, or path expressions.\n * The second syntax allows setting multiple properties at once.\n * It also has `null` and `undefined` as shortcuts for the empty array,\n * and a direct value as shortcut for a single-valued array.\n *\n * Requires:\n * - a pathExpression property on the path proxy and all non-raw arguments.\n */\n\nexport default class MutationFunctionHandler {\n  constructor(mutationType, allowZeroArgs) {\n    this._mutationType = mutationType;\n    this._allowZeroArgs = allowZeroArgs;\n  } // Creates a function that performs a mutation\n\n\n  handle(pathData, path) {\n    return (...args) => {\n      // Check if the given arguments are valid\n      if (!this._allowZeroArgs && !args.length) throw new Error('Mutation cannot be invoked without arguments'); // Create a lazy Promise to the mutation expressions\n\n      const mutationExpressions = lazyThenable(() => this.createMutationExpressions(pathData, path, args));\n      return pathData.extendPath({\n        mutationExpressions\n      });\n    };\n  } // Creates expressions that represent the requested mutation\n\n\n  async createMutationExpressions(pathData, path, args) {\n    // The mutation targets a single property on the path by passing objects\n    if (!hasPlainObjectArgs(args)) return [await this.createMutationExpression(pathData, path, args)]; // The mutation targets multiple properties through a map of property-objects pairs\n\n    const pairs = Object.entries(args[0]);\n    const expressions = await Promise.all(pairs.map(([property, values]) => this.createMutationExpression(pathData, path[property], ensureArray(values)))); // Group expressions together to maintain the same structure as the singular case\n    // (All properties have the same parent path, and hence the same condition)\n\n    return [expressions.length === 0 ? {} : _objectSpread(_objectSpread({}, expressions[0]), {}, {\n      predicateObjects: joinArrays(expressions.map(e => e.predicateObjects))\n    })];\n  } // Creates an expression that represents a mutation with the given objects\n\n\n  async createMutationExpression(pathData, path, values) {\n    // Obtain the path segments, which are the selection conditions for the mutation\n    const conditions = await path.pathExpression;\n    if (!Array.isArray(conditions)) throw new Error(`${pathData} has no pathExpression property`);\n    if (conditions.length < 2) throw new Error(`${pathData} should at least contain a subject and a predicate`); // Obtain the predicate and target objects\n\n    const {\n      predicate,\n      reverse\n    } = conditions[conditions.length - 1];\n    if (!predicate) throw new Error(`Expected predicate in ${pathData}`);\n    const objects = await this.extractObjects(pathData, path, values); // Create a mutation, unless no objects are affected (`null` means all)\n\n    return objects !== null && objects.length === 0 ? {} : {\n      mutationType: this._mutationType,\n      conditions: conditions.slice(0, -1),\n      predicateObjects: [{\n        predicate,\n        reverse,\n        objects\n      }]\n    };\n  } // Extracts individual objects from a set of values passed to a mutation function\n\n\n  async extractObjects(pathData, path, values) {\n    // If no specific values are specified, match all (represented by `null`)\n    if (values.length === 0) return null; // Otherwise, expand singular values, promises, and paths\n\n    const objects = [];\n\n    for (const value of values) {\n      if (!isAsyncIterable(value)) // Add a (promise to) a single value\n        objects.push(await value); // Add multiple values from a path\n      else objects.push(...(await iterableToArray(value)));\n    }\n\n    return objects.map(valueToTerm);\n  }\n\n}","import MutationFunctionHandler from './MutationFunctionHandler';\n/**\n * A MutationFunctionHandler for deletions.\n */\n\nexport default class DeleteFunctionHandler extends MutationFunctionHandler {\n  constructor() {\n    super('DELETE', true);\n  }\n\n}","function _awaitAsyncGenerator(value) { return new _AwaitValue(value); }\n\nfunction _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }\n\nfunction _AsyncGenerator(gen) { var front, back; function send(key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; if (back) { back = back.next = request; } else { front = back = request; resume(key, arg); } }); } function resume(key, arg) { try { var result = gen[key](arg); var value = result.value; var wrappedAwait = value instanceof _AwaitValue; Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) { if (wrappedAwait) { resume(key === \"return\" ? \"return\" : \"next\", arg); return; } settle(result.done ? \"return\" : \"normal\", arg); }, function (err) { resume(\"throw\", err); }); } catch (err) { settle(\"throw\", err); } } function settle(type, value) { switch (type) { case \"return\": front.resolve({ value: value, done: true }); break; case \"throw\": front.reject(value); break; default: front.resolve({ value: value, done: false }); break; } front = front.next; if (front) { resume(front.key, front.arg); } else { back = null; } } this._invoke = send; if (typeof gen.return !== \"function\") { this.return = undefined; } }\n\nif (typeof Symbol === \"function\" && Symbol.asyncIterator) { _AsyncGenerator.prototype[Symbol.asyncIterator] = function () { return this; }; }\n\n_AsyncGenerator.prototype.next = function (arg) { return this._invoke(\"next\", arg); };\n\n_AsyncGenerator.prototype.throw = function (arg) { return this._invoke(\"throw\", arg); };\n\n_AsyncGenerator.prototype.return = function (arg) { return this._invoke(\"return\", arg); };\n\nfunction _AwaitValue(value) { this.wrapped = value; }\n\nfunction _asyncIterator(iterable) { var method; if (typeof Symbol !== \"undefined\") { if (Symbol.asyncIterator) { method = iterable[Symbol.asyncIterator]; if (method != null) return method.call(iterable); } if (Symbol.iterator) { method = iterable[Symbol.iterator]; if (method != null) return method.call(iterable); } } throw new TypeError(\"Object is not async iterable\"); }\n\n/**\n * Executes the query represented by a path.\n *\n * Requires:\n * - a queryEngine property in the path settings\n * - a sparql property on the path proxy\n * - (optional) a resultsCache property on the path data\n */\nexport default class ExecuteQueryHandler {\n  handle(pathData, path) {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      // Try to retrieve the result from cache\n      const resultsCache = yield _awaitAsyncGenerator(pathData.resultsCache);\n\n      if (resultsCache) {\n        for (const result of resultsCache) yield result;\n\n        return;\n      } // Retrieve the query engine and query\n\n\n      const {\n        queryEngine\n      } = pathData.settings;\n      if (!queryEngine) throw new Error(`${pathData} has no queryEngine setting`);\n      const query = yield _awaitAsyncGenerator(path.sparql);\n      if (query === null || query === undefined) throw new Error(`${pathData} has no sparql property`); // No results if the query is empty\n\n      if (query.length === 0) return; // Extract the term from every query result\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(queryEngine.execute(query)), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const bindings = _value;\n          yield _this.extractTerm(bindings, pathData);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _awaitAsyncGenerator(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    })();\n  }\n  /**\n   * Extracts the first term from a query result binding as a new path.\n   */\n\n\n  extractTerm(binding, pathData) {\n    // Extract the first term from the binding map\n    if (binding.size !== 1) throw new Error('Only single-variable queries are supported');\n    const subject = binding.values().next().value; // Each result is a new path that starts from the term as subject\n\n    return pathData.extendPath({\n      subject\n    }, null);\n  }\n\n}","function _asyncIterator(iterable) { var method; if (typeof Symbol !== \"undefined\") { if (Symbol.asyncIterator) { method = iterable[Symbol.asyncIterator]; if (method != null) return method.call(iterable); } if (Symbol.iterator) { method = iterable[Symbol.iterator]; if (method != null) return method.call(iterable); } } throw new TypeError(\"Object is not async iterable\"); }\n\nconst VARIABLE = /(SELECT\\s+)(\\?\\S+)/;\nconst QUERY_TAIL = /\\}[^}]*$/;\n/**\n * Returns a function that preloads and caches\n * certain properties of results on the current path.\n *\n * Requires:\n * - a predicate handler on the path proxy\n * - a queryEngine property in the path settings\n *\n * Creates:\n * - a resultsCache property on the path data\n */\n\nexport default class PreloadHandler {\n  /**\n   * Creates a preload function.\n   */\n  handle(pathData, pathProxy) {\n    return async (...properties) => {\n      if (properties.length > 0) {\n        // Map the properties to predicates\n        const predicates = await Promise.all(properties.map(async p => (await pathProxy[p].predicate).value)); // Create and attach the results cache to the path data\n\n        pathData.resultsCache = await this.createResultsCache(predicates, pathData, pathProxy);\n      }\n\n      return pathProxy;\n    };\n  }\n  /**\n   * Creates a cache for the results of\n   * resolving the given predicates against the path.\n   */\n\n\n  async createResultsCache(predicates, pathData, path) {\n    // Execute the preloading query\n    const {\n      query,\n      vars,\n      resultVar\n    } = await this.createQuery(predicates, path);\n    const {\n      settings: {\n        queryEngine\n      }\n    } = pathData;\n    const bindings = queryEngine.execute(query); // Extract all results and their preloaded property values\n\n    const resultsCache = {};\n    const propertyCaches = {};\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n\n    var _iteratorError;\n\n    try {\n      for (var _iterator = _asyncIterator(bindings), _step, _value; _step = await _iterator.next(), _iteratorNormalCompletion = _step.done, _value = await _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n        const binding = _value;\n        // Initialize the result's cache if needed\n        const result = binding.get(resultVar),\n              hash = hashTerm(result);\n\n        if (!(hash in resultsCache)) {\n          // Create the property cache\n          const propertyCache = propertyCaches[hash] = {};\n\n          for (const predicate of predicates) propertyCache[predicate] = []; // Create the result path\n\n\n          const resultData = {\n            subject: result,\n            propertyCache\n          };\n          resultsCache[hash] = pathData.extendPath(resultData, null);\n        } // Create and cache a possible property value path from the binding\n\n\n        const propertyCache = propertyCaches[hash];\n\n        for (let i = 0; i < vars.length; i++) {\n          const value = binding.get(vars[i]);\n\n          if (value) {\n            const valuePath = pathData.extendPath({\n              subject: value\n            }, null);\n            propertyCache[predicates[i]].push(valuePath);\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          await _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return Object.values(resultsCache);\n  }\n  /**\n   * Creates the query for preloading the given predicates on the path\n   */\n\n\n  async createQuery(predicates, path) {\n    // Obtain the query for the current path, and its main variable\n    const parentQuery = await path.sparql;\n    const variableMatch = VARIABLE.exec(parentQuery);\n    if (!variableMatch) throw new Error(`Unexpected path query: ${parentQuery}`);\n    const resultVar = variableMatch[2]; // Modify the query to include the preload clauses\n    // TODO: instead of query manipulation, adjust the query generator\n    // TODO: support reverse predicates\n\n    const vars = predicates.map((p, i) => `?preload_${i}`);\n    const preloadClauses = predicates.map((predicate, i) => `    { ${resultVar} <${predicate}> ${vars[i]}. }`).join('\\n    UNION\\n');\n    const query = parentQuery.replace(VARIABLE, `$1$2 ${vars.join(' ')}`).replace(QUERY_TAIL, `  OPTIONAL {\\n${preloadClauses}\\n  }\\n$&`);\n    return {\n      query,\n      vars,\n      resultVar\n    };\n  }\n\n} // Returns a unique string representation of the term\n\nfunction hashTerm(term) {\n  const {\n    termType,\n    value\n  } = term;\n\n  switch (termType) {\n    case 'NamedNode':\n      return value;\n\n    case 'Literal':\n      const {\n        language,\n        datatype\n      } = term;\n      return `${termType}|${language}|${datatype.value}|${value}`;\n\n    default:\n      return `${termType}|${value}`;\n  }\n}","function _awaitAsyncGenerator(value) { return new _AwaitValue(value); }\n\nfunction _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }\n\nfunction _AsyncGenerator(gen) { var front, back; function send(key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; if (back) { back = back.next = request; } else { front = back = request; resume(key, arg); } }); } function resume(key, arg) { try { var result = gen[key](arg); var value = result.value; var wrappedAwait = value instanceof _AwaitValue; Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) { if (wrappedAwait) { resume(key === \"return\" ? \"return\" : \"next\", arg); return; } settle(result.done ? \"return\" : \"normal\", arg); }, function (err) { resume(\"throw\", err); }); } catch (err) { settle(\"throw\", err); } } function settle(type, value) { switch (type) { case \"return\": front.resolve({ value: value, done: true }); break; case \"throw\": front.reject(value); break; default: front.resolve({ value: value, done: false }); break; } front = front.next; if (front) { resume(front.key, front.arg); } else { back = null; } } this._invoke = send; if (typeof gen.return !== \"function\") { this.return = undefined; } }\n\nif (typeof Symbol === \"function\" && Symbol.asyncIterator) { _AsyncGenerator.prototype[Symbol.asyncIterator] = function () { return this; }; }\n\n_AsyncGenerator.prototype.next = function (arg) { return this._invoke(\"next\", arg); };\n\n_AsyncGenerator.prototype.throw = function (arg) { return this._invoke(\"throw\", arg); };\n\n_AsyncGenerator.prototype.return = function (arg) { return this._invoke(\"return\", arg); };\n\nfunction _AwaitValue(value) { this.wrapped = value; }\n\nfunction _asyncIterator(iterable) { var method; if (typeof Symbol !== \"undefined\") { if (Symbol.asyncIterator) { method = iterable[Symbol.asyncIterator]; if (method != null) return method.call(iterable); } if (Symbol.iterator) { method = iterable[Symbol.iterator]; if (method != null) return method.call(iterable); } } throw new TypeError(\"Object is not async iterable\"); }\n\n/**\n * Queries for all compacted predicates of a path subject\n */\nimport { JsonLdContextNormalized } from 'jsonld-context-parser';\nimport { toIterablePromise } from './promiseUtils';\nexport default class PropertiesHandler {\n  handle(pathData, path) {\n    return toIterablePromise(this._handle(pathData, path));\n  }\n\n  _handle(pathData, path) {\n    return _wrapAsyncGenerator(function* () {\n      const contextRaw = (yield _awaitAsyncGenerator(pathData.settings.parsedContext)) || {};\n      const context = new JsonLdContextNormalized(contextRaw);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(path.predicates), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const predicate = _value;\n          yield context.compactIri(`${yield _awaitAsyncGenerator(predicate)}`, true);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _awaitAsyncGenerator(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    })();\n  }\n\n}","/**\n * Returns a function that creates a new path with the same values,\n * but sorted on the given property.\n * The function accepts multiple properties to sort on a deeper path.\n *\n * Requires:\n *  - a predicate on the path proxy\n *  - a sort function on the path proxy (for multi-property sorting)\n */\nexport default class SortHandler {\n  constructor(order = 'ASC') {\n    this.order = order;\n  }\n\n  handle(pathData, pathProxy) {\n    return (...properties) => {\n      // Do nothing if no sort properties were given\n      if (properties.length === 0) return pathProxy; // Split off the first sort property and obtain its predicate\n\n      const [property, ...rest] = properties;\n      const {\n        predicate\n      } = pathProxy[property]; // Sort on the first property, and create paths for the next one\n\n      const childData = {\n        property,\n        predicate,\n        sort: this.order\n      };\n      const childPath = pathData.extendPath(childData);\n      return rest.length === 0 ? childPath : childPath.sort(...rest);\n    };\n  }\n\n}","import { namedNode } from '@rdfjs/data-model';\nconst NEEDS_ESCAPE = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019\\ud800-\\udbff]/,\n      ESCAPE_ALL = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019]|[\\ud800-\\udbff][\\udc00-\\udfff]/g,\n      ESCAPED_CHARS = {\n  '\\\\': '\\\\\\\\',\n  '\"': '\\\\\"',\n  '\\t': '\\\\t',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\b': '\\\\b',\n  '\\f': '\\\\f'\n};\n/**\n * Expresses a path or mutation as a SPARQL query.\n *\n * Requires:\n * - a mutationExpressions or pathExpression property on the path proxy\n */\n\nexport default class SparqlHandler {\n  async handle(pathData, path) {\n    // First check if we have a mutation expression\n    const mutationExpressions = await path.mutationExpressions;\n    if (Array.isArray(mutationExpressions) && mutationExpressions.length) // Remove empty results to prevent dangling semicolons\n      return mutationExpressions.map(e => this.mutationExpressionToQuery(e)).filter(Boolean).join('\\n;\\n'); // Otherwise, fall back to checking for a path expression\n\n    const pathExpression = await path.pathExpression;\n    if (!Array.isArray(pathExpression)) throw new Error(`${pathData} has no pathExpression property`);\n    return this.pathExpressionToQuery(pathData, path, pathExpression);\n  }\n\n  pathExpressionToQuery(pathData, path, pathExpression) {\n    if (pathExpression.length < 2 && !pathData.finalClause) throw new Error(`${pathData} should at least contain a subject and a predicate`); // Create triple patterns\n\n    let queryVar = '?subject',\n        sorts = [],\n        clauses = [];\n\n    if (pathExpression.length > 1) {\n      queryVar = this.createVar(pathData.property);\n      ({\n        queryVar,\n        sorts,\n        clauses\n      } = this.expressionToTriplePatterns(pathExpression, queryVar));\n    }\n\n    if (pathData.finalClause) clauses.push(pathData.finalClause(queryVar)); // Create SPARQL query body\n\n    const distinct = pathData.distinct ? 'DISTINCT ' : '';\n    const select = `SELECT ${distinct}${pathData.select ? pathData.select : queryVar}`;\n    const where = ` WHERE {\\n  ${clauses.join('\\n  ')}\\n}`;\n    const orderClauses = sorts.map(({\n      order,\n      variable\n    }) => `${order}(${variable})`);\n    const orderBy = orderClauses.length === 0 ? '' : `\\nORDER BY ${orderClauses.join(' ')}`;\n    return `${select}${where}${orderBy}`;\n  }\n\n  mutationExpressionToQuery({\n    mutationType,\n    conditions,\n    predicateObjects\n  }) {\n    // If there are no mutations, there is no query\n    if (!mutationType || !conditions || predicateObjects && predicateObjects.length === 0) return ''; // Create the WHERE clauses\n\n    const scope = {};\n    let subject, where; // If the only condition is a subject, we need no WHERE clause\n\n    if (conditions.length === 1) {\n      subject = this.termToString(conditions[0].subject);\n      where = [];\n    } // Otherwise, create a WHERE clause from all conditions\n    else {\n        const lastPredicate = conditions[conditions.length - 1].predicate;\n        subject = this.createVar(lastPredicate.value, scope);\n        ({\n          queryVar: subject,\n          clauses: where\n        } = this.expressionToTriplePatterns(conditions, subject, scope));\n      } // Create the mutation clauses\n\n\n    const mutations = [];\n\n    for (const {\n      predicate,\n      reverse,\n      objects\n    } of predicateObjects) {\n      // Mutate either only the specified objects, or all of them\n      const objectStrings = objects ? objects.map(o => this.termToString(o)) : [this.createVar(predicate.value, scope)]; // Generate a triple pattern for all subjects\n\n      mutations.push(...this.triplePatterns(subject, predicate, objectStrings, reverse));\n    }\n\n    const mutationClauses = `{\\n  ${mutations.join('\\n  ')}\\n}`; // Join clauses into a SPARQL query\n\n    return where.length === 0 ? // If there are no WHERE clauses, just mutate raw data\n    `${mutationType} DATA ${mutationClauses}` : // Otherwise, return a DELETE/INSERT ... WHERE ... query\n    `${mutationType} ${mutationClauses} WHERE {\\n  ${where.join('\\n  ')}\\n}`;\n  }\n\n  expressionToTriplePatterns([root, ...pathExpression], lastVar, scope = {}) {\n    const lastIndex = pathExpression.length - 1;\n    const clauses = [];\n    const sorts = [];\n    let object = this.termToString(skolemize(root.subject));\n    let queryVar = object;\n    let allowValues = false;\n    pathExpression.forEach((segment, index) => {\n      // Obtain components and generate triple pattern\n      const subject = object;\n      const {\n        predicate,\n        reverse,\n        sort,\n        values\n      } = segment; // Use fixed object values values if they were specified\n\n      let objects;\n\n      if (values && values.length > 0) {\n        if (!allowValues) throw new Error('Specifying fixed values is not allowed here');\n        objects = values.map(this.termToString);\n        allowValues = false; // disallow subsequent fixed values for this predicate\n      } // Otherwise, use a variable subject\n      else {\n          object = index < lastIndex ? this.createVar(`v${index}`, scope) : lastVar;\n          objects = [object];\n          allowValues = true;\n        }\n\n      clauses.push(...this.triplePatterns(subject, predicate, objects, reverse)); // If the sort option was not set, use this object as a query variable\n\n      if (!sort) {\n        queryVar = object;\n      } // If sort was set, use this object as a sorting variable\n      else {\n          // TODO: handle when an object is used for sorting, and later also for querying\n          sorts.push({\n            variable: object,\n            order: sort\n          }); // TODO: use a descriptive lastVar in case of sorting\n\n          object = queryVar;\n        }\n    });\n    return {\n      queryVar,\n      sorts,\n      clauses\n    };\n  } // Creates a unique query variable within the given scope, based on the suggestion\n\n\n  createVar(suggestion = '', scope) {\n    let counter = 0;\n    let label = `?${suggestion.match(/[a-z0-9]*$/i)[0] || 'result'}`;\n\n    if (scope) {\n      suggestion = label;\n\n      while (scope[label]) label = `${suggestion}_${counter++}`;\n\n      scope[label] = true;\n    }\n\n    return label;\n  } // Converts an RDFJS term to a string that we can use in a query\n\n\n  termToString(term) {\n    // Determine escaped value\n    let {\n      value\n    } = term;\n    if (NEEDS_ESCAPE.test(value)) value = value.replace(ESCAPE_ALL, escapeCharacter);\n\n    switch (term.termType) {\n      case 'NamedNode':\n        return `<${value}>`;\n\n      case 'BlankNode':\n        return `_:${value}`;\n\n      case 'Literal':\n        // Determine optional language or datatype\n        let suffix = '';\n        if (term.language) suffix = `@${term.language}`;else if (term.datatype.value !== 'http://www.w3.org/2001/XMLSchema#string') suffix = `^^<${term.datatype.value}>`;\n        return `\"${value}\"${suffix}`;\n\n      default:\n        throw new Error(`Could not convert a term of type ${term.termType}`);\n    }\n  } // Creates triple patterns for the given subject, predicate, and objects\n\n\n  triplePatterns(subjectString, predicateTerm, objectStrings, reverse = false) {\n    let subjectStrings = [subjectString];\n    if (reverse) [subjectStrings, objectStrings] = [objectStrings, subjectStrings];\n    const objects = objectStrings.join(', ');\n    return subjectStrings.map(s => `${s} <${predicateTerm.value}> ${objects}.`);\n  }\n\n} // Replaces a character by its escaped version\n// (borrowed from https://www.npmjs.com/package/n3)\n\nfunction escapeCharacter(character) {\n  // Replace a single character by its escaped version\n  let result = ESCAPED_CHARS[character];\n\n  if (result === undefined) {\n    // Replace a single character with its 4-bit unicode escape sequence\n    if (character.length === 1) {\n      result = character.charCodeAt(0).toString(16);\n      result = '\\\\u0000'.substr(0, 6 - result.length) + result;\n    } // Replace a surrogate pair with its 8-bit unicode escape sequence\n    else {\n        result = ((character.charCodeAt(0) - 0xD800) * 0x400 + character.charCodeAt(1) + 0x2400).toString(16);\n        result = '\\\\U00000000'.substr(0, 10 - result.length) + result;\n      }\n  }\n\n  return result;\n} // Skolemizes the given term if it is a blank node\n\n\nlet skolemId = 0;\n\nfunction skolemize(term) {\n  if (term.termType !== 'BlankNode') return term;\n  if (!term.skolemized) term.skolemized = namedNode(`urn:ldflex:sk${skolemId++}`);\n  return term.skolemized;\n}","import AsyncIteratorHandler from './AsyncIteratorHandler';\nimport DataHandler from './DataHandler';\nimport DeleteFunctionHandler from './DeleteFunctionHandler';\nimport ExecuteQueryHandler from './ExecuteQueryHandler';\nimport GetHandler from './GetFunctionHandler';\nimport InsertFunctionHandler from './InsertFunctionHandler';\nimport MutationExpressionsHandler from './MutationExpressionsHandler';\nimport PathExpressionHandler from './PathExpressionHandler';\nimport PredicateHandler from './PredicateHandler';\nimport PredicatesHandler from './PredicatesHandler';\nimport PreloadHandler from './PreloadHandler';\nimport PropertiesHandler from './PropertiesHandler';\nimport ReplaceFunctionHandler from './ReplaceFunctionHandler';\nimport SetFunctionHandler from './SetFunctionHandler';\nimport SortHandler from './SortHandler';\nimport SparqlHandler from './SparqlHandler';\nimport StringToLDflexHandler from './StringToLDflexHandler';\nimport SubjectHandler from './SubjectHandler';\nimport SubjectsHandler from './SubjectsHandler';\nimport ThenHandler from './ThenHandler';\nimport ToArrayHandler from './ToArrayHandler';\n/**\n * A map with default property handlers.\n */\n\nexport default {\n  // Flag to loaders that exported paths are not ES6 modules\n  __esModule: () => undefined,\n  // Add thenable and async iterable behavior\n  then: new ThenHandler(),\n  [Symbol.asyncIterator]: new AsyncIteratorHandler(),\n  // Add read and query functionality\n  get: new GetHandler(),\n  subject: new SubjectHandler(),\n  predicate: new PredicateHandler(),\n  properties: new PropertiesHandler(),\n  predicates: new PredicatesHandler(),\n  pathExpression: new PathExpressionHandler(),\n  sparql: new SparqlHandler(),\n  subjects: new SubjectsHandler(),\n  results: new ExecuteQueryHandler(),\n  sort: new SortHandler('ASC'),\n  sortDesc: new SortHandler('DESC'),\n  preload: new PreloadHandler(),\n  // Add write functionality\n  mutationExpressions: new MutationExpressionsHandler(),\n  add: new InsertFunctionHandler(),\n  set: new SetFunctionHandler(),\n  replace: new ReplaceFunctionHandler(),\n  delete: new DeleteFunctionHandler(),\n  // Add RDFJS term handling\n  termType: termPropertyHandler('termType'),\n  value: termPropertyHandler('value'),\n  datatype: termPropertyHandler('datatype'),\n  language: termPropertyHandler('language'),\n  canonical: termPropertyHandler('canonical'),\n  equals: DataHandler.sync('subject', 'equals'),\n  toString: DataHandler.syncFunction('subject', 'value'),\n  toPrimitive: DataHandler.syncFunction('subject', 'value'),\n  // Add iteration helpers\n  toArray: new ToArrayHandler(),\n  termTypes: handler((_, path) => path.toArray(t => t.termType)),\n  values: handler((_, path) => path.toArray(t => t.value)),\n  datatypes: handler((_, path) => path.toArray(t => t.datatype)),\n  languages: handler((_, path) => path.toArray(t => t.language)),\n  // Parse a string into an LDflex object\n  resolve: new StringToLDflexHandler()\n}; // Creates a handler from the given function\n\nfunction handler(handle) {\n  return {\n    handle\n  };\n} // Creates a handler for the given RDF/JS Term property\n\n\nfunction termPropertyHandler(property) {\n  return handler((pathData, path) => {\n    // If a resolved subject is present,\n    // synchronously expose the RDF/JS property\n    const {\n      subject\n    } = pathData;\n    const subjectValue = subject && subject[property];\n    if (typeof subjectValue !== 'undefined') return subjectValue; // Otherwise, return a promise to the property value\n\n    return path.then(term => term && term[property]);\n  });\n}","import { getThen } from './promiseUtils';\nimport { getFirstItem } from './iterableUtils';\n/**\n * Thenable handler that resolves to either the subject\n * of the first item of the results.\n *\n * Requires:\n *  - (optional) a subject on the path data\n *  - (optional) a subject on the path proxy\n *  - (optional) results on the path proxy\n */\n\nexport default class ThenHandler {\n  handle({\n    subject\n  }, pathProxy) {\n    // Resolve to either the subject (zero-length path) or the first result\n    return subject ? // If the subject is not a promise, it has already been resolved;\n    // consumers should not resolve it, but access its properties directly.\n    // This avoids infinite `then` chains when `await`ing this path.\n    subject.then && getThen(() => pathProxy.subject) : // Otherwise, return the first result of this path\n    getThen(() => getFirstItem(pathProxy.results));\n  }\n\n}","import { iteratorFor } from './iterableUtils';\n/**\n * AsyncIterator handler that yields either the subject or all results.\n *\n * Requires:\n *  - (optional) a subject on the path data\n *  - (optional) a subject on the path proxy\n *  - (optional) results on the path proxy\n */\n\nexport default class AsyncIteratorHandler {\n  handle({\n    subject\n  }, pathProxy) {\n    // Return a one-item iterator of the subject if present;\n    // otherwise, return all results of this path\n    return subject ? () => iteratorFor(pathProxy.subject) : () => pathProxy.results[Symbol.asyncIterator]();\n  }\n\n}","import { isPlainObject, isAsyncIterable } from './valueUtils';\nimport { iterableToArray } from './iterableUtils';\n/**\n * Returns a function that requests the values of multiple properties.\n * You can use this function to access properties as follows:\n * - fn() returns []\n * - fn(p1) returns [path[p1]]\n * - fn(p1, p2) returns [path[p1], path[p2]]\n * - fn([p1, p2]) returns [path[p1], path[p2]]\n * - fn(asyncIterable) returns [path[p1], path[p2]]\n * - fn({ p1: null, p2: null }) returns { p1: path[p1], p2: path[p2] }\n * Combinations of the above are possible by passing them in arrays.\n */\n\nexport default class GetFunctionHandler {\n  handle(pathData, path) {\n    return (...args) => this.readProperties(path, args.length === 1 ? args[0] : args, true);\n  }\n\n  async readProperties(path, properties, wrapSingleValues = false) {\n    // Convert an async iterable to an array\n    if (isAsyncIterable(properties)) properties = await iterableToArray(properties); // If passed an array, read every property\n\n    if (Array.isArray(properties)) {\n      const values = properties.map(p => this.readProperties(path, p));\n      return Promise.all(values);\n    } // If passed an object with property names as keys,\n    // return an object with the values filled in\n\n\n    if (isPlainObject(properties)) {\n      // Use the key as property value if none is specified\n      const keys = Object.keys(properties);\n      properties = keys.map(key => properties[key] || key); // Store the resolved properties by key\n\n      const results = {};\n      const values = await this.readProperties(path, properties);\n\n      for (let i = 0; i < keys.length; i++) results[keys[i]] = values[i];\n\n      return results;\n    } // Otherwise, perform a single property access\n\n\n    const value = path[properties];\n    return wrapSingleValues ? [value] : value;\n  }\n\n}","/**\n * Returns a new path starting from the subject of the current path.\n *\n * Requires:\n * - (optional) a subject property on the path data\n * - (optional) a parent property on the path data\n */\nexport default class SubjectHandler {\n  handle(pathData) {\n    // Traverse parents until we find a subject\n    let {\n      subject,\n      parent\n    } = pathData;\n\n    while (!subject && parent) ({\n      subject,\n      parent\n    } = parent); // Resolve the subject if it exists,\n    // and return a path starting from that subject\n\n\n    return !subject ? undefined : Promise.resolve(subject).then(value => pathData.extendPath({\n      subject: value\n    }, null));\n  }\n\n}","/**\n * Returns a new path starting from the predicate of the current path.\n *\n * Requires:\n * - (optional) a predicate property on the path data\n */\nexport default class PredicateHandler {\n  handle(pathData) {\n    const {\n      predicate\n    } = pathData;\n    return !predicate ? undefined : Promise.resolve(predicate).then(subject => pathData.extendPath({\n      subject\n    }, null));\n  }\n\n}","/**\n * Queries for all predicates of a path subject\n */\nexport default class PredicatesHandler {\n  handle(pathData) {\n    return pathData.extendPath({\n      distinct: true,\n      select: '?predicate',\n      finalClause: queryVar => `${queryVar} ?predicate ?object.`,\n      property: pathData.property\n    });\n  }\n\n}","/**\n * Traverses a path to collect links and nodes into an expression.\n */\nexport default class PathExpressionHandler {\n  async handle(pathData) {\n    const segments = [];\n    let current = pathData; // Add all predicates to the path\n\n    while (current.parent) {\n      // Obtain and store predicate\n      if (current.predicate) {\n        segments.unshift({\n          predicate: await current.predicate,\n          reverse: await current.reverse,\n          sort: current.sort,\n          values: current.values\n        });\n      } // Move to parent link\n\n\n      current = current.parent;\n    } // Add the root subject to the path\n\n\n    if (!current.subject) throw new Error(`Expected root subject in ${current}`);\n    const subject = await current.subject;\n    segments.unshift({\n      subject\n    });\n    return segments;\n  }\n\n}","/**\n * Queries for all subjects of a document\n */\nexport default class SubjectsHandler {\n  handle(pathData) {\n    return pathData.extendPath({\n      distinct: true,\n      select: '?subject',\n      finalClause: () => '?subject ?predicate ?object.',\n      property: pathData.property\n    });\n  }\n\n}","/**\n * Traverses a path to collect mutationExpressions into an expression.\n * This is needed because mutations can be chained.\n *\n * Requires:\n * - a mutationExpressions property on the path proxy\n */\nexport default class MutationExpressionsHandler {\n  async handle(pathData) {\n    const mutationExpressions = []; // Add all mutationExpressions to the path\n\n    let current = pathData;\n\n    while (current) {\n      // Obtain and store mutationExpressions\n      if (current.mutationExpressions) mutationExpressions.unshift(...(await current.mutationExpressions)); // Move to parent link\n\n      current = current.parent;\n    }\n\n    return mutationExpressions;\n  }\n\n}","import MutationFunctionHandler from './MutationFunctionHandler';\n/**\n * A MutationFunctionHandler for insertions.\n */\n\nexport default class InsertFunctionHandler extends MutationFunctionHandler {\n  constructor() {\n    super('INSERT', false);\n  }\n\n}","import MutationFunctionHandler from './MutationFunctionHandler';\nimport { hasPlainObjectArgs } from './valueUtils';\n/**\n * Returns a function that deletes all existing values\n * for the path, and then adds the given values to the path.\n *\n * Requires:\n * - a delete function on the path proxy.\n * - an add function on the path proxy.\n */\n\nexport default class SetFunctionHandler extends MutationFunctionHandler {\n  handle(pathData, path) {\n    return (...args) => {\n      // First, delete all existing values for the property/properties\n      const deletePath = !hasPlainObjectArgs(args) ? // When a single property is given, delete all of its values\n      path.delete() : // When a map of properties is given, delete all of their values\n      Object.keys(args[0]).reduce((previousPath, property) => previousPath.delete({\n        [property]: []\n      }), path); // Next, insert the new values\n\n      return deletePath.add(...args);\n    };\n  }\n\n}","/**\n * Returns a function that deletes the given value\n * for the path, and then adds the given values to the path.\n *\n * Requires:\n * - a delete function on the path proxy.\n * - an add function on the path proxy.\n */\nexport default class ReplaceFunctionHandler {\n  handle(pathData, path) {\n    return function (oldValue, ...newValues) {\n      if (!oldValue || !newValues.length) throw new Error('Replacing values requires at least two arguments, old value followed by all new values');\n      return path.delete(oldValue).add(...newValues);\n    };\n  }\n\n}","function _asyncIterator(iterable) { var method; if (typeof Symbol !== \"undefined\") { if (Symbol.asyncIterator) { method = iterable[Symbol.asyncIterator]; if (method != null) return method.call(iterable); } if (Symbol.iterator) { method = iterable[Symbol.iterator]; if (method != null) return method.call(iterable); } } throw new TypeError(\"Object is not async iterable\"); }\n\nimport { isAsyncIterable } from './valueUtils';\n/**\n * Converts an asynchronously iterable path into an array.\n *\n * Requires:\n * - (optional) an iterable path\n */\n\nexport default class ToArrayHandler {\n  handle(pathData, path) {\n    return async map => {\n      const items = [];\n\n      if (isAsyncIterable(path)) {\n        // Ensure the mapping function is valid\n        if (typeof map !== 'function') map = item => item; // Retrieve and map all elements\n\n        let index = 0;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n\n        var _iteratorError;\n\n        try {\n          for (var _iterator = _asyncIterator(path), _step, _value; _step = await _iterator.next(), _iteratorNormalCompletion = _step.done, _value = await _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n            const item = _value;\n            items.push(await map(item, index++));\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              await _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      return items;\n    };\n  }\n\n}","/**\n * Yields a function that interprets a string expression as an LDflex path.\n */\nexport default class StringToLDflexHandler {\n  handle(pathData, path) {\n    // Resolves the given string expression against the LDflex object\n    return (expression = '', ldflex = path) => {\n      // An expression starts with a property access in dot or bracket notation\n      const propertyPath = expression // Add brackets around a single URL\n      .replace(/^(https?:\\/\\/[^()[\\]'\"]+)$/, '[\"$1\"]') // Add the starting dot if omitted\n      .replace(/^(?=[a-z$_])/i, '.') // Add quotes inside of brackets if omitted\n      .replace(/\\[([^'\"`\\](]*)\\]/g, '[\"$1\"]'); // Create a function to evaluate the expression\n\n      const body = `\"use strict\";return ldflex${propertyPath}`;\n      let evaluator;\n\n      try {\n        /* eslint no-new-func: off */\n        evaluator = Function('ldflex', body);\n      } catch ({\n        message\n      }) {\n        throw new Error(`Expression \"${expression}\" is invalid: ${message}`);\n      } // Evaluate the function\n\n\n      return evaluator(ldflex);\n    };\n  }\n\n}","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nconst EMPTY = Object.create(null);\n/**\n * A PathProxy creates path expressions,\n * to which functionality can be attached.\n *\n * To users, these paths act as regular JavaScript objects\n * (such as `path.foo.bar.prop`) thanks to Proxy.\n * Behind the scenes, they carry around internal data\n * that can be used to influence their functionality.\n *\n * A path's functionality is realized by:\n * - handlers, which handle a specific named property\n * - resolvers, which can handle arbitrary properties\n * Only handlers and resolvers see the internal data.\n *\n * A path can have arbitrary internal data fields, but these are reserved:\n * - settings, an object that is passed on as-is to child paths\n * - proxy, a reference to the proxied object the user sees\n * - parent, a reference to the parent path\n * - apply, a function the will be invoked when the path is called as a function\n * - extendPath, a method to create a child path with this path as parent\n */\n\nexport default class PathProxy {\n  constructor({\n    handlers = EMPTY,\n    resolvers = []\n  } = {}) {\n    this._handlers = handlers;\n    this._resolvers = resolvers;\n  }\n  /**\n   * Creates a path Proxy with the given settings and internal data fields.\n   */\n\n\n  createPath(settings = {}, data) {\n    // The settings parameter is optional\n    if (data === undefined) [data, settings] = [settings, {}]; // Create the path's internal data object and the proxy that wraps it\n\n    const {\n      apply\n    } = data,\n          rawData = _objectWithoutProperties(data, [\"apply\"]);\n\n    const path = apply ? Object.assign(callPathFunction, rawData) : rawData;\n    const proxy = new Proxy(path, this);\n    path.proxy = proxy;\n    path.settings = settings;\n\n    function callPathFunction(...args) {\n      return apply(args, path, proxy);\n    } // Add an extendPath method to create child paths\n\n\n    if (!path.extendPath) {\n      const pathProxy = this;\n\n      path.extendPath = function extendPath(newData, parent = this) {\n        return pathProxy.createPath(settings, _objectSpread({\n          parent,\n          extendPath\n        }, newData));\n      };\n    } // Return the proxied path\n\n\n    return proxy;\n  }\n  /**\n   * Handles access to a property\n   */\n\n\n  get(pathData, property) {\n    // Handlers provide functionality for a specific property,\n    // so check if we find a handler first\n    const handler = this._handlers[property];\n    if (handler && typeof handler.handle === 'function') return handler.handle(pathData, pathData.proxy); // Resolvers provide functionality for arbitrary properties,\n    // so find a resolver that can handle this property\n\n    for (const resolver of this._resolvers) {\n      if (resolver.supports(property)) return resolver.resolve(property, pathData, pathData.proxy);\n    } // Otherwise, the property does not exist\n\n\n    return undefined;\n  }\n\n}","import { ContextParser, Util as ContextUtil } from 'jsonld-context-parser';\nimport { namedNode } from '@rdfjs/data-model';\nimport { lazyThenable } from './promiseUtils';\nimport { valueToTerm } from './valueUtils';\n/**\n * Resolves property names of a path\n * to their corresponding IRIs through a JSON-LD context.\n */\n\nexport default class JSONLDResolver {\n  /**\n   * Creates a new resolver for the given context(s).\n   */\n  constructor(...contexts) {\n    this._context = Promise.resolve({});\n    this.extendContext(...contexts);\n  }\n  /**\n   * The JSON-LD resolver supports all string properties.\n   */\n\n\n  supports(property) {\n    return typeof property === 'string';\n  }\n  /**\n   * When resolving a JSON-LD property,\n   * we create a new chainable path segment corresponding to the predicate.\n   *\n   * Example usage: person.friends.firstName\n   */\n\n\n  resolve(property, pathData) {\n    const predicate = lazyThenable(() => this.expandProperty(property));\n    const reverse = lazyThenable(() => this._context.then(({\n      contextRaw\n    }) => contextRaw[property] && contextRaw[property]['@reverse']));\n    const resultsCache = this.getResultsCache(pathData, predicate, reverse);\n    const newData = {\n      property,\n      predicate,\n      resultsCache,\n      reverse,\n      apply: this.apply\n    };\n    return pathData.extendPath(newData);\n  }\n  /**\n   * When the property is called as a function,\n   * it adds property-object constraints to the path.\n   *\n   * Example usage: person.friends.location(place).firstName\n   */\n\n\n  apply(args, pathData, path) {\n    if (args.length === 0) throw new Error('Specify at least one value for the property'); // With the property constraint added, continue from the previous path\n\n    pathData.values = args.map(valueToTerm);\n    return path;\n  }\n  /**\n   * Expands a JSON property key into a full IRI.\n   */\n\n\n  async expandProperty(property) {\n    // JavaScript requires keys containing colons to be quoted,\n    // so prefixed names would need to written as path['foaf:knows'].\n    // We thus allow writing path.foaf_knows or path.foaf$knows instead.\n    property = property.replace(/^([a-z][a-z0-9]*)[_$]/i, '$1:'); // Expand the property to a full IRI\n\n    const context = await this._context;\n    const expandedProperty = context.expandTerm(property, true);\n    if (!ContextUtil.isValidIri(expandedProperty)) throw new Error(`The JSON-LD context cannot expand the '${property}' property`);\n    return namedNode(expandedProperty);\n  }\n  /**\n   * Extends the current JSON-LD context with the given context(s).\n   */\n\n\n  async extendContext(...contexts) {\n    await (this._context = this._context.then(({\n      contextRaw\n    }) => new ContextParser().parse([contextRaw, ...contexts])));\n  }\n  /**\n   * Gets the results cache for the given predicate.\n   */\n\n\n  getResultsCache(pathData, predicate, reverse) {\n    let {\n      propertyCache\n    } = pathData;\n    return propertyCache && lazyThenable(async () => {\n      // Preloading does not work with reversed predicates\n      propertyCache = !(await reverse) && (await propertyCache);\n      return propertyCache && propertyCache[(await predicate).value];\n    });\n  }\n\n}","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport PathProxy from './PathProxy';\nimport JSONLDResolver from './JSONLDResolver';\nimport defaultHandlers from './defaultHandlers';\nimport { ContextParser } from 'jsonld-context-parser';\n/**\n * A PathFactory creates paths with default settings.\n */\n\nexport default class PathFactory {\n  constructor(settings, data) {\n    // Store settings and data\n    this._settings = settings = _objectSpread({}, settings);\n    this._data = data = _objectSpread({}, data); // Prepare the handlers\n\n    const handlers = settings.handlers || defaultHandlers;\n\n    for (const key in handlers) handlers[key] = toHandler(handlers[key]);\n\n    for (const key of Object.getOwnPropertySymbols(handlers)) handlers[key] = toHandler(handlers[key]); // Prepare the resolvers\n\n\n    const resolvers = (settings.resolvers || []).map(toResolver);\n\n    if (settings.context) {\n      resolvers.push(new JSONLDResolver(settings.context));\n      settings.parsedContext = new ContextParser().parse(settings.context).then(({\n        contextRaw\n      }) => contextRaw);\n    } else {\n      settings.context = settings.parsedContext = {};\n    } // Instantiate PathProxy that will create the paths\n\n\n    this._pathProxy = new PathProxy({\n      handlers,\n      resolvers\n    }); // Remove PathProxy settings from the settings object\n\n    delete settings.handlers;\n    delete settings.resolvers;\n  }\n  /**\n   * Creates a path with the given (optional) settings and data.\n   */\n\n\n  create(settings = {}, data) {\n    // The settings parameter is optional\n    if (!data) [data, settings] = [settings, null]; // Apply defaults on settings and data\n\n    return this._pathProxy.createPath(Object.assign(Object.create(null), this._settings, settings), Object.assign(Object.create(null), this._data, data));\n  }\n\n}\nPathFactory.defaultHandlers = defaultHandlers;\n/**\n * Converts a handler function into a handler object.\n */\n\nexport function toHandler(handle) {\n  return typeof handle.handle === 'function' ? handle : {\n    handle\n  };\n}\n/**\n * Converts a resolver function into a catch-all resolver object.\n */\n\nexport function toResolver(resolve) {\n  return typeof resolve.resolve === 'function' ? resolve : {\n    supports,\n    resolve\n  };\n} // Catch-all resolvers support everything\n\nfunction supports() {\n  return true;\n}","import { toIterablePromise } from 'ldflex';\nimport { namedNode } from '@rdfjs/data-model';\nimport context from '@solid/context';\n\nconst { as } = context['@context'];\n\n/**\n * Base class for handlers that manipulate activities\n * Requires:\n * - the `root.user` handler\n * - the `root[...]` resolver\n * - a queryEngine property in the path settings\n */\nexport default class ActivityHandler {\n  requireUser = true;\n\n  constructor({ activitiesPath = '/public/activities' } = {}) {\n    this.activitiesPath = activitiesPath;\n  }\n\n  handle(pathData, path) {\n    const self = this;\n    const { root } = path;\n    const { settings: { queryEngine } } = pathData;\n\n    // Return an iterator over the activity paths\n    return (type = `${as}Like`) => toIterablePromise(async function* () {\n      // Only process activities if a user is logged in\n      let user;\n      try {\n        user = await root.user;\n      }\n      catch (error) {\n        if (self.requireUser)\n          throw error;\n        return;\n      }\n\n      // Determine the storage location\n      const storage = await root.user.pim$storage;\n      const document = new URL(self.activitiesPath, storage || user).href;\n\n      // Obtain results for every activity on the path\n      const results = [];\n      const actor = namedNode(user);\n      type = namedNode(type);\n      for await (const object of path) {\n        if (object.termType === 'NamedNode') {\n          const activity = { actor, type, object };\n          for await (const result of self.createResults(activity, document, queryEngine))\n            results.push(result);\n        }\n      }\n\n      // Process all results and return paths starting from the returned terms\n      for (const term of await self.processResults(results, document, queryEngine))\n        yield root[term.value];\n    });\n  }\n\n  async processResults(results) {\n    return results;\n  }\n}\n","import { SparqlHandler } from 'ldflex';\n\nexport const { termToString } = SparqlHandler.prototype;\n\nexport function replaceVariables(template, terms) {\n  for (const name in terms)\n    template = template.replace(new RegExp(`_:${name}`, 'g'), termToString(terms[name]));\n  return template;\n}\n\n// Transforms the arguments into an Immutable.js-style list\nexport function asList(...items) {\n  return {\n    size: items.length,\n    values: () => ({\n      next: () => ({ value: items.shift() }),\n    }),\n  };\n}\n","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n// find the complete implementation of crypto (msCrypto) on IE11.\nvar getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);\nvar rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\nexport default function rng() {\n  if (!getRandomValues) {\n    throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n  }\n\n  return getRandomValues(rnds8);\n}","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\n  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');\n}\n\nexport default bytesToUuid;","import rng from './rng.js';\nimport bytesToUuid from './bytesToUuid.js';\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof options == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nexport default v4;","import ActivityHandler from './ActivityHandler';\nimport activityTemplate from './activity.ttl';\nimport { replaceVariables } from '../util';\nimport { namedNode, literal } from '@rdfjs/data-model';\nimport { v4 as uuidv4 } from 'uuid';\nimport context from '@solid/context';\n\nconst { xsd } = context['@context'];\n\n/**\n * Handler that creates an activity in the user's data pod\n * Requires:\n * - the `root.user` handler\n * - the `root[...]` resolver\n * - a queryEngine property in the path settings\n */\nexport default class CreateActivityHandler extends ActivityHandler {\n  // Creates an activity for insertion in the given document\n  async* createResults(activity, document) {\n    const id = namedNode(new URL(`#${uuidv4()}`, document).href);\n    const published = literal(new Date().toISOString(), `${xsd}dateTime`);\n    activity = { id, published, ...activity };\n\n    const insert = replaceVariables(activityTemplate, activity);\n    yield { id, insert };\n  }\n\n  // Inserts the activities into the document\n  async processResults(results, document, queryEngine) {\n    const sparql = `INSERT {\\n${results.map(r => r.insert).join('')}}`;\n    await queryEngine.executeUpdate(sparql, document).next();\n    return results.map(r => r.id);\n  }\n}\n","import ActivityHandler from './ActivityHandler';\nimport queryTemplate from './activity-triples.sparql';\nimport { replaceVariables, termToString } from '../util';\n\nconst components = ['?subject', '?predicate', '?object'];\n\n/**\n * Handler that deletes an activity in the user's data pod\n * Requires:\n * - the `root.user` handler\n * - the `root[...]` resolver\n * - a queryEngine property in the path settings\n */\nexport default class DeleteActivityHandler extends ActivityHandler {\n  // Finds activity triples for deletion\n  async* createResults(activity, document, queryEngine) {\n    const query = replaceVariables(queryTemplate, activity);\n    for await (const triple of queryEngine.execute(query, document)) {\n      const terms = components.map(c => termToString(triple.get(c)));\n      yield `${terms.join(' ')}.\\n`;\n    }\n  }\n\n  // Deletes the activity triples from the document\n  async processResults(results, document, queryEngine) {\n    const sparql = `DELETE {\\n${results.join('')}}`;\n    await queryEngine.executeUpdate(sparql, document).next();\n    return [];\n  }\n}\n","import { namedNode } from '@rdfjs/data-model';\n\n/**\n * LDflex property resolver that returns a new path\n * starting from the property name as a subject.\n *\n * For example, when triggered as\n *     data['http://person.example/#me'].friends.firstName\n * it will create a path with `http://person.example/#me` as subject\n * and then resolve `friends` and `firstName` against the JSON-LD context.\n *\n * In case a source object is given as input, data will be pulled from there.\n */\nexport default class SubjectPathResolver {\n  constructor(pathFactory, source) {\n    this._paths = pathFactory;\n    this._source = source;\n  }\n\n  /** Resolve all string properties (not Symbols) */\n  supports(property) {\n    return typeof property === 'string';\n  }\n\n  resolve(property, { settings }) {\n    return this._createSubjectPath(namedNode(property), settings);\n  }\n\n  _createSubjectPath(subject, { createQueryEngine }) {\n    const source = this._source || Promise.resolve(subject).catch(() => null);\n    const queryEngine = createQueryEngine(source);\n    return this._paths.create({ queryEngine }, { subject });\n  }\n}\n","import { PathFactory, defaultHandlers } from 'ldflex';\nimport SubjectPathResolver from '../resolvers/SubjectPathResolver';\n\nexport default class SourcePathHandler {\n  constructor(pathFactory) {\n    this._paths = pathFactory;\n  }\n\n  handle({ settings }) {\n    return source => new PathFactory({\n      handlers: { ...defaultHandlers },\n      resolvers: [new SubjectPathResolver(this._paths, source)],\n    }).create(settings, {});\n  }\n}\n","import SubjectPathResolver from '../resolvers/SubjectPathResolver';\nimport auth from 'solid-auth-client';\nimport { namedNode } from '@rdfjs/data-model';\n\n/**\n * Creates a path with the current user as a subject.\n */\nexport default class UserPathHandler extends SubjectPathResolver {\n  handle({ settings }) {\n    const subject = this.getWebId().then(namedNode);\n    return this._createSubjectPath(subject, settings);\n  }\n\n  /** Gets the WebID of the logged in user */\n  async getWebId() {\n    const session = await auth.currentSession();\n    if (!session)\n      throw new Error('Cannot resolve user path: no user logged in');\n    return session.webId;\n  }\n}\n","import { PathFactory, defaultHandlers } from 'ldflex';\nimport context from '@solid/context';\nimport SolidDeleteFunctionHandler from './handlers/SolidDeleteFunctionHandler';\nimport FindActivityHandler from './handlers/FindActivityHandler';\nimport CreateActivityHandler from './handlers/CreateActivityHandler';\nimport DeleteActivityHandler from './handlers/DeleteActivityHandler';\nimport SourcePathHandler from './handlers/SourcePathHandler';\nimport UserPathHandler from './handlers/UserPathHandler';\nimport ContextResolver from './resolvers/ContextResolver';\nimport SubjectPathResolver from './resolvers/SubjectPathResolver';\n\nconst { as } = context['@context'];\nconst contextResolver = new ContextResolver(context);\n\n// Handlers for subject paths\nconst subjectHandlers = {\n  ...defaultHandlers,\n\n  // Custom delete handler to match node-solid-server behavior\n  delete: new SolidDeleteFunctionHandler(),\n\n  // Find activities\n  findActivity: new FindActivityHandler(),\n  likes: (_, path) => path.findActivity(`${as}Like`),\n  dislikes: (_, path) => path.findActivity(`${as}Dislike`),\n  follows: (_, path) => path.findActivity(`${as}Follow`),\n\n  // Create activities\n  createActivity: new CreateActivityHandler(),\n  like: (_, path) => () => path.createActivity(`${as}Like`),\n  dislike: (_, path) => () => path.createActivity(`${as}Dislike`),\n  follow: (_, path) => () => path.createActivity(`${as}Follow`),\n\n  // Delete activities\n  deleteActivity: new DeleteActivityHandler(),\n  unlike: (_, path) => () => path.deleteActivity(`${as}Like`),\n  undislike: (_, path) => () => path.deleteActivity(`${as}Dislike`),\n  unfollow: (_, path) => () => path.deleteActivity(`${as}Follow`),\n};\n\n// Creates an LDflex for Solid root path with the given settings\nexport default function createRootPath(defaultSettings) {\n  let rootPath = null;\n\n  // Factory for data paths that start from a given subject\n  const subjectPathFactory = new PathFactory({\n    handlers: { ...subjectHandlers, root: () => rootPath },\n    resolvers: [contextResolver],\n  });\n\n  // Root path that resolves the first property access\n  rootPath = new PathFactory({\n    // Handlers of specific named properties\n    handlers: {\n      ...defaultHandlers,\n\n      // The `from` function takes a source as input\n      from: new SourcePathHandler(subjectPathFactory),\n      // The `user` property starts a path with the current user as subject\n      user: new UserPathHandler(subjectPathFactory),\n\n      // Clears the cache for the given document (or everything, if undefined)\n      clearCache: ({ settings }) => doc =>\n        settings.createQueryEngine().clearCache(doc),\n\n      // Expose the JSON-LD context\n      context: contextResolver,\n    },\n    // Resolvers for all remaining properties\n    resolvers: [\n      // `data[url]` starts a path with the property as subject\n      new SubjectPathResolver(subjectPathFactory),\n    ],\n    ...defaultSettings,\n  }).create();\n  return rootPath;\n}\n","import { JSONLDResolver } from 'ldflex';\n\n/**\n * A ContextResolver is a combined resolver/handler that:\n * - resolves a JSON-LD context\n * - handles by returning an object that\n *   - is the initial context passed to the constructor\n *   - allows extending that context by calling `.extend`\n *   - when `await`ed, resolves to the expanded context\n */\nexport default class ContextResolver extends JSONLDResolver {\n  constructor(context) {\n    super(context);\n\n    // Create an exposed version of the initial context, with additional functionality\n    const exposedContext = this._exposedContext = Object.create(context['@context']);\n    // Allow extending the context\n    Object.defineProperty(exposedContext, 'extend', {\n      value: (...contexts) => this.extendContext(...contexts),\n    });\n    // Resolve to the expanded context\n    Object.defineProperty(exposedContext, 'then', {\n      value: (resolve, reject) => this._context\n        .then(ctx => ctx.contextRaw).then(resolve, reject),\n    });\n  }\n\n  handle() {\n    return this._exposedContext;\n  }\n}\n","import { DeleteFunctionHandler } from 'ldflex';\n\n/**\n * node-solid-server deviates from the SPARQL UPDATE spec:\n * whereas the spec asks for DELETE on non-existing triples to silently succeed,\n * node-solid-server will only DELETE if exactly one triple matches.\n *\n * This delete handler works around that limitation\n * by first requesting all existing values for a path,\n * and then only issuing DELETE statements for those that exist.\n */\nexport default class SolidDeleteFunctionHandler extends DeleteFunctionHandler {\n  async extractObjects(pathData, path, args) {\n    // Obtain all values whose deletion was requested\n    const objects = await super.extractObjects(pathData, path, args);\n\n    // Obtain all values that currently exist\n    const existing = [];\n    for await (const term of path) {\n      if (term.termType !== 'BlankNode')\n        existing.push(term);\n    }\n\n    // Perform deletions only for values that exist\n    return !objects ? existing : existing.filter(e => objects.some(o => o.equals(e)));\n  }\n}\n","import ActivityHandler from './ActivityHandler';\nimport queryTemplate from './activity.sparql';\nimport { replaceVariables } from '../util';\n\n/**\n * Handler that finds an activity in the user's data pod\n * Requires:\n * - the `root.user` handler\n * - the `root[...]` resolver\n * - a queryEngine property in the path settings\n */\nexport default class FindActivityHandler extends ActivityHandler {\n  requireUser = false;\n\n  // Finds all activities in the document matching the given pattern\n  async* createResults(activity, document, queryEngine) {\n    const query = replaceVariables(queryTemplate, activity);\n    for await (const binding of queryEngine.execute(query, document))\n      yield binding.values().next().value;\n  }\n}\n","import auth from 'solid-auth-client';\nimport { asList } from './util';\n\n/**\n * A wrapper around a query engine\n * that uses Solid authenticated requests for updates.\n */\nexport default class SolidUpdateEngine {\n  /**\n   * Creates a wrapper around the given query engine.\n   */\n  constructor(sources, baseEngine) {\n    // Preload source but silence errors; they will be thrown during execution\n    this._source = this.getUpdateSource(sources);\n    this._source.catch(() => null);\n    this._engine = baseEngine;\n  }\n\n  /**\n   * Creates an asynchronous iterable of results for the given SPARQL query.\n   */\n  async* execute(sparql, sources) {\n    yield* /^\\s*(?:INSERT|DELETE)/i.test(sparql) ?\n      this.executeUpdate(sparql, sources) :\n      this._engine.execute(sparql, sources);\n  }\n\n  /**\n   * Creates an asynchronous iterable with the results of the SPARQL UPDATE query.\n   */\n  executeUpdate(sparql, sources) {\n    let done = false;\n    const next = async () => {\n      if (done)\n        return { done };\n      done = true;\n\n      // Send authenticated PATCH request to the document\n      const source = await (sources ? this.getUpdateSource(sources) : this._source);\n      const { ok, status, statusText } = await auth.fetch(source, {\n        method: 'PATCH',\n        headers: {\n          'Content-Type': 'application/sparql-update',\n        },\n        body: sparql,\n      });\n      if (!ok)\n        throw new Error(`Update query failed (${status}): ${statusText}`);\n\n      // Clear stale cached versions of the document\n      await this.clearCache(source);\n\n      // Return success\n      return { value: asList({ ok }) };\n    };\n    return {\n      next,\n      return: noop, throw: noop, // required by the interface\n      [Symbol.asyncIterator]() { return this; },\n    };\n  }\n\n  /**\n   * Parses the source(s) into the source to update.\n   */\n  async getUpdateSource(sources) {\n    let source = await sources;\n\n    // Transform URLs or terms into strings\n    if (source instanceof URL)\n      source = source.href;\n    else if (source && typeof source.value === 'string')\n      source = source.value;\n\n    // Parse a string URL source\n    if (typeof source === 'string') {\n      if (!/^https?:\\/\\//.test(source))\n        throw new Error('Can only update an HTTP(S) document.');\n      return source.replace(/#.*/, '');\n    }\n\n    // Flatten recursive calls to this function\n    if (Array.isArray(source)) {\n      source = await Promise.all(source.map(s => this.getUpdateSource(s)));\n      source = [].concat(...source).filter(s => !!s);\n      if (source.length !== 1)\n        throw new Error('Can only update a single source.');\n      return source[0];\n    }\n\n    // Error on unsupported sources\n    throw new Error(`Unsupported source: ${source}`);\n  }\n\n  /**\n   * Removes the given document (or all, if not specified) from the cache,\n   * such that fresh results are obtained next time.\n   */\n  clearCache(document) {\n    return this._engine.clearCache(document);\n  }\n}\n\nfunction noop() { /* empty */ }\n","import RdflibQueryEngine from './RdflibQueryEngine';\nexport default RdflibQueryEngine;\n","import {\n  graph,\n  Fetcher,\n  SPARQLToQuery as sparqlToQuery,\n} from 'rdflib';\n\n/**\n * Asynchronous iterator wrapper for the rdflib.js SPARQL query engine.\n */\nexport default class RdflibQueryEngine {\n  /**\n   * Creates a query engine with the given sources as default.\n   */\n  constructor(defaultSources) {\n    // Preload sources but silence errors; they will be thrown during execution\n    this._defaultStore = this.readSources(defaultSources);\n    this._defaultStore.catch(() => null);\n  }\n\n  /**\n   * Creates an asynchronous iterable of results for the given SPARQL query.\n   */\n  async* execute(sparql, sources) {\n    if ((/^\\s*(?:INSERT|DELETE)/i).test(sparql))\n      yield* this.executeUpdate(sparql, sources);\n\n    // Parse the SPARQL query\n    const query = sparqlToQuery(sparql, true, graph());\n    // Load the sources if passed, the default sources otherwise\n    const store = await (sources ? this.readSources(sources) : this._defaultStore);\n    // Disable link traversal for now (slow, and unreliable error handling)\n    store.fetcher = null;\n\n    // Execute the query and store the results in an array\n    const results = [];\n    await new Promise((resolve, reject) => {\n      store.query(query, result => results.push(result), null,\n        error => error ? reject(error) : resolve(results));\n    });\n\n    // Convert every result to a map\n    const vars = new Set(query.vars.map(v => `?${v.value}`));\n    for (const result of results) {\n      // Only return explicitly requested variables\n      // (workaround for https://github.com/linkeddata/rdflib.js/issues/393)\n      const bindings = Object.entries(result).filter(([v]) => vars.has(v));\n      yield new Map(bindings);\n    }\n  }\n\n  /**\n   * Creates an asynchronous iterable with the results of the SPARQL UPDATE query.\n   */\n  async* executeUpdate(sparql, sources) {\n    throw new Error(`SPARQL UPDATE queries are unsupported, received: ${sparql}`);\n  }\n\n  /**\n   * Reads the specified stores into a store.\n   */\n  async readSources(sourceList, store = graph()) {\n    let source = await sourceList;\n    if (source) {\n      // Transform URLs or terms into strings\n      if (source instanceof URL)\n        source = source.href;\n      else if (source.termType === 'NamedNode')\n        source = source.value;\n\n      // Read a document from a URL\n      if (typeof source === 'string') {\n        const document = source.replace(/#.*/, '');\n        const fetcher = new Fetcher(store);\n        await fetcher.load(document);\n      }\n      // Read an array of sources\n      else if (Array.isArray(source)) {\n        await Promise.all(source.map(s => this.readSources(s, store)));\n      }\n      // Read an RDF/JS source\n      else if (typeof source.match === 'function') {\n        const results = source.match(null, null, null, null);\n        await new Promise((resolve, reject) => {\n          results.on('data', addQuad);\n          results.on('end', finish);\n          results.on('error', finish);\n          // Adds a quad to the store\n          function addQuad(quad) {\n            try {\n              store.add(quad.subject, quad.predicate, quad.object, quad.graph);\n            }\n            catch (error) {\n              finish(error);\n            }\n          }\n          // Finishes reading the source\n          function finish(error) {\n            results.removeListener('data', addQuad);\n            results.removeListener('end', finish);\n            results.removeListener('error', finish);\n            return error ? reject(error) : resolve(null);\n          }\n        });\n      }\n      // Error on unsupported sources\n      else {\n        throw new Error(`Unsupported source: ${source}`);\n      }\n    }\n    return store;\n  }\n\n  /**\n   * Removes the given document (or all, if not specified) from the cache,\n   * such that fresh results are obtained next time.\n   */\n  async clearCache(document) {\n    // No action required, since we need a new fetcher for every store\n  }\n}\n","import RootPath from '../RootPath';\nimport SolidUpdateEngine from '../SolidUpdateEngine';\nimport RdflibQueryEngine from '@ldflex/rdflib';\n\n// Export the root path with rdflib.js as query engine\nexport default new RootPath({\n  createQueryEngine: sources =>\n    new SolidUpdateEngine(sources, new RdflibQueryEngine(sources)),\n});\n"],"sourceRoot":""}