{"version":3,"sources":["webpack://solid.data/webpack/bootstrap","webpack://solid.data/./node_modules/@rdfjs/data-model/index.js","webpack://solid.data/./node_modules/ldflex/node_modules/jsonld-context-parser/index.js","webpack://solid.data/external \"$rdf\"","webpack://solid.data/external [\"solid\",\"auth\"]","webpack://solid.data/./node_modules/isomorphic-fetch/fetch-npm-browserify.js","webpack://solid.data/./node_modules/ldflex/node_modules/jsonld-context-parser/lib/FetchDocumentLoader.js","webpack://solid.data/./node_modules/@rdfjs/data-model/lib/default-graph.js","webpack://solid.data/./node_modules/@rdfjs/data-model/lib/named-node.js","webpack://solid.data/./node_modules/ldflex/node_modules/jsonld-context-parser/lib/ContextParser.js","webpack://solid.data/./node_modules/whatwg-fetch/fetch.js","webpack://solid.data/./node_modules/relative-to-absolute-iri/index.js","webpack://solid.data/./node_modules/relative-to-absolute-iri/lib/Resolve.js","webpack://solid.data/./node_modules/@rdfjs/data-model/lib/data-factory.js","webpack://solid.data/./node_modules/@rdfjs/data-model/lib/blank-node.js","webpack://solid.data/./node_modules/@rdfjs/data-model/lib/literal.js","webpack://solid.data/./node_modules/@rdfjs/data-model/lib/quad.js","webpack://solid.data/./node_modules/@rdfjs/data-model/lib/variable.js","webpack://solid.data/./node_modules/ldflex/module/iterableUtils.js","webpack://solid.data/./node_modules/ldflex/module/DataHandler.js","webpack://solid.data/./node_modules/ldflex/module/promiseUtils.js","webpack://solid.data/./node_modules/ldflex/module/MutationFunctionHandler.js","webpack://solid.data/./node_modules/ldflex/module/DeleteFunctionHandler.js","webpack://solid.data/./node_modules/ldflex/module/PreloadHandler.js","webpack://solid.data/./node_modules/ldflex/module/SortHandler.js","webpack://solid.data/./node_modules/ldflex/module/SparqlHandler.js","webpack://solid.data/./node_modules/ldflex/module/defaultHandlers.js","webpack://solid.data/./node_modules/ldflex/module/ThenHandler.js","webpack://solid.data/./node_modules/ldflex/module/AsyncIteratorHandler.js","webpack://solid.data/./node_modules/ldflex/module/SubjectHandler.js","webpack://solid.data/./node_modules/ldflex/module/PredicateHandler.js","webpack://solid.data/./node_modules/ldflex/module/PropertiesHandler.js","webpack://solid.data/./node_modules/ldflex/module/PredicatesHandler.js","webpack://solid.data/./node_modules/ldflex/module/PathExpressionHandler.js","webpack://solid.data/./node_modules/ldflex/module/SubjectsHandler.js","webpack://solid.data/./node_modules/ldflex/module/ExecuteQueryHandler.js","webpack://solid.data/./node_modules/ldflex/module/MutationExpressionsHandler.js","webpack://solid.data/./node_modules/ldflex/module/InsertFunctionHandler.js","webpack://solid.data/./node_modules/ldflex/module/SetFunctionHandler.js","webpack://solid.data/./node_modules/ldflex/module/ReplaceFunctionHandler.js","webpack://solid.data/./node_modules/ldflex/module/ToArrayHandler.js","webpack://solid.data/./node_modules/ldflex/module/StringToLDflexHandler.js","webpack://solid.data/./node_modules/ldflex/module/PathProxy.js","webpack://solid.data/./node_modules/ldflex/module/JSONLDResolver.js","webpack://solid.data/./node_modules/ldflex/module/PathFactory.js","webpack://solid.data/./src/handlers/ActivityHandler.js","webpack://solid.data/./src/util.js","webpack://solid.data/./node_modules/uuid/dist/esm-browser/rng.js","webpack://solid.data/./node_modules/uuid/dist/esm-browser/bytesToUuid.js","webpack://solid.data/./node_modules/uuid/dist/esm-browser/v4.js","webpack://solid.data/./src/handlers/CreateActivityHandler.js","webpack://solid.data/./src/handlers/DeleteActivityHandler.js","webpack://solid.data/./src/resolvers/SubjectPathResolver.js","webpack://solid.data/./src/handlers/SourcePathHandler.js","webpack://solid.data/./src/handlers/UserPathHandler.js","webpack://solid.data/./src/RootPath.js","webpack://solid.data/./src/resolvers/ContextResolver.js","webpack://solid.data/./src/handlers/SolidDeleteFunctionHandler.js","webpack://solid.data/./src/handlers/FindActivityHandler.js","webpack://solid.data/./src/SolidUpdateEngine.js","webpack://solid.data/./node_modules/@ldflex/rdflib/src/index.js","webpack://solid.data/./node_modules/@ldflex/rdflib/src/RdflibQueryEngine.js","webpack://solid.data/./src/exports/rdflib.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","DataFactory","__export","$rdf","solid","self","fetch","__awaiter","this","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","result","done","then","apply","FetchDocumentLoader","url","response","headers","accept","ok","json","Error","statusText","DefaultGraph","equals","other","termType","NamedNode","iri","relative_to_absolute_iri_1","FetchDocumentLoader_1","ContextParser","options","documentLoader","documentCache","validate","skipValidation","expandContentTypeToBase","term","indexOf","context","separatorPos","length","charAt","prefix","substr","contextValue","id","vocab","assertNormalized","getContextValueId","getPrefix","isCompactIri","startsWith","shortestPrefixing","suffix","contextIri","Array","isArray","IRI_REGEX","test","keys","EXPAND_KEYS_BLACKLIST","ALIAS_KEYS_BLACKLIST","isPrefixValue","changed","expandTerm","type","toLowerCase","valueType","JSON","stringify","objectKey","objectValue","isValidIri","CONTAINERS","join","baseIri","parentContext","external","parse","load","normalizeContextIri","all","map","subContext","reduce","accContextPromise","contextEntry","accContext","newContext","assign","idifyReverseTerms","expandPrefixedTerms","normalize","cached","slice","support","Blob","viewClasses","isArrayBufferView","ArrayBuffer","isView","obj","toString","normalizeName","String","TypeError","normalizeValue","iteratorFor","items","iterator","shift","undefined","Headers","forEach","append","header","getOwnPropertyNames","consumed","body","bodyUsed","fileReaderReady","reader","onload","onerror","error","readBlobAsArrayBuffer","blob","FileReader","promise","readAsArrayBuffer","bufferClone","buf","view","Uint8Array","byteLength","set","buffer","Body","_initBody","_bodyInit","_bodyText","isPrototypeOf","_bodyBlob","FormData","_bodyFormData","URLSearchParams","DataView","_bodyArrayBuffer","arrayBuffer","text","readAsText","chars","fromCharCode","readArrayBufferAsText","formData","decode","oldValue","has","callback","push","values","entries","methods","Request","input","method","upcased","credentials","signal","toUpperCase","referrer","form","trim","split","bytes","replace","decodeURIComponent","Response","bodyInit","status","clone","redirectStatuses","redirect","RangeError","location","DOMException","err","message","stack","constructor","init","request","aborted","xhr","XMLHttpRequest","abortXhr","abort","rawHeaders","getAllResponseHeaders","line","parts","responseURL","responseText","ontimeout","onabort","open","withCredentials","responseType","setRequestHeader","addEventListener","onreadystatechange","readyState","removeEventListener","send","polyfill","removeDotSegments","path","segmentBuffers","isCharacterAllowedAfterRelativePathSegment","pop","removeDotSegmentsOfPath","colonPosition","searchOffset","pathSeparator","character","relativeIRI","baseIRI","baseFragmentPos","baseQueryPos","valueColonPos","baseColonPos","baseIRIScheme","baseSlashAfterColonPos","baseIRIPath","baseIRILastSlashPos","lastIndexOf","BlankNode","Literal","Quad","Variable","namedNode","blankNode","literal","languageOrDatatype","defaultGraph","defaultGraphInstance","variable","triple","subject","predicate","quad","graph","nextId","language","datatype","stringDatatype","langStringDatatype","getFirstItem","iterable","asyncIterator","item","DataHandler","dataProperties","_isAsync","async","_isFunction","function","_dataProperties","pathData","_resolveDataPath","data","_resolveAsyncDataPath","_resolveSyncDataPath","lazyThenable","createPromise","getThen","onResolved","onRejected","toIterablePromise","cache","memoizeIterable","finally","mutationType","allowZeroArgs","_mutationType","_allowZeroArgs","args","concat","mutationExpressions","createMutationExpressions","extendPath","conditions","pathExpression","objects","extractObjects","arg","extractObject","super","VARIABLE","QUERY_TAIL","hashTerm","SortHandler","order","pathProxy","properties","rest","childData","sort","childPath","NEEDS_ESCAPE","ESCAPE_ALL","ESCAPED_CHARS","SparqlHandler","mutationExpressionToQuery","pathExpressionToQuery","finalClause","queryVar","sorts","clauses","createVar","expressionToTriplePatterns","distinct","select","where","orderClauses","orderBy","scope","termToString","lastPredicate","objectList","mutationPattern","root","lastVar","lastIndex","skolemized","skolemId","skolemize","segment","index","suggestion","counter","label","match","escapeCharacter","charCodeAt","results","parent","_handle","settings","parsedContext","predicates","compactIri","segments","current","unshift","sparql","subjects","resultsCache","queryEngine","query","bindings","execute","extractTerm","binding","size","sortDesc","preload","createResultsCache","vars","resultVar","createQuery","propertyCaches","hash","propertyCache","resultData","valuePath","parentQuery","variableMatch","exec","preloadClauses","add","delete","newValues","termPropertyHandler","sync","syncFunction","toPrimitive","toArray","termTypes","handler","_","datatypes","languages","expression","ldflex","propertyPath","evaluator","Function","handle","subjectValue","EMPTY","PathProxy","handlers","resolvers","_handlers","_resolvers","proxy","Proxy","newData","createPath","resolver","supports","contexts","_context","extendContext","expandProperty","getResultsCache","expandedProperty","currentContext","_settings","_data","defaultHandlers","toHandler","getOwnPropertySymbols","toResolver","_pathProxy","as","ActivityHandler","activitiesPath","requireUser","user","storage","pim$storage","document","URL","href","actor","activity","createResults","processResults","replaceVariables","template","terms","RegExp","asList","getRandomValues","crypto","msCrypto","rnds8","rng","byteToHex","offset","bth","rnds","random","ii","xsd","components","SubjectPathResolver","pathFactory","source","_paths","_source","_createSubjectPath","createQueryEngine","catch","SourcePathHandler","PathFactory","UserPathHandler","getWebId","session","auth","currentSession","webId","contextResolver","JSONLDResolver","exposedContext","_exposedContext","subjectHandlers","DeleteFunctionHandler","existing","filter","some","findActivity","likes","dislikes","follows","createActivity","uuidv4","insert","published","Date","toISOString","executeUpdate","like","dislike","follow","deleteActivity","unlike","undislike","unfollow","SolidUpdateEngine","sources","baseEngine","getUpdateSource","_engine","clearCache","defaultSources","_defaultStore","readSources","store","fetcher","Set","v","Map","sourceList","addQuad","finish","removeListener","on","defaultSettings","rootPath","subjectPathFactory","from","doc","RdflibQueryEngine"],"mappings":"iEACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QA0Df,OArDAF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,oBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,GAIjBlC,EAAoBA,EAAoBmC,EAAI,I,kBClFrD,IAAIC,EAAc,EAAQ,IAE1BjC,EAAOD,QAAUkC,G,6BCDjB,SAASC,EAAS7B,GACd,IAAK,IAAI0B,KAAK1B,EAAQN,EAAQ+B,eAAeC,KAAIhC,EAAQgC,GAAK1B,EAAE0B,IAEpEpB,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,IACtDgB,EAAS,EAAQ,KACjBA,EAAS,EAAQ,K,gpGCNjBlC,EAAOD,QAAUoC,M,cCAjBnC,EAAOD,QAAUqC,MAAY,M,gBCI7B,EAAQ,IACRpC,EAAOD,QAAUsC,KAAKC,MAAMb,KAAKY,O,6BCJjC,IAAIE,EAAaC,MAAQA,KAAKD,WAAc,SAAUE,EAASC,EAAYC,EAAGC,GAC1E,OAAO,IAAKD,IAAMA,EAAIE,WAAU,SAAUC,EAASC,GAC/C,SAASC,EAAU9B,GAAS,IAAM+B,EAAKL,EAAUM,KAAKhC,IAAW,MAAOiC,GAAKJ,EAAOI,IACpF,SAASC,EAASlC,GAAS,IAAM+B,EAAKL,EAAiB,MAAE1B,IAAW,MAAOiC,GAAKJ,EAAOI,IACvF,SAASF,EAAKI,GAAUA,EAAOC,KAAOR,EAAQO,EAAOnC,OAAS,IAAIyB,GAAE,SAAUG,GAAWA,EAAQO,EAAOnC,UAAWqC,KAAKP,EAAWI,GACnIH,GAAML,EAAYA,EAAUY,MAAMf,EAASC,GAAc,KAAKQ,YAGtEvC,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,IACtD,EAAQ,GAiBRnB,EAAQ0D,oBAbR,MACI,KAAKC,GACD,OAAOnB,EAAUC,UAAM,OAAQ,GAAQ,YACnC,MAAMmB,QAAiBrB,MAAMoB,EAAK,CAAEE,QAAS,CAAEC,OAAQ,yBACvD,GAAIF,EAASG,GACT,aAAcH,EAASI,OAGvB,MAAM,IAAIC,MAAM,iCAAiCN,MAAQC,EAASM,oB,cCtBlF,SAASC,IACP1B,KAAKtB,MAAQ,GAGfgD,EAAarC,UAAUsC,OAAS,SAAUC,GACxC,QAASA,GAASA,EAAMC,WAAa7B,KAAK6B,UAG5CH,EAAarC,UAAUwC,SAAW,eAElCrE,EAAOD,QAAUmE,G,cCVjB,SAASI,EAAWC,GAClB/B,KAAKtB,MAAQqD,EAGfD,EAAUzC,UAAUsC,OAAS,SAAUC,GACrC,QAASA,GAASA,EAAMC,WAAa7B,KAAK6B,UAAYD,EAAMlD,QAAUsB,KAAKtB,OAG7EoD,EAAUzC,UAAUwC,SAAW,YAE/BrE,EAAOD,QAAUuE,G,6BCTjB,IAAI/B,EAAaC,MAAQA,KAAKD,WAAc,SAAUE,EAASC,EAAYC,EAAGC,GAC1E,OAAO,IAAKD,IAAMA,EAAIE,WAAU,SAAUC,EAASC,GAC/C,SAASC,EAAU9B,GAAS,IAAM+B,EAAKL,EAAUM,KAAKhC,IAAW,MAAOiC,GAAKJ,EAAOI,IACpF,SAASC,EAASlC,GAAS,IAAM+B,EAAKL,EAAiB,MAAE1B,IAAW,MAAOiC,GAAKJ,EAAOI,IACvF,SAASF,EAAKI,GAAUA,EAAOC,KAAOR,EAAQO,EAAOnC,OAAS,IAAIyB,GAAE,SAAUG,GAAWA,EAAQO,EAAOnC,UAAWqC,KAAKP,EAAWI,GACnIH,GAAML,EAAYA,EAAUY,MAAMf,EAASC,GAAc,KAAKQ,YAGtEvC,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,IACtD,EAAQ,GACR,MAAMsD,EAA6B,EAAQ,IACrCC,EAAwB,EAAQ,GAItC,MAAMC,EACF,YAAYC,GACRA,EAAUA,GAAW,GACrBnC,KAAKoC,eAAiBD,EAAQC,gBAAkB,IAAIH,EAAsBhB,oBAC1EjB,KAAKqC,cAAgB,GACrBrC,KAAKsC,UAAYH,EAAQI,eACzBvC,KAAKwC,wBAA0BL,EAAQK,wBAQ3C,oBAAoBC,GAChB,OAAOA,EAAKC,QAAQ,MAAQ,KAAOD,GAAoB,MAAZA,EAAK,IASpD,iBAAiBA,EAAME,GAEnB,GAAIF,GAAoB,MAAZA,EAAK,GACb,OAAO,KAEX,MAAMG,EAAeH,EAAKC,QAAQ,KAClC,GAAIE,GAAgB,EAAG,CAEnB,GAAIH,EAAKI,OAASD,EAAe,GACQ,MAAlCH,EAAKK,OAAOF,EAAe,IACO,MAAlCH,EAAKK,OAAOF,EAAe,GAC9B,OAAO,KAEX,MAAMG,EAASN,EAAKO,OAAO,EAAGJ,GAE9B,GAAe,MAAXG,EACA,OAAO,KAGX,GAAIJ,EAAQI,GACR,OAAOA,EAGf,OAAO,KAOX,yBAAyBE,GACrB,GAAqB,OAAjBA,GAAiD,iBAAjBA,EAChC,OAAOA,EAEX,MAAMC,EAAKD,EAAa,OACxB,OAAOC,GAAU,KAsBrB,kBAAkBT,EAAME,EAASQ,GAC7BjB,EAAckB,iBAAiBT,GAC/B,MAAMM,EAAeN,EAAQF,GAE7B,GAAqB,OAAjBQ,GAA0BA,GAAwC,OAAxBA,EAAa,OACvD,OAAO,KAGX,GAAIA,GAAgBE,EAAO,CACvB,MAAMzE,EAAQsB,KAAKqD,kBAAkBJ,GACrC,GAAIvE,GAASA,IAAU+D,EACnB,OAAO/D,EAIf,MAAMqE,EAASb,EAAcoB,UAAUb,EAAME,GAC7C,GAAII,EAAQ,CACR,MAAMrE,EAAQsB,KAAKqD,kBAAkBV,EAAQI,IAC7C,GAAIrE,EACA,OAAOA,EAAQ+D,EAAKO,OAAOD,EAAOF,OAAS,OAG9C,IAAIM,GAASR,EAAQ,WAAgC,MAAnBF,EAAKK,OAAO,KAAeZ,EAAcqB,aAAad,GACzF,OAAOE,EAAQ,UAAYF,EAE1B,IAAKU,GAASR,EAAQ,UAA+B,MAAnBF,EAAKK,OAAO,KAAeZ,EAAcqB,aAAad,GACzF,OAAOT,EAA2B1B,QAAQmC,EAAME,EAAQ,UAE5D,OAAOF,EAaX,kBAAkBV,EAAKY,EAASQ,GAG5B,GAFAjB,EAAckB,iBAAiBT,GAE3BQ,GAASR,EAAQ,WAAaZ,EAAIyB,WAAWb,EAAQ,WACrD,OAAOZ,EAAIiB,OAAOL,EAAQ,UAAUE,QAGxC,IAAKM,GAASR,EAAQ,UAAYZ,EAAIyB,WAAWb,EAAQ,UACrD,OAAOZ,EAAIiB,OAAOL,EAAQ,SAASE,QAKvC,MAAMY,EAAoB,CAAEV,OAAQ,GAAIW,OAAQ3B,GAChD,IAAK,MAAM/C,KAAO2D,EAAS,CACvB,MAAMjE,EAAQiE,EAAQ3D,GACtB,GAAIN,IAAUM,EAAIwE,WAAW,KAAM,CAC/B,MAAMG,EAAa3D,KAAKqD,kBAAkB3E,GAC1C,GAAIqD,EAAIyB,WAAWG,GAAa,CAC5B,MAAMD,EAAS3B,EAAIiB,OAAOW,EAAWd,QACrC,GAAKa,EAMIA,EAAOb,OAASY,EAAkBC,OAAOb,SAE9CY,EAAkBV,OAAS/D,EAC3ByE,EAAkBC,OAASA,QAR3B,GAAIP,EAEA,OAAOnE,IAY3B,OAAIyE,EAAkBV,OACXU,EAAkBV,OAAS,IAAMU,EAAkBC,OAEvD3B,EAOX,wBAAwBY,GACpB,GAAuB,iBAAZA,GAAwBiB,MAAMC,QAAQlB,IAAYA,EAAQ,YACjE,MAAM,IAAInB,MAAM,uFAQxB,qBAAqB9C,GACjB,OAAOA,IAA2B,iBAAVA,GAAsBA,EAAM,QAAUA,EAAM,UAOxE,kBAAkBqD,GACd,OAAOG,EAAc4B,UAAUC,KAAKhC,GAOxC,yBAAyBY,GACrB,IAAK,MAAM3D,KAAOb,OAAO6F,KAAKrB,GAAU,CACpC,MAAMjE,EAAQiE,EAAQ3D,GACtB,GAAIN,GAA0B,iBAAVA,GACZA,EAAM,cAAgBA,EAAM,OAAQ,CACpC,GAAiC,iBAAtBA,EAAM,YACb,MAAM,IAAI8C,MAAM,4BAA4B9C,EAAM,gBAEtDA,EAAM,OAASA,EAAM,YACrBA,EAAM,aAAc,GAIhC,OAAOiE,EASX,2BAA2BA,EAASH,GAChC,IAAK,MAAMxD,KAAOb,OAAO6F,KAAKrB,GAE1B,GAAIT,EAAc+B,sBAAsBvB,QAAQ1D,GAAO,EAAG,CAEtD,GAAe,MAAXA,EAAI,IAAckD,EAAcgC,qBAAqBxB,QAAQ1D,IAAQ,EACrE,MAAM,IAAIwC,MAAM,iEACpBxC,QAAU2D,EAAQ3D,MAGlB,KAAOkD,EAAciC,cAAcxB,EAAQ3D,KAAO,CAC9C,MAAMN,EAAQiE,EAAQ3D,GACtB,IAAIoF,GAAU,EACd,GAAqB,iBAAV1F,EACPiE,EAAQ3D,GAAOkD,EAAcmC,WAAW3F,EAAOiE,GAAS,GACxDyB,EAAUA,GAAW1F,IAAUiE,EAAQ3D,OAEtC,CACD,MAAMkE,EAAKxE,EAAM,OACX4F,EAAO5F,EAAM,SACfwE,IACAP,EAAQ3D,GAAK,OAASkD,EAAcmC,WAAWnB,EAAIP,GAAS,GAC5DyB,EAAUA,GAAWlB,IAAOP,EAAQ3D,GAAK,QAEzCsF,GAAiB,WAATA,IAER3B,EAAQ3D,GAAK,SAAWkD,EAAcmC,WAAWC,EAAM3B,GAAS,GAC5DH,GAA2B8B,IAAS3B,EAAQ3D,GAAK,WACjD2D,EAAQ3D,GAAK,SAAWkD,EAAcmC,WAAWC,EAAM3B,GAAS,IAEpEyB,EAAUA,GAAWE,IAAS3B,EAAQ3D,GAAK,UAGnD,IAAKoF,EACD,OAKhB,OAAOzB,EAOX,iBAAiBA,GACb,IAAK,MAAM3D,KAAOb,OAAO6F,KAAKrB,GAC1B,GAAY,cAAR3D,GAA+C,iBAAjB2D,EAAQ3D,GACtC2D,EAAQ3D,GAAO2D,EAAQ3D,GAAKuF,kBAE3B,CACD,MAAM7F,EAAQiE,EAAQ3D,GAClBN,GAA0B,iBAAVA,GACkB,iBAAvBA,EAAM,eACbA,EAAM,aAAeA,EAAM,aAAa6F,eAKxD,OAAO5B,EAMX,gBAAgBA,GACZ,IAAK,MAAM3D,KAAOb,OAAO6F,KAAKrB,GAAU,CACpC,MAAMjE,EAAQiE,EAAQ3D,GAChBwF,SAAmB9F,EAEzB,GAAe,MAAXM,EAAI,GACJ,OAAQA,EAAIgE,OAAO,IACf,IAAK,QACD,GAAc,OAAVtE,GAAgC,WAAd8F,EAClB,MAAM,IAAIhD,MAAM,gCAAgC9C,GAEpD,MACJ,IAAK,OACD,GAAc,OAAVA,GAAgC,WAAd8F,EAClB,MAAM,IAAIhD,MAAM,+BAA+BmB,EAAQ3D,IAE3D,MACJ,IAAK,WACD,GAAc,OAAVN,GAAgC,WAAd8F,EAClB,MAAM,IAAIhD,MAAM,sCAAsC9C,GAMtE,GAAc,OAAVA,EACA,OAAQ8F,GACJ,IAAK,SAED,MACJ,IAAK,SACD,KAAKtC,EAAcqB,aAAavE,IAAU,QAASN,IACxB,QAAnBA,EAAM,SAAsBiE,EAAQ,SAAYA,EAAQ,YAC5D,MAAM,IAAInB,MAAM,kCAAkCxC,QAAUyF,KAAKC,UAAUhG,OAE/E,IAAK,MAAMiG,KAAaxG,OAAO6F,KAAKtF,GAAQ,CACxC,MAAMkG,EAAclG,EAAMiG,GAC1B,GAAKC,EAGL,OAAQD,GACJ,IAAK,MACD,GAAuB,MAAnBC,EAAY,IAA8B,UAAhBA,GAA2C,QAAhBA,EACrD,MAAM,IAAIpD,MAAM,gDAAgDxC,QAAUyF,KAAKC,UAAUhG,OAE7F,MACJ,IAAK,QACD,GAAoB,QAAhBkG,GAAyC,WAAhBA,IACF,MAAnBA,EAAY,KAAe1C,EAAc2C,WAAWD,IACxD,MAAM,IAAIpD,MAAM,oDAAoDxC,QAAU4F,MAElF,MACJ,IAAK,WACD,GAA2B,iBAAhBA,GAA4BlG,EAAM,QAAUA,EAAM,SAAWkG,EACpE,MAAM,IAAIpD,MAAM,uDAAuDxC,OAC5G4F,WAAqBlG,EAAM,WAEM,MACJ,IAAK,aACD,GAAoB,UAAhBkG,GAA2BlG,EAAM,YACjC,MAAM,IAAI8C,MAAM,6EAA6ExC,MAEjG,GAAIkD,EAAc4C,WAAWpC,QAAQkC,GAAe,EAChD,MAAM,IAAIpD,MAAM,gCAAgCxC,QAAU4F,uBACjF1C,EAAc4C,WAAWC,KAAK,SAEX,MACJ,IAAK,YACD,GAAoB,OAAhBH,GAA+C,iBAAhBA,EAC/B,MAAM,IAAIpD,MAAM,+CAA+CxC,QAAUyF,KAAKC,UAAUhG,QAKxG,MACJ,QACI,MAAM,IAAI8C,MAAM,iCAAiCxC,QAAUN,QAW/E,2BAA2BiF,EAAYqB,GACnC,IAAK9C,EAAc2C,WAAWlB,KAC1BA,EAAa3B,EAA2B1B,QAAQqD,EAAYqB,IACvD9C,EAAc2C,WAAWlB,IAC1B,MAAM,IAAInC,MAAM,wBAAwBmC,GAGhD,OAAOA,EAQX,MAAMhB,GAAS,QAAEqC,EAAO,cAAEC,EAAa,SAAEC,GAAa,IAClD,OAAOnF,EAAUC,UAAM,OAAQ,GAAQ,YACnC,GAAI2C,QAEA,OAAOqC,EAAU,CAAE,QAASA,GAAY,GAEvC,GAAuB,iBAAZrC,EACZ,OAAO3C,KAAKmF,YAAYnF,KAAKoF,KAAKlD,EAAcmD,oBAAoB1C,EAASqC,IAAW,CAAEA,UAASC,gBAAeC,UAAU,IAE3H,GAAItB,MAAMC,QAAQlB,GAAU,CAU7B,aARuBtC,QAAQiF,IAAI3C,EAAQ4C,IAAKC,GAClB,iBAAfA,EACAxF,KAAKoF,KAAKlD,EAAcmD,oBAAoBG,EAAYR,IAGxDQ,KAGCC,OAAO,CAACC,EAAmBC,IAAiBD,EACvD3E,KAAM6E,GAAe5F,KAAKmF,MAAMQ,EAAc,CAC/CX,QAASY,GAAcA,EAAW,UAAYZ,EAC9CE,WACAD,cAAeW,KACdvF,QAAQC,QAAQ2E,IAEpB,GAAuB,iBAAZtC,EAAsB,CAClC,GAAIA,EAAQ,YACR,aAAa3C,KAAKmF,MAAMxC,EAAQ,YAAa,CAAEqC,UAASC,gBAAeC,aAG3EvC,EAAU8B,KAAKU,MAAMV,KAAKC,UAAU/B,IAEpC,IAAIkD,EAAa,GAuBjB,OArBIX,UACOvC,EAAQ,SAGfqC,IACM,UAAWrC,EAIa,OAArBA,EAAQ,UAAsBT,EAAc2C,WAAWlC,EAAQ,YAEpEA,EAAQ,SAAWX,EAA2B1B,QAAQqC,EAAQ,SAAUqC,IAJxErC,EAAQ,SAAWqC,GAO3Ba,EAAa1H,OAAO2H,OAAO,GAAID,EAAYZ,EAAetC,GAC1DT,EAAc6D,kBAAkBF,GAChC3D,EAAc8D,oBAAoBH,EAAY7F,KAAKwC,yBACnDN,EAAc+D,UAAUJ,GACpB7F,KAAKsC,UACLJ,EAAcI,SAASuD,GAEpBA,EAGP,MAAM,IAAIrE,MAAM,0EAA0EmB,MAItG,KAAKzB,GACD,OAAOnB,EAAUC,UAAM,OAAQ,GAAQ,YACnC,MAAMkG,EAASlG,KAAKqC,cAAcnB,GAClC,OAAIgF,EACOtC,MAAMC,QAAQqC,GAAUA,EAAOC,QAAUhI,OAAO2H,OAAO,GAAII,GAE/DlG,KAAKqC,cAAcnB,UAAclB,KAAKoC,eAAegD,KAAKlE,IAAM,gBAKnFgB,EAAc4B,UAAY,mDAE1B5B,EAAc+B,sBAAwB,CAClC,QACA,SACA,aAGJ/B,EAAcgC,qBAAuB,CACjC,aACA,SACA,MACA,SACA,QACA,QACA,QACA,UACA,WACA,OACA,QACA,UAGJhC,EAAc4C,WAAa,CACvB,QACA,OACA,SACA,aAEJvH,EAAQ2E,cAAgBA,G,6BCtfxB,uNAAIkE,EACY,oBAAqBvG,KADjCuG,EAEQ,WAAYvG,MAAQ,aAAcrB,OAF1C4H,EAIA,eAAgBvG,MAChB,SAAUA,MACV,WACE,IAEE,OADA,IAAIwG,MACG,EACP,MAAO1F,GACP,OAAO,GALX,GANAyF,EAcQ,aAAcvG,KAdtBuG,EAeW,gBAAiBvG,KAOhC,GAAIuG,EACF,IAAIE,EAAc,CAChB,qBACA,sBACA,6BACA,sBACA,uBACA,sBACA,uBACA,wBACA,yBAGEC,EACFC,YAAYC,QACZ,SAASC,GACP,OAAOA,GAAOJ,EAAY5D,QAAQvE,OAAOkB,UAAUsH,SAAS/I,KAAK8I,KAAS,GAIhF,SAASE,EAAc5I,GAIrB,GAHoB,iBAATA,IACTA,EAAO6I,OAAO7I,IAEZ,4BAA4B+F,KAAK/F,GACnC,MAAM,IAAI8I,UAAU,0CAEtB,OAAO9I,EAAKuG,cAGd,SAASwC,EAAerI,GAItB,MAHqB,iBAAVA,IACTA,EAAQmI,OAAOnI,IAEVA,EAIT,SAASsI,EAAYC,GACnB,IAAIC,EAAW,CACbxG,KAAM,WACJ,IAAIhC,EAAQuI,EAAME,QAClB,MAAO,CAACrG,UAAgBsG,IAAV1I,EAAqBA,MAAOA,KAU9C,OANI0H,IACFc,EAAS1I,OAAO0I,UAAY,WAC1B,OAAOA,IAIJA,EAGF,SAASG,EAAQjG,GACtBpB,KAAKuF,IAAM,GAEPnE,aAAmBiG,EACrBjG,EAAQkG,SAAQ,SAAS5I,EAAOV,GAC9BgC,KAAKuH,OAAOvJ,EAAMU,KACjBsB,MACM4D,MAAMC,QAAQzC,GACvBA,EAAQkG,SAAQ,SAASE,GACvBxH,KAAKuH,OAAOC,EAAO,GAAIA,EAAO,MAC7BxH,MACMoB,GACTjD,OAAOsJ,oBAAoBrG,GAASkG,SAAQ,SAAStJ,GACnDgC,KAAKuH,OAAOvJ,EAAMoD,EAAQpD,MACzBgC,MAgEP,SAAS0H,EAASC,GAChB,GAAIA,EAAKC,SACP,OAAOvH,QAAQE,OAAO,IAAIuG,UAAU,iBAEtCa,EAAKC,UAAW,EAGlB,SAASC,EAAgBC,GACvB,OAAO,IAAIzH,SAAQ,SAASC,EAASC,GACnCuH,EAAOC,OAAS,WACdzH,EAAQwH,EAAOjH,SAEjBiH,EAAOE,QAAU,WACfzH,EAAOuH,EAAOG,WAKpB,SAASC,EAAsBC,GAC7B,IAAIL,EAAS,IAAIM,WACbC,EAAUR,EAAgBC,GAE9B,OADAA,EAAOQ,kBAAkBH,GAClBE,EAoBT,SAASE,EAAYC,GACnB,GAAIA,EAAIrC,MACN,OAAOqC,EAAIrC,MAAM,GAEjB,IAAIsC,EAAO,IAAIC,WAAWF,EAAIG,YAE9B,OADAF,EAAKG,IAAI,IAAIF,WAAWF,IACjBC,EAAKI,OAIhB,SAASC,IA0FP,OAzFA9I,KAAK4H,UAAW,EAEhB5H,KAAK+I,UAAY,SAASpB,GAhM5B,IAAoBjB,EAiMhB1G,KAAKgJ,UAAYrB,EACZA,EAEsB,iBAATA,EAChB3H,KAAKiJ,UAAYtB,EACRvB,GAAgBC,KAAKhH,UAAU6J,cAAcvB,GACtD3H,KAAKmJ,UAAYxB,EACRvB,GAAoBgD,SAAS/J,UAAU6J,cAAcvB,GAC9D3H,KAAKqJ,cAAgB1B,EACZvB,GAAwBkD,gBAAgBjK,UAAU6J,cAAcvB,GACzE3H,KAAKiJ,UAAYtB,EAAKhB,WACbP,GAAuBA,KA5MlBM,EA4M6CiB,IA3MjD4B,SAASlK,UAAU6J,cAAcxC,KA4M3C1G,KAAKwJ,iBAAmBjB,EAAYZ,EAAKkB,QAEzC7I,KAAKgJ,UAAY,IAAI3C,KAAK,CAACrG,KAAKwJ,oBACvBpD,IAAwBI,YAAYnH,UAAU6J,cAAcvB,IAASpB,EAAkBoB,IAChG3H,KAAKwJ,iBAAmBjB,EAAYZ,GAEpC3H,KAAKiJ,UAAYtB,EAAOxJ,OAAOkB,UAAUsH,SAAS/I,KAAK+J,GAhBvD3H,KAAKiJ,UAAY,GAmBdjJ,KAAKoB,QAAQ9C,IAAI,kBACA,iBAATqJ,EACT3H,KAAKoB,QAAQwH,IAAI,eAAgB,4BACxB5I,KAAKmJ,WAAanJ,KAAKmJ,UAAU7E,KAC1CtE,KAAKoB,QAAQwH,IAAI,eAAgB5I,KAAKmJ,UAAU7E,MACvC8B,GAAwBkD,gBAAgBjK,UAAU6J,cAAcvB,IACzE3H,KAAKoB,QAAQwH,IAAI,eAAgB,qDAKnCxC,IACFpG,KAAKmI,KAAO,WACV,IAAIvH,EAAW8G,EAAS1H,MACxB,GAAIY,EACF,OAAOA,EAGT,GAAIZ,KAAKmJ,UACP,OAAO9I,QAAQC,QAAQN,KAAKmJ,WACvB,GAAInJ,KAAKwJ,iBACd,OAAOnJ,QAAQC,QAAQ,IAAI+F,KAAK,CAACrG,KAAKwJ,oBACjC,GAAIxJ,KAAKqJ,cACd,MAAM,IAAI7H,MAAM,wCAEhB,OAAOnB,QAAQC,QAAQ,IAAI+F,KAAK,CAACrG,KAAKiJ,cAI1CjJ,KAAKyJ,YAAc,WACjB,OAAIzJ,KAAKwJ,iBACA9B,EAAS1H,OAASK,QAAQC,QAAQN,KAAKwJ,kBAEvCxJ,KAAKmI,OAAOpH,KAAKmH,KAK9BlI,KAAK0J,KAAO,WACV,IA3FoBvB,EAClBL,EACAO,EAyFEzH,EAAW8G,EAAS1H,MACxB,GAAIY,EACF,OAAOA,EAGT,GAAIZ,KAAKmJ,UACP,OAjGkBhB,EAiGInI,KAAKmJ,UAhG3BrB,EAAS,IAAIM,WACbC,EAAUR,EAAgBC,GAC9BA,EAAO6B,WAAWxB,GACXE,EA8FE,GAAIrI,KAAKwJ,iBACd,OAAOnJ,QAAQC,QA5FrB,SAA+BkI,GAI7B,IAHA,IAAIC,EAAO,IAAIC,WAAWF,GACtBoB,EAAQ,IAAIhG,MAAM6E,EAAK5F,QAElBpF,EAAI,EAAGA,EAAIgL,EAAK5F,OAAQpF,IAC/BmM,EAAMnM,GAAKoJ,OAAOgD,aAAapB,EAAKhL,IAEtC,OAAOmM,EAAM7E,KAAK,IAqFS+E,CAAsB9J,KAAKwJ,mBAC7C,GAAIxJ,KAAKqJ,cACd,MAAM,IAAI7H,MAAM,wCAEhB,OAAOnB,QAAQC,QAAQN,KAAKiJ,YAI5B7C,IACFpG,KAAK+J,SAAW,WACd,OAAO/J,KAAK0J,OAAO3I,KAAKiJ,KAI5BhK,KAAKuB,KAAO,WACV,OAAOvB,KAAK0J,OAAO3I,KAAK0D,KAAKU,QAGxBnF,KA1MTqH,EAAQhI,UAAUkI,OAAS,SAASvJ,EAAMU,GACxCV,EAAO4I,EAAc5I,GACrBU,EAAQqI,EAAerI,GACvB,IAAIuL,EAAWjK,KAAKuF,IAAIvH,GACxBgC,KAAKuF,IAAIvH,GAAQiM,EAAWA,EAAW,KAAOvL,EAAQA,GAGxD2I,EAAQhI,UAAkB,OAAI,SAASrB,UAC9BgC,KAAKuF,IAAIqB,EAAc5I,KAGhCqJ,EAAQhI,UAAUf,IAAM,SAASN,GAE/B,OADAA,EAAO4I,EAAc5I,GACdgC,KAAKkK,IAAIlM,GAAQgC,KAAKuF,IAAIvH,GAAQ,MAG3CqJ,EAAQhI,UAAU6K,IAAM,SAASlM,GAC/B,OAAOgC,KAAKuF,IAAIjG,eAAesH,EAAc5I,KAG/CqJ,EAAQhI,UAAUuJ,IAAM,SAAS5K,EAAMU,GACrCsB,KAAKuF,IAAIqB,EAAc5I,IAAS+I,EAAerI,IAGjD2I,EAAQhI,UAAUiI,QAAU,SAAS6C,EAAUlK,GAC7C,IAAK,IAAIjC,KAAQgC,KAAKuF,IAChBvF,KAAKuF,IAAIjG,eAAetB,IAC1BmM,EAASvM,KAAKqC,EAASD,KAAKuF,IAAIvH,GAAOA,EAAMgC,OAKnDqH,EAAQhI,UAAU2E,KAAO,WACvB,IAAIiD,EAAQ,GAIZ,OAHAjH,KAAKsH,SAAQ,SAAS5I,EAAOV,GAC3BiJ,EAAMmD,KAAKpM,MAENgJ,EAAYC,IAGrBI,EAAQhI,UAAUgL,OAAS,WACzB,IAAIpD,EAAQ,GAIZ,OAHAjH,KAAKsH,SAAQ,SAAS5I,GACpBuI,EAAMmD,KAAK1L,MAENsI,EAAYC,IAGrBI,EAAQhI,UAAUiL,QAAU,WAC1B,IAAIrD,EAAQ,GAIZ,OAHAjH,KAAKsH,SAAQ,SAAS5I,EAAOV,GAC3BiJ,EAAMmD,KAAK,CAACpM,EAAMU,OAEbsI,EAAYC,IAGjBb,IACFiB,EAAQhI,UAAUb,OAAO0I,UAAYG,EAAQhI,UAAUiL,SAqJzD,IAAIC,EAAU,CAAC,SAAU,MAAO,OAAQ,UAAW,OAAQ,OAOpD,SAASC,EAAQC,EAAOtI,GAE7B,IAPuBuI,EACnBC,EAMAhD,GADJxF,EAAUA,GAAW,IACFwF,KAEnB,GAAI8C,aAAiBD,EAAS,CAC5B,GAAIC,EAAM7C,SACR,MAAM,IAAId,UAAU,gBAEtB9G,KAAKkB,IAAMuJ,EAAMvJ,IACjBlB,KAAK4K,YAAcH,EAAMG,YACpBzI,EAAQf,UACXpB,KAAKoB,QAAU,IAAIiG,EAAQoD,EAAMrJ,UAEnCpB,KAAK0K,OAASD,EAAMC,OACpB1K,KAAKpB,KAAO6L,EAAM7L,KAClBoB,KAAK6K,OAASJ,EAAMI,OACflD,GAA2B,MAAnB8C,EAAMzB,YACjBrB,EAAO8C,EAAMzB,UACbyB,EAAM7C,UAAW,QAGnB5H,KAAKkB,IAAM2F,OAAO4D,GAYpB,GATAzK,KAAK4K,YAAczI,EAAQyI,aAAe5K,KAAK4K,aAAe,eAC1DzI,EAAQf,SAAYpB,KAAKoB,UAC3BpB,KAAKoB,QAAU,IAAIiG,EAAQlF,EAAQf,UAErCpB,KAAK0K,QAjCkBA,EAiCOvI,EAAQuI,QAAU1K,KAAK0K,QAAU,MAhC3DC,EAAUD,EAAOI,cACdP,EAAQ7H,QAAQiI,IAAY,EAAIA,EAAUD,GAgCjD1K,KAAKpB,KAAOuD,EAAQvD,MAAQoB,KAAKpB,MAAQ,KACzCoB,KAAK6K,OAAS1I,EAAQ0I,QAAU7K,KAAK6K,OACrC7K,KAAK+K,SAAW,MAEK,QAAhB/K,KAAK0K,QAAoC,SAAhB1K,KAAK0K,SAAsB/C,EACvD,MAAM,IAAIb,UAAU,6CAEtB9G,KAAK+I,UAAUpB,GAOjB,SAASqC,EAAOrC,GACd,IAAIqD,EAAO,IAAI5B,SAYf,OAXAzB,EACGsD,OACAC,MAAM,KACN5D,SAAQ,SAAS6D,GAChB,GAAIA,EAAO,CACT,IAAID,EAAQC,EAAMD,MAAM,KACpBlN,EAAOkN,EAAM/D,QAAQiE,QAAQ,MAAO,KACpC1M,EAAQwM,EAAMnG,KAAK,KAAKqG,QAAQ,MAAO,KAC3CJ,EAAKzD,OAAO8D,mBAAmBrN,GAAOqN,mBAAmB3M,QAGxDsM,EAqBF,SAASM,EAASC,EAAUpJ,GAC5BA,IACHA,EAAU,IAGZnC,KAAKsE,KAAO,UACZtE,KAAKwL,YAA4BpE,IAAnBjF,EAAQqJ,OAAuB,IAAMrJ,EAAQqJ,OAC3DxL,KAAKsB,GAAKtB,KAAKwL,QAAU,KAAOxL,KAAKwL,OAAS,IAC9CxL,KAAKyB,WAAa,eAAgBU,EAAUA,EAAQV,WAAa,KACjEzB,KAAKoB,QAAU,IAAIiG,EAAQlF,EAAQf,SACnCpB,KAAKkB,IAAMiB,EAAQjB,KAAO,GAC1BlB,KAAK+I,UAAUwC,GAjDjBf,EAAQnL,UAAUoM,MAAQ,WACxB,OAAO,IAAIjB,EAAQxK,KAAM,CAAC2H,KAAM3H,KAAKgJ,aAmCvCF,EAAKlL,KAAK4M,EAAQnL,WAgBlByJ,EAAKlL,KAAK0N,EAASjM,WAEnBiM,EAASjM,UAAUoM,MAAQ,WACzB,OAAO,IAAIH,EAAStL,KAAKgJ,UAAW,CAClCwC,OAAQxL,KAAKwL,OACb/J,WAAYzB,KAAKyB,WACjBL,QAAS,IAAIiG,EAAQrH,KAAKoB,SAC1BF,IAAKlB,KAAKkB,OAIdoK,EAASrD,MAAQ,WACf,IAAI9G,EAAW,IAAImK,EAAS,KAAM,CAACE,OAAQ,EAAG/J,WAAY,KAE1D,OADAN,EAASmD,KAAO,QACTnD,GAGT,IAAIuK,EAAmB,CAAC,IAAK,IAAK,IAAK,IAAK,KAE5CJ,EAASK,SAAW,SAASzK,EAAKsK,GAChC,IAA0C,IAAtCE,EAAiBhJ,QAAQ8I,GAC3B,MAAM,IAAII,WAAW,uBAGvB,OAAO,IAAIN,EAAS,KAAM,CAACE,OAAQA,EAAQpK,QAAS,CAACyK,SAAU3K,MAG1D,IAAI4K,EAAejM,KAAKiM,aAC/B,IACE,IAAIA,EACJ,MAAOC,IACPD,EAAe,SAASE,EAAShO,GAC/BgC,KAAKgM,QAAUA,EACfhM,KAAKhC,KAAOA,EACZ,IAAIiK,EAAQzG,MAAMwK,GAClBhM,KAAKiM,MAAQhE,EAAMgE,QAER5M,UAAYlB,OAAOY,OAAOyC,MAAMnC,WAC7CyM,EAAazM,UAAU6M,YAAcJ,EAGhC,SAAShM,EAAM2K,EAAO0B,GAC3B,OAAO,IAAI9L,SAAQ,SAASC,EAASC,GACnC,IAAI6L,EAAU,IAAI5B,EAAQC,EAAO0B,GAEjC,GAAIC,EAAQvB,QAAUuB,EAAQvB,OAAOwB,QACnC,OAAO9L,EAAO,IAAIuL,EAAa,UAAW,eAG5C,IAAIQ,EAAM,IAAIC,eAEd,SAASC,IACPF,EAAIG,QAGNH,EAAIvE,OAAS,WACX,IAxFgB2E,EAChBtL,EAuFIe,EAAU,CACZqJ,OAAQc,EAAId,OACZ/J,WAAY6K,EAAI7K,WAChBL,SA3FcsL,EA2FQJ,EAAIK,yBAA2B,GA1FvDvL,EAAU,IAAIiG,EAGQqF,EAAWtB,QAAQ,eAAgB,KACzCF,MAAM,SAAS5D,SAAQ,SAASsF,GAClD,IAAIC,EAAQD,EAAK1B,MAAM,KACnBlM,EAAM6N,EAAM1F,QAAQ8D,OACxB,GAAIjM,EAAK,CACP,IAAIN,EAAQmO,EAAM9H,KAAK,KAAKkG,OAC5B7J,EAAQmG,OAAOvI,EAAKN,OAGjB0C,IAgFHe,EAAQjB,IAAM,gBAAiBoL,EAAMA,EAAIQ,YAAc3K,EAAQf,QAAQ9C,IAAI,iBAC3E,IAAIqJ,EAAO,aAAc2E,EAAMA,EAAInL,SAAWmL,EAAIS,aAClDzM,EAAQ,IAAIgL,EAAS3D,EAAMxF,KAG7BmK,EAAItE,QAAU,WACZzH,EAAO,IAAIuG,UAAU,4BAGvBwF,EAAIU,UAAY,WACdzM,EAAO,IAAIuG,UAAU,4BAGvBwF,EAAIW,QAAU,WACZ1M,EAAO,IAAIuL,EAAa,UAAW,gBAGrCQ,EAAIY,KAAKd,EAAQ1B,OAAQ0B,EAAQlL,KAAK,GAEV,YAAxBkL,EAAQxB,YACV0B,EAAIa,iBAAkB,EACW,SAAxBf,EAAQxB,cACjB0B,EAAIa,iBAAkB,GAGpB,iBAAkBb,GAAOlG,IAC3BkG,EAAIc,aAAe,QAGrBhB,EAAQhL,QAAQkG,SAAQ,SAAS5I,EAAOV,GACtCsO,EAAIe,iBAAiBrP,EAAMU,MAGzB0N,EAAQvB,SACVuB,EAAQvB,OAAOyC,iBAAiB,QAASd,GAEzCF,EAAIiB,mBAAqB,WAEA,IAAnBjB,EAAIkB,YACNpB,EAAQvB,OAAO4C,oBAAoB,QAASjB,KAKlDF,EAAIoB,UAAkC,IAAtBtB,EAAQpD,UAA4B,KAAOoD,EAAQpD,cAIvElJ,EAAM6N,UAAW,EAEZ9N,KAAKC,QACRD,KAAKC,MAAQA,EACbD,KAAKwH,QAAUA,EACfxH,KAAK2K,QAAUA,EACf3K,KAAKyL,SAAWA,I,6BC9flBnN,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,IAHtD,SAAkBb,GACd,IAAK,IAAI0B,KAAK1B,EAAQN,EAAQ+B,eAAeC,KAAIhC,EAAQgC,GAAK1B,EAAE0B,IAGpEG,CAAS,EAAQ,M,6BCqGjB,SAASkO,EAAkBC,GAGvB,MAAMC,EAAiB,GACvB,IAAIrQ,EAAI,EACR,KAAOA,EAAIoQ,EAAKhL,QAEZ,OAAQgL,EAAKpQ,IACT,IAAK,IACD,GAAoB,MAAhBoQ,EAAKpQ,EAAI,GACT,GAAoB,MAAhBoQ,EAAKpQ,EAAI,GAAY,CAErB,IAAKsQ,EAA2CF,EAAKpQ,EAAI,IAAK,CAC1DqQ,EAAe1D,KAAK,IACpB3M,IACA,MAIJqQ,EAAeE,MAEVH,EAAKpQ,EAAI,IACVqQ,EAAe1D,KAAK,IAExB3M,GAAK,MAEJ,CAED,IAAKsQ,EAA2CF,EAAKpQ,EAAI,IAAK,CAC1DqQ,EAAe1D,KAAK,IACpB3M,IACA,MAGCoQ,EAAKpQ,EAAI,IACVqQ,EAAe1D,KAAK,IAIxB3M,GAAK,OAKTqQ,EAAe1D,KAAK,IACpB3M,IAEJ,MACJ,IAAK,IACL,IAAK,IAEIqQ,EAAejL,QAChBiL,EAAe1D,KAAK,IAExB0D,EAAeA,EAAejL,OAAS,GAAGuH,KAAKyD,EAAK7K,OAAOvF,IAE3DA,EAAIoQ,EAAKhL,OACT,MACJ,QAESiL,EAAejL,QAChBiL,EAAe1D,KAAK,IAExB0D,EAAeA,EAAejL,OAAS,GAAGuH,KAAKyD,EAAKpQ,IACpDA,IAIZ,MAAO,IAAMqQ,EAAevI,IAAKsD,GAAWA,EAAO9D,KAAK,KAAKA,KAAK,KAStE,SAASkJ,EAAwBlM,EAAKmM,GAElC,IAAIC,EAAeD,EAAgB,EAC/BA,GAAiB,EACc,MAA3BnM,EAAImM,EAAgB,IAAyC,MAA3BnM,EAAImM,EAAgB,KACtDC,EAAeD,EAAgB,GAIpB,MAAXnM,EAAI,IAAyB,MAAXA,EAAI,KACtBoM,EAAe,GAIvB,MAAMC,EAAgBrM,EAAIW,QAAQ,IAAKyL,GACvC,OAAIC,EAAgB,EACTrM,EAEEA,EAAIiB,OAAO,EAAGoL,GAGbR,EAFD7L,EAAIiB,OAAOoL,IAK5B,SAASL,EAA2CM,GAChD,OAAQA,GAA2B,MAAdA,GAAmC,MAAdA,GAAmC,MAAdA,EA/MnElQ,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,IAkGtDnB,EAAQ+C,QAzFR,SAAiBgO,EAAaC,GAE1B,MAAMC,GADND,EAAUA,GAAW,IACW7L,QAAQ,KAMxC,GAJI8L,EAAkB,IAClBD,EAAUA,EAAQvL,OAAO,EAAGwL,KAG3BF,EAAYzL,OACb,OAAO0L,EAGX,GAAID,EAAY9K,WAAW,KAAM,CAC7B,MAAMiL,EAAeF,EAAQ7L,QAAQ,KAIrC,OAHI+L,EAAe,IACfF,EAAUA,EAAQvL,OAAO,EAAGyL,IAEzBF,EAAUD,EAGrB,GAAIA,EAAY9K,WAAW,KACvB,OAAO+K,EAAUD,EAGrB,IAAKC,EAAQ1L,OACT,OAAOoL,EAAwBK,EAAaA,EAAY5L,QAAQ,MAGpE,MAAMgM,EAAgBJ,EAAY5L,QAAQ,KAC1C,GAAIgM,GAAiB,EACjB,OAAOT,EAAwBK,EAAaI,GAGhD,MAAMC,EAAeJ,EAAQ7L,QAAQ,KACrC,GAAIiM,EAAe,EACf,MAAM,IAAInN,MAAM,0BAA0B+M,iBAAuBD,MAErE,MAAMM,EAAgBL,EAAQvL,OAAO,EAAG2L,EAAe,GAEvD,GAAkC,IAA9BL,EAAY5L,QAAQ,MACpB,OAAOkM,EAAgBX,EAAwBK,EAAaI,GAGhE,IAAIG,EACJ,GAAIN,EAAQ7L,QAAQ,KAAMiM,KAAkBA,EAAe,GAGvD,GADAE,EAAyBN,EAAQ7L,QAAQ,IAAKiM,EAAe,GACzDE,EAAyB,EAGzB,OAAIN,EAAQ1L,OAAS8L,EAAe,EACzBJ,EAAU,IAAMN,EAAwBK,EAAaI,GAGrDE,EAAgBX,EAAwBK,EAAaI,QAOpE,GADAG,EAAyBN,EAAQ7L,QAAQ,IAAKiM,EAAe,GACzDE,EAAyB,EAGzB,OAAOD,EAAgBX,EAAwBK,EAAaI,GAIpE,GAAiC,IAA7BJ,EAAY5L,QAAQ,KACpB,OAAO6L,EAAQvL,OAAO,EAAG6L,GAA0BjB,EAAkBU,GAEzE,IAAIQ,EAAcP,EAAQvL,OAAO6L,GACjC,MAAME,EAAsBD,EAAYE,YAAY,KAepD,OAbID,GAAuB,GAAKA,EAAsBD,EAAYjM,OAAS,IACvEiM,EAAcA,EAAY9L,OAAO,EAAG+L,EAAsB,GAGnC,MAAnBT,EAAY,IAAiC,MAAnBA,EAAY,IAAiC,MAAnBA,EAAY,IAAcA,EAAY,KAC1FA,EAAcA,EAAYtL,OAAO,KAMzCsL,EAAcV,EAFdU,EAAcQ,EAAcR,GAIrBC,EAAQvL,OAAO,EAAG6L,GAA0BP,GA+EvD/Q,EAAQqQ,kBAAoBA,EA8B5BrQ,EAAQ0Q,wBAA0BA,G,gBC9MlC,IAAIgB,EAAY,EAAQ,IACpBvN,EAAe,EAAQ,GACvBwN,EAAU,EAAQ,IAClBpN,EAAY,EAAQ,GACpBqN,EAAO,EAAQ,IACfC,EAAW,EAAQ,IAEvB,SAAS3P,KAETA,EAAY4P,UAAY,SAAU3Q,GAChC,OAAO,IAAIoD,EAAUpD,IAGvBe,EAAY6P,UAAY,SAAU5Q,GAChC,OAAO,IAAIuQ,EAAUvQ,IAGvBe,EAAY8P,QAAU,SAAU7Q,EAAO8Q,GACrC,MAAkC,iBAAvBA,GACgC,IAArCA,EAAmB9M,QAAQ,KACtB,IAAIwM,EAAQxQ,EAAO8Q,GAGrB,IAAIN,EAAQxQ,EAAO,KAAMe,EAAY4P,UAAUG,IAGjD,IAAIN,EAAQxQ,EAAO,KAAM8Q,IAGlC/P,EAAYgQ,aAAe,WACzB,OAAOhQ,EAAYiQ,sBAGrBjQ,EAAYkQ,SAAW,SAAUjR,GAC/B,OAAO,IAAI0Q,EAAS1Q,IAGtBe,EAAYmQ,OAAS,SAAUC,EAASC,EAAW3Q,GACjD,OAAOM,EAAYsQ,KAAKF,EAASC,EAAW3Q,IAG9CM,EAAYsQ,KAAO,SAAUF,EAASC,EAAW3Q,EAAQ6Q,GACvD,OAAO,IAAIb,EAAKU,EAASC,EAAW3Q,EAAQ6Q,GAASvQ,EAAYiQ,uBAGnEjQ,EAAYiQ,qBAAuB,IAAIhO,EAEvClE,EAAOD,QAAUkC,G,cC/CjB,SAASwP,EAAW/L,GAClBlD,KAAKtB,MAAQwE,GAAO,OAAS+L,EAAUgB,OAGzChB,EAAU5P,UAAUsC,OAAS,SAAUC,GACrC,QAASA,GAASA,EAAMC,WAAa7B,KAAK6B,UAAYD,EAAMlD,QAAUsB,KAAKtB,OAG7EuQ,EAAU5P,UAAUwC,SAAW,YAE/BoN,EAAUgB,OAAS,EAEnBzS,EAAOD,QAAU0R,G,gBCZjB,IAAInN,EAAY,EAAQ,GAExB,SAASoN,EAASxQ,EAAOwR,EAAUC,GACjCnQ,KAAKtB,MAAQA,EACbsB,KAAKmQ,SAAWjB,EAAQkB,eACxBpQ,KAAKkQ,SAAW,GAEZA,GACFlQ,KAAKkQ,SAAWA,EAChBlQ,KAAKmQ,SAAWjB,EAAQmB,oBACfF,IACTnQ,KAAKmQ,SAAWA,GAIpBjB,EAAQ7P,UAAUsC,OAAS,SAAUC,GACnC,QAASA,GAASA,EAAMC,WAAa7B,KAAK6B,UAAYD,EAAMlD,QAAUsB,KAAKtB,OACzEkD,EAAMsO,WAAalQ,KAAKkQ,UAAYtO,EAAMuO,SAASxO,OAAO3B,KAAKmQ,WAGnEjB,EAAQ7P,UAAUwC,SAAW,UAC7BqN,EAAQmB,mBAAqB,IAAIvO,EAAU,yDAC3CoN,EAAQkB,eAAiB,IAAItO,EAAU,2CAEvCtE,EAAOD,QAAU2R,G,gBCxBjB,IAAIxN,EAAe,EAAQ,GAE3B,SAASyN,EAAMU,EAASC,EAAW3Q,EAAQ6Q,GACzChQ,KAAK6P,QAAUA,EACf7P,KAAK8P,UAAYA,EACjB9P,KAAKb,OAASA,EAGZa,KAAKgQ,MADHA,GAGW,IAAItO,EAIrByN,EAAK9P,UAAUsC,OAAS,SAAUC,GAChC,QAASA,GAASA,EAAMiO,QAAQlO,OAAO3B,KAAK6P,UAAYjO,EAAMkO,UAAUnO,OAAO3B,KAAK8P,YAClFlO,EAAMzC,OAAOwC,OAAO3B,KAAKb,SAAWyC,EAAMoO,MAAMrO,OAAO3B,KAAKgQ,QAGhExS,EAAOD,QAAU4R,G,cCnBjB,SAASC,EAAUpR,GACjBgC,KAAKtB,MAAQV,EAGfoR,EAAS/P,UAAUsC,OAAS,SAAUC,GACpC,QAASA,GAASA,EAAMC,WAAa7B,KAAK6B,UAAYD,EAAMlD,QAAUsB,KAAKtB,OAG7E0Q,EAAS/P,UAAUwC,SAAW,WAE9BrE,EAAOD,QAAU6R,G,oCCVjB,MAAM,EAAO,GAKN,SAASkB,EAAaC,GAE3B,OADiBA,EAAS/R,OAAOgS,iBACjB9P,OAAOK,KAAK0P,GAAQA,EAAK/R,OCC5B,MAAMgS,EACnB,YAAYvO,KAAYwO,GACtB3Q,KAAK4Q,SAAWzO,EAAQ0O,MACxB7Q,KAAK8Q,YAAc3O,EAAQ4O,SAC3B/Q,KAAKgR,gBAAkBL,EAGzB,eAAeA,GACb,OAAO,IAAID,EAAY,CACrBG,OAAO,MACHF,GAGR,uBAAuBA,GACrB,OAAO,IAAID,EAAY,CACrBG,OAAO,EACPE,UAAU,MACNJ,GAGR,gBAAgBA,GACd,OAAO,IAAID,EAAY,CACrBG,OAAO,MACHF,GAGR,wBAAwBA,GACtB,OAAO,IAAID,EAAY,CACrBG,OAAO,EACPE,UAAU,MACNJ,GAIR,OAAOM,GACL,OAAQjR,KAAK8Q,YAAgD,IAAM9Q,KAAKkR,iBAAiBD,GAA9DjR,KAAKkR,iBAAiBD,GAInD,iBAAiBE,GACf,OAAQnR,KAAK4Q,SAA6C5Q,KAAKoR,sBAAsBD,GAA7DnR,KAAKqR,qBAAqBF,GAIpD,qBAAqBA,GACnB,IAAK,MAAM/R,KAAYY,KAAKgR,gBAAiBG,EAAOA,GAAQA,EAAK/R,GAEjE,OAAO+R,EAIT,4BAA4BA,GAC1B,IAAK,MAAM/R,KAAYY,KAAKgR,gBAAiBG,EAAOA,SAAeA,EAAK/R,GAExE,OAAO+R,G,WCzDJ,SAASG,EAAaC,GAC3B,MAAO,CACLxQ,KAAMyQ,EAAQD,IAOX,SAASC,EAAQD,GACtB,MAAO,CAACE,EAAYC,IAAeH,IAAgBxQ,KAAK0Q,EAAYC,GAM/D,SAASC,EAAkBpB,GAKhC,MAFwB,mBAAbA,IAAyBA,EA0B/B,SAAyBA,GAC9B,MAAMqB,EAAQ,GACd,IAAI1K,EAAWqJ,EAAS/R,OAAOgS,iBAC/B,MAAO,CACL,CAAChS,OAAOgS,iBACN,IAAI/S,EAAI,EACR,MAAO,CACL,aAEE,GAAIA,EAAImU,EAAM/O,OAAQ,OAAO+O,EAAMnU,KAEnC,IAAKyJ,EAAU,MAAO,CACpBpG,MAAM,GAGR,MAAM2P,EAAOmB,EAAMnU,KAAOyJ,EAASxG,OAEnC,aADW+P,GAAM3P,OAAMoG,EAAW,MAC3BuJ,MA3CgCoB,CAAgBtB,MAExD,CACL,CAAC/R,OAAOgS,eAAc,IACbD,EAAS/R,OAAOgS,iBAGzB,WACE,OAAOgB,EAAQ,IAAMlB,EAAatQ,QAGpC,MAAM0R,GACJ,OAAO1R,KAAKe,KAAK,KAAM2Q,IAGzB,QAAQvH,GACN,OAAOnK,KAAKe,OAAO+Q,QAAQ3H,KC1BlB,MAAM,EACnB,YAAY4H,EAAcC,GACxBhS,KAAKiS,cAAgBF,EACrB/R,KAAKkS,eAAiBF,EAGxB,OAAOf,EAAUpD,GACf,MAAO,IAAIsE,KAET,IAAKnS,KAAKkS,iBAAmBC,EAAKtP,OAAQ,MAAM,IAAIrB,MAAM,eAAe4Q,OAAOnB,EAAU,0CAE1F,MAAMoB,EAAsBf,EAAa,IAAMtR,KAAKsS,0BAA0BrB,EAAUpD,EAAMsE,IAC9F,OAAOlB,EAASsB,WAAW,CACzBF,yBAKN,gCAAgCpB,EAAUpD,EAAMsE,GAE9C,MAAMK,QAAmB3E,EAAK4E,eAC9B,IAAK7O,MAAMC,QAAQ2O,GAAa,MAAM,IAAIhR,MAAM,GAAG4Q,OAAOnB,EAAU,oCACpE,GAAIuB,EAAW3P,OAAS,EAAG,MAAM,IAAIrB,MAAM,GAAG4Q,OAAOnB,EAAU,uDAE/D,MAAMyB,QAAgB1S,KAAK2S,eAAe1B,EAAUpD,EAAMsE,GAEpDJ,EAAe/R,KAAKiS,cAC1B,IAAKS,EAAS,MAAO,CAAC,CACpBX,eACAS,eAGF,GAAuB,IAAnBE,EAAQ7P,OAAc,MAAO,GAEjC,MAAM,UACJiN,GACE0C,EAAWxE,MACf,IAAK8B,EAAW,MAAM,IAAItO,MAAM,yBAAyB4Q,OAAOnB,IAChE,MAAO,CAAC,CACNc,eACAS,aACA1C,YACA4C,YAIJ,qBAAqBzB,EAAUpD,EAAMsE,GAEnC,GAAoB,IAAhBA,EAAKtP,OAAc,OAAO,KAE9B,MAAM6P,EAAU,GAEhB,IAAK,MAAME,KAAOT,EAEhB,GAAIS,GAAOA,EAAIpU,OAAOgS,eACpB,UAAW,MAAMC,KAAQmC,EAAKF,EAAQtI,KAAKpK,KAAK6S,cAAc5B,EAAUpD,EAAM4C,SAG9EiC,EAAQtI,KAAKpK,KAAK6S,cAAc5B,EAAUpD,QAAa+E,IAI3D,OAAOF,EAGT,cAAczB,EAAUpD,EAAM+E,GAC5B,GAAmB,iBAARA,EAAkB,OAAO,kBAAQA,GAC5C,GAAIA,GAAOA,EAAI/Q,SAAU,OAAO+Q,EAChC,MAAM,IAAIpR,MAAM,mBAAmB4Q,OAAOQ,KC7E/B,MAAM,UAA8B,EACjD,cACEE,MAAM,UAAU,ICPpB,MAAMC,EAAW,qBACXC,EAAa,WAiHnB,SAASC,EAASxQ,GAChB,MAAM,SACJZ,EAAQ,MACRnD,GACE+D,EAEJ,OAAQZ,GACN,IAAK,YACH,OAAOnD,EAET,IAAK,UACH,MAAM,SACJwR,EAAQ,SACRC,GACE1N,EACJ,MAAO,GAAG2P,OAAOvQ,EAAU,KAAKuQ,OAAOlC,EAAU,KAAKkC,OAAOjC,EAASzR,MAAO,KAAK0T,OAAO1T,GAE3F,QACE,MAAO,GAAG0T,OAAOvQ,EAAU,KAAKuQ,OAAO1T,I,WC3H9B,MAAMwU,EACnB,YAAYC,EAAQ,OAClBnT,KAAKmT,MAAQA,EAGf,OAAOlC,EAAUmC,GACf,MAAO,IAAIC,KAET,GAA0B,IAAtBA,EAAWxQ,OAAc,OAAOuQ,EAEpC,MAAOhU,KAAakU,GAAQD,GACtB,UACJvD,GACEsD,EAAUhU,GAERmU,EAAY,CAChBnU,WACA0Q,YACA0D,KAAMxT,KAAKmT,OAEPM,EAAYxC,EAASsB,WAAWgB,GACtC,OAAuB,IAAhBD,EAAKzQ,OAAe4Q,EAAYA,EAAUD,QAAQF,KC7B/D,MAAMI,EAAe,4CACfC,EAAa,+DACbC,EAAgB,CACpB,KAAM,OACN,IAAK,MACL,KAAM,MACN,KAAM,MACN,KAAM,MACN,KAAM,MACN,KAAM,OASO,MAAMC,EACnB,aAAa5C,EAAUpD,GAErB,MAAMwE,QAA4BxE,EAAKwE,oBACvC,GAAIzO,MAAMC,QAAQwO,IAAwBA,EAAoBxP,OAAQ,OAAOwP,EAAoB9M,IAAI5E,GAAKX,KAAK8T,0BAA0BnT,IAAIoE,KAAK,SAElJ,MAAM0N,QAAuB5E,EAAK4E,eAClC,IAAK7O,MAAMC,QAAQ4O,GAAiB,MAAM,IAAIjR,MAAM,GAAG4Q,OAAOnB,EAAU,oCACxE,OAAOjR,KAAK+T,sBAAsB9C,EAAUpD,EAAM4E,GAGpD,sBAAsBxB,EAAUpD,EAAM4E,GACpC,GAAIA,EAAe5P,OAAS,IAAMoO,EAAS+C,YAAa,MAAM,IAAIxS,MAAM,GAAG4Q,OAAOnB,EAAU,uDAE5F,IAAIgD,EAAW,WACXC,EAAQ,GACRC,EAAU,GAEV1B,EAAe5P,OAAS,IAC1BoR,EAAWjU,KAAKoU,UAAUnD,EAAS7R,YAEjC6U,WACAC,QACAC,WACEnU,KAAKqU,2BAA2B5B,EAAgBwB,KAGlDhD,EAAS+C,aAAaG,EAAQ/J,KAAK6G,EAAS+C,YAAYC,IAE5D,MAAMK,EAAWrD,EAASqD,SAAW,YAAc,GAC7CC,EAAS,UAAUnC,OAAOkC,GAAUlC,OAAOnB,EAASsD,OAAStD,EAASsD,OAASN,GAC/EO,EAAQ,eAAepC,OAAO+B,EAAQpP,KAAK,QAAS,OACpD0P,EAAeP,EAAM3O,IAAI,EAC7B4N,QACAxD,cACI,GAAGyC,OAAOe,EAAO,KAAKf,OAAOzC,EAAU,MACvC+E,EAAkC,IAAxBD,EAAa5R,OAAe,GAAK,cAAcuP,OAAOqC,EAAa1P,KAAK,MACxF,MAAO,GAAGqN,OAAOmC,GAAQnC,OAAOoC,GAAOpC,OAAOsC,GAGhD,2BAA0B,aACxB3C,EAAY,WACZS,EAAU,UACV1C,EAAS,QACT4C,IAGA,MAAMiC,EAAQ,GACd,IAAI9E,EAAS2E,EAEb,GAA0B,IAAtBhC,EAAW3P,OACbgN,EAAU7P,KAAK4U,aAAapC,EAAW,GAAG3C,SAC1C2E,EAAQ,OAEL,CACD,MAAMK,EAAgBrC,EAAWA,EAAW3P,OAAS,GAAGiN,UACxDD,EAAU7P,KAAKoU,UAAUS,EAAcnW,MAAOiW,KAE5CV,SAAUpE,EACVsE,QAASK,GACPxU,KAAKqU,2BAA2B7B,EAAY3C,EAAS8E,IAI7D,MAAMG,EAAapC,GAAWA,EAAQnN,IAAIrH,GAAK8B,KAAK4U,aAAa1W,IAAI6G,KAAK,MACpEgQ,EAAkBD,EAAa,GAAG1C,OAAOvC,EAAS,KAAKuC,OAAOpS,KAAK4U,aAAa9E,GAAY,KAAKsC,OAAO0C,EAAY,KAC1HN,EAAMA,EAAM3R,OAAS,GACrB,OAAwB,IAAjB2R,EAAM3R,OACb,GAAGuP,OAAOL,EAAc,eAAeK,OAAO2C,EAAiB,OAC/D,GAAG3C,OAAOL,EAAc,UAAUK,OAAO2C,EAAiB,mBAAmB3C,OAAOoC,EAAMzP,KAAK,QAAS,OAG1G,4BAA4BiQ,KAASvC,GAAiBwC,EAASN,EAAQ,IACrE,MAAMO,EAAYzC,EAAe5P,OAAS,EAC1C,IAAI1D,EAASa,KAAK4U,aAmGtB,SAAmBnS,GACjB,GAAsB,cAAlBA,EAAKZ,SAA0B,OAAOY,EACrCA,EAAK0S,aAAY1S,EAAK0S,WAAa,oBAAU,gBAAgB/C,OAAOgD,OACzE,OAAO3S,EAAK0S,WAtGqBE,CAAUL,EAAKnF,UAC1CoE,EAAW9U,EACf,MAAM+U,EAAQ,GACRC,EAAU1B,EAAelN,IAAI,CAAC+P,EAASC,KAE3C,MAAM1F,EAAU1Q,GACV,UACJ2Q,GACEwF,EACJnW,EAASoW,EAAQL,EAAYlV,KAAKoU,UAAU,IAAIhC,OAAOmD,GAAQZ,GAASM,EACxE,MAAMpU,EAAS,GAAGuR,OAAOvC,EAAS,KAAKuC,OAAOpS,KAAK4U,aAAa9E,GAAY,KAAKsC,OAAOjT,EAAQ,KAehG,OAbKmW,EAAQ9B,MAKTU,EAAM9J,KAAK,CACTuF,SAAUxQ,EACVgU,MAAOmC,EAAQ9B,OAGjBrU,EAAS8U,GATXA,EAAW9U,EAYN0B,IAET,MAAO,CACLoT,WACAC,QACAC,WAKJ,UAAUqB,EAAa,GAAIb,GACzB,IAAIc,EAAU,EACVC,EAAQ,IAAItD,OAAOoD,EAAWG,MAAM,eAAe,IAAM,UAE7D,GAAIhB,EAAO,CACT,KAAOA,EAAMe,IAAQA,EAAQ,IAAItD,OAAOoD,EAAY,KAAKpD,OAAOqD,KAEhEd,EAAMe,IAAS,EAGjB,OAAOA,EAIT,aAAajT,GAEX,IAAI,MACF/D,GACE+D,EAGJ,OAFIiR,EAAa3P,KAAKrF,KAAQA,EAAQA,EAAM0M,QAAQuI,EAAYiC,IAExDnT,EAAKZ,UACX,IAAK,YACH,MAAO,IAAIuQ,OAAO1T,EAAO,KAE3B,IAAK,YACH,MAAO,KAAK0T,OAAO1T,GAErB,IAAK,UAEH,IAAIgF,EAAS,GAEb,OADIjB,EAAKyN,SAAUxM,EAAS,IAAI0O,OAAO3P,EAAKyN,UAA2C,4CAAxBzN,EAAK0N,SAASzR,QAAqDgF,EAAS,MAAM0O,OAAO3P,EAAK0N,SAASzR,MAAO,MACtK,IAAK0T,OAAO1T,EAAO,KAAM0T,OAAO1O,GAEzC,QACE,MAAM,IAAIlC,MAAM,oCAAoC4Q,OAAO3P,EAAKZ,aAOxE,SAAS+T,EAAgBvH,GAEvB,IAAIxN,EAAS+S,EAAcvF,GAc3B,YAZejH,IAAXvG,IAEuB,IAArBwN,EAAUxL,QACZhC,EAASwN,EAAUwH,WAAW,GAAGlP,SAAS,IAC1C9F,EAAS,UAAUmC,OAAO,EAAG,EAAInC,EAAOgC,QAAUhC,IAGhDA,GAA+C,MAApCwN,EAAUwH,WAAW,GAAK,OAAkBxH,EAAUwH,WAAW,GAAK,MAAQlP,SAAS,IAClG9F,EAAS,cAAcmC,OAAO,EAAG,GAAKnC,EAAOgC,QAAUhC,IAItDA,EAIT,IAAIuU,EAAW,ECtKA,OAEbvW,WAAY,OAEZkC,KAAM,IChBO,MACb,QAAO,QACL8O,GACCuD,GAED,OAAOvD,EAGPA,EAAQ9O,MAAQyQ,EAAQ,IAAM4B,EAAUvD,SACxC2B,EAAQ,IAAMlB,EAAa8C,EAAU0C,YDQvC,CAACtX,OAAOgS,eAAgB,IEnBX,MACb,QAAO,QACLX,GACCuD,GAGD,OAAOvD,EAAU,KAAM7I,OVHCyJ,EUGW2C,EAAUvD,QVFxC,CACL,aACE,GAAIY,IAAS,EAAM,CACjB,MAAM/R,QAAc+R,EAEpB,OADAA,EAAO,EACA,CACL/R,SAIJ,MAAO,CACLoC,MAAM,KAZP,IAAqB2P,GUGgC,IAAM2C,EAAU0C,QAAQtX,OAAOgS,mBFezFX,QAAS,IGxBI,MACb,OAAOoB,GAEL,IAAI,QACFpB,EAAO,OACPkG,GACE9E,EAEJ,MAAQpB,GAAWkG,KACjBlG,UACAkG,UACEA,GAIJ,OAAQlG,EAAsBxP,QAAQC,QAAQuP,GAAS9O,KAAKrC,GAASuS,EAASsB,WAAW,CACvF1C,QAASnR,GACR,YAFe0I,IHUpB0I,UAAW,II1BE,MACb,OAAOmB,GACL,MAAM,UACJnB,GACEmB,EACJ,OAAQnB,EAAwBzP,QAAQC,QAAQwP,GAAW/O,KAAK8O,GAAWoB,EAASsB,WAAW,CAC7F1C,WACC,YAFiBzI,IJsBtBiM,WAAY,IK5BC,MACb,OAAOpC,EAAUpD,GACf,OAAO8D,EAAkB3R,KAAKgW,QAAQ/E,EAAUpD,IAGlD,cAAeoD,EAAUpD,GACvB,MAAMlL,QAAiBsO,EAASgF,SAASC,eAAkB,GAE3D,UAAW,MAAMpG,KAAajC,EAAKsI,iBAAkB,gBAAcC,WAAW,GAAGhE,aAActC,GAAanN,GAAS,KLqBvHwT,WAAY,IM/BC,MACb,OAAOlF,GACL,OAAOA,EAASsB,WAAW,CACzB+B,UAAU,EACVC,OAAQ,aACRP,YAAaC,GAAY,GAAG7B,OAAO6B,EAAU,wBAC7C7U,SAAU6R,EAAS7R,aN0BvBqT,eAAgB,IOhCH,MACb,aAAaxB,GACX,MAAMoF,EAAW,GACjB,IAAIC,EAAUrF,EAEd,KAAOqF,EAAQP,QAETO,EAAQxG,WACVuG,EAASE,QAAQ,CACfzG,gBAAiBwG,EAAQxG,UACzB0D,KAAM8C,EAAQ9C,OAKlB8C,EAAUA,EAAQP,OAIpB,IAAKO,EAAQzG,QAAS,MAAM,IAAIrO,MAAM,4BAA4B4Q,OAAOkE,IACzE,MAAMzG,QAAgByG,EAAQzG,QAI9B,OAHAwG,EAASE,QAAQ,CACf1G,YAEKwG,IPSTG,OAAQ,IAAI3C,EACZ4C,SAAU,IQlCG,MACb,OAAOxF,GACL,OAAOA,EAASsB,WAAW,CACzB+B,UAAU,EACVC,OAAQ,WACRP,YAAa,IAAM,+BACnB5U,SAAU6R,EAAS7R,aR6BvB0W,QAAS,IS9BI,MACb,aAAc7E,EAAUpD,GAEtB,MAAM6I,QAAqBzF,EAASyF,aAEpC,GAAIA,EAAc,CAChB,IAAK,MAAM7V,KAAU6V,QAAoB7V,EAEzC,OAIF,MAAM,YACJ8V,GACE1F,EAASgF,SACb,IAAKU,EAAa,MAAM,IAAInV,MAAM,GAAG4Q,OAAOnB,EAAU,gCACtD,MAAM2F,QAAc/I,EAAK2I,OACzB,IAAKI,EAAO,MAAM,IAAIpV,MAAM,GAAG4Q,OAAOnB,EAAU,4BAEhD,UAAW,MAAM4F,KAAYF,EAAYG,QAAQF,SAAc5W,KAAK+W,YAAYF,EAAU5F,GAO5F,YAAY+F,EAAS/F,GAEnB,GAAqB,IAAjB+F,EAAQC,KAAY,MAAM,IAAIzV,MAAM,8CACxC,MAAMqO,EAAUmH,EAAQ3M,SAAS3J,OAAOhC,MAExC,OAAOuS,EAASsB,WAAW,CACzB1C,WACC,QTFL2D,KAAM,IAAIN,EAAY,OACtBgE,SAAU,IAAIhE,EAAY,QAC1BiE,QAAS,IH3BI,MAIb,OAAOlG,EAAUmC,GACf,OAAOvC,SAAUwC,KACf,GAAIA,EAAWxQ,OAAS,EAAG,CAEzB,MAAMsT,QAAmB9V,QAAQiF,IAAI+N,EAAW9N,IAAIsL,gBAAkBuC,EAAU7T,GAAGuQ,WAAWpR,QAE9FuS,EAASyF,mBAAqB1W,KAAKoX,mBAAmBjB,EAAYlF,EAAUmC,GAG9E,OAAOA,GASX,yBAAyB+C,EAAYlF,EAAUpD,GAE7C,MAAM,MACJ+I,EAAK,KACLS,EAAI,UACJC,SACQtX,KAAKuX,YAAYpB,EAAYtI,IAErCoI,UAAU,YACRU,IAEA1F,EACE4F,EAAWF,EAAYG,QAAQF,GAE/BF,EAAe,GACfc,EAAiB,GAEvB,UAAW,MAAMR,KAAWH,EAAU,CAEpC,MAAMhW,EAASmW,EAAQ1Y,IAAIgZ,GACrBG,EAAOxE,EAASpS,GAEtB,KAAM4W,KAAQf,GAAe,CAE3B,MAAMgB,EAAgBF,EAAeC,GAAQ,GAE7C,IAAK,MAAM3H,KAAaqG,EAAYuB,EAAc5H,GAAa,GAG/D,MAAM6H,EAAa,CACjB9H,QAAShP,EACT6W,iBAEFhB,EAAae,GAAQxG,EAASsB,WAAWoF,EAAY,MAIvD,MAAMD,EAAgBF,EAAeC,GAErC,IAAK,IAAIha,EAAI,EAAGA,EAAI4Z,EAAKxU,OAAQpF,IAAK,CACpC,MAAMiB,EAAQsY,EAAQ1Y,IAAI+Y,EAAK5Z,IAE/B,GAAIiB,EAAO,CACT,MAAMkZ,EAAY3G,EAASsB,WAAW,CACpC1C,QAASnR,GACR,MACHgZ,EAAcvB,EAAW1Y,IAAI2M,KAAKwN,KAKxC,OAAOzZ,OAAOkM,OAAOqM,GAOvB,kBAAkBP,EAAYtI,GAE5B,MAAMgK,QAAoBhK,EAAK2I,OACzBsB,EAAgB/E,EAASgF,KAAKF,GACpC,IAAKC,EAAe,MAAM,IAAItW,MAAM,0BAA0B4Q,OAAOyF,IACrE,MAAMP,EAAYQ,EAAc,GAG1BT,EAAOlB,EAAW5Q,IAAI,CAAChG,EAAG9B,IAAM,YAAY2U,OAAO3U,IACnDua,EAAiB7B,EAAW5Q,IAAI,CAACuK,EAAWrS,IAAM,SAAS2U,OAAOkF,EAAW,MAAMlF,OAAOtC,EAAW,MAAMsC,OAAOiF,EAAK5Z,GAAI,QAAQsH,KAAK,iBAE9I,MAAO,CACL6R,MAFYiB,EAAYzM,QAAQ2H,EAAU,QAAQX,OAAOiF,EAAKtS,KAAK,OAAOqG,QAAQ4H,EAAY,iBAAiBZ,OAAO4F,EAAgB,cAGtIX,OACAC,eGjEJjF,oBAAqB,IUpCR,MACb,aAAapB,GACX,MAAMoB,EAAsB,GAE5B,IAAIiE,EAAUrF,EAEd,KAAOqF,GAEDA,EAAQjE,qBAAqBA,EAAoBkE,iBAAkBD,EAAQjE,qBAE/EiE,EAAUA,EAAQP,OAGpB,OAAO1D,IVwBT4F,IAAK,IWvCQ,cAAoC,EACjD,cACEnF,MAAM,UAAU,KXsClBlK,IAAK,IYrCQ,MACb,OAAOqI,EAAUpD,GACf,MAAO,IAAIsE,IAAStE,EAAKqK,SAASD,OAAO9F,KZoC3C/G,QAAS,IatCI,MACb,OAAO6F,EAAUpD,GACf,OAAO,SAAU5D,KAAakO,GAC5B,IAAKlO,IAAakO,EAAUtV,OAAQ,MAAM,IAAIrB,MAAM,0FACpD,OAAOqM,EAAKqK,OAAOjO,GAAUgO,OAAOE,MbmCxCD,OAAQ,IAAI,EAEZrW,SAAUuW,EAAoB,YAC9B1Z,MAAO0Z,EAAoB,SAC3BjI,SAAUiI,EAAoB,YAC9BlI,SAAUkI,EAAoB,YAC9BzW,OAAQ+O,EAAY2H,KAAK,UAAW,UACpC1R,SAAU+J,EAAY4H,aAAa,UAAW,SAC9CC,YAAa7H,EAAY4H,aAAa,UAAW,SAEjDE,QAAS,IcnDI,MACb,OAAOvH,EAAUpD,GACf,OAAOgD,UACL,MAAM5J,EAAQ,GAEd,GAAI4G,GAA8C,mBAA/BA,EAAKrP,OAAOgS,eAA+B,CAEzC,mBAARjL,IAAoBA,EAAMkL,GAAQA,GAE7C,IAAI8E,EAAQ,EAEZ,UAAW,MAAM9E,KAAQ5C,EAAM5G,EAAMmD,WAAY7E,EAAIkL,EAAM8E,MAG7D,OAAOtO,KdsCXwR,UAAWC,EAAQ,CAACC,EAAG9K,IAASA,EAAK2K,QAAQ7Z,GAAKA,EAAEkD,WACpDwI,OAAQqO,EAAQ,CAACC,EAAG9K,IAASA,EAAK2K,QAAQ7Z,GAAKA,EAAED,QACjDka,UAAWF,EAAQ,CAACC,EAAG9K,IAASA,EAAK2K,QAAQ7Z,GAAKA,EAAEwR,WACpD0I,UAAWH,EAAQ,CAACC,EAAG9K,IAASA,EAAK2K,QAAQ7Z,GAAKA,EAAEuR,WAEpD5P,QAAS,Ie5DI,MACb,OAAO2Q,EAAUpD,GAEf,MAAO,CAACiL,EAAa,GAAIC,EAASlL,KAEhC,MAAMmL,EAAeF,EACpB1N,QAAQ,6BAA8B,UACtCA,QAAQ,gBAAiB,KACzBA,QAAQ,oBAAqB,UAExBzD,EAAO,6BAA+ByK,OAAO4G,GACnD,IAAIC,EAEJ,IAEEA,EAAYC,SAAS,SAAUvR,GAC/B,OAAO,QACPqE,IAEA,MAAM,IAAIxK,MAAM,eAAgB4Q,OAAO0G,EAAY,kBAAmB1G,OAAOpG,IAI/E,OAAOiN,EAAUF,OfwCvB,SAASL,EAAQS,GACf,MAAO,CACLA,UAKJ,SAASf,EAAoBhZ,GAC3B,OAAOsZ,EAAQ,CAACzH,EAAUpD,KAGxB,MAAM,QACJgC,GACEoB,EACEmI,EAAevJ,GAAWA,EAAQzQ,GACxC,YAA4B,IAAjBga,EAAqCA,EAEzCvL,EAAK9M,KAAK0B,GAAQA,GAAQA,EAAKrD,MgBnF1C,MAAMia,EAAQlb,OAAOY,OAAO,MAsBb,MAAMua,EACnB,aAAY,SACVC,EAAWF,EAAK,UAChBG,EAAY,IACV,IACFxZ,KAAKyZ,UAAYF,EACjBvZ,KAAK0Z,WAAaF,EAOpB,WAAWvD,EAAW,GAAI9E,QAEX/J,IAAT+J,KAAqBA,EAAM8E,GAAY,CAACA,EAAU,KAEtD,MAAMpI,EAAO,CACXoI,cACG9E,GAECwI,EAAQ9L,EAAK8L,MAAQ,IAAIC,MAAM/L,EAAM7N,MAE3C,IAAK6N,EAAK0E,WAAY,CACpB,MAAMa,EAAYpT,KAElB6N,EAAK0E,WAAa,SAASA,EAAWsH,EAAS9D,EAAS/V,MACtD,OAAOoT,EAAU0G,WAAW7D,EAAU,CACpCF,SACAxD,gBACGsH,KAMT,OAAOF,EAOT,IAAI1I,EAAU7R,GAGZ,MAAMsZ,EAAU1Y,KAAKyZ,UAAUra,GAC/B,GAAIsZ,GAAqC,mBAAnBA,EAAQS,OAAuB,OAAOT,EAAQS,OAAOlI,EAAUA,EAAS0I,OAG9F,IAAK,MAAMI,KAAY/Z,KAAK0Z,WAC1B,GAAIK,EAASC,SAAS5a,GAAW,OAAO2a,EAASzZ,QAAQlB,EAAU6R,EAAUA,EAAS0I,QCjE7E,MAAM,EAInB,eAAeM,GACbja,KAAKka,SAAW7Z,QAAQC,QAAQ,IAChCN,KAAKma,iBAAiBF,GAOxB,SAAS7a,GACP,MAA2B,iBAAbA,EAOhB,QAAQA,EAAU6R,GAChB,MAAMnB,EAAYwB,EAAa,IAAMtR,KAAKoa,eAAehb,IACnDsX,EAAe1W,KAAKqa,gBAAgBpJ,EAAUnB,GACpD,OAAOmB,EAASsB,WAAW,CACzBnT,WACA0Q,YACA4G,iBAQJ,qBAAqBtX,GAInBA,EAAWA,EAASgM,QAAQ,yBAA0B,OAEtD,MAAMzI,QAAgB3C,KAAKka,SACrBI,EAAmB,gBAAcjW,WAAWjF,EAAUuD,GAAS,GACrE,IAAK,gBAAckC,WAAWyV,GAAmB,MAAM,IAAI9Y,MAAM,0CAA0C4Q,OAAOhT,EAAU,eAC5H,OAAO,oBAAUkb,GAOnB,uBAAuBL,SACdja,KAAKka,SAAWla,KAAKka,SAASnZ,KAAKwZ,IAAkB,IAAI,iBAAgBpV,MAAM,CAACoV,KAAmBN,MAO5G,gBAAgBhJ,EAAUnB,GACxB,IAAI,cACF4H,GACEzG,EACJ,OAAOyG,GAAiBpG,EAAaT,UACnC6G,QAAsBA,EACfA,GAAiBA,SAAqB5H,GAAWpR,UCjE/C,MAAM,EACnB,YAAYuX,EAAU9E,GAEpBnR,KAAKwa,UAAYvE,EAAW,IAAKA,GAEjCjW,KAAKya,MAAQtJ,EAAO,IAAKA,GAGzB,MAAMoI,EAAWtD,EAASsD,UAAYmB,EAEtC,IAAK,MAAM1b,KAAOua,EAAUA,EAASva,GAAO2b,EAAUpB,EAASva,IAE/D,IAAK,MAAMA,KAAOb,OAAOyc,sBAAsBrB,GAAWA,EAASva,GAAO2b,EAAUpB,EAASva,IAG7F,MAAMwa,GAAavD,EAASuD,WAAa,IAAIjU,IAAIsV,GAE7C5E,EAAStT,SACX6W,EAAUpP,KAAK,IAAI,EAAe6L,EAAStT,UAC3CsT,EAASC,eAAgB,IAAI,iBAAgB/Q,MAAM8Q,EAAStT,UAE5DsT,EAAStT,QAAUsT,EAASC,cAAgB,GAI9ClW,KAAK8a,WAAa,IAAIxB,EAAU,CAC9BC,WACAC,qBAGKvD,EAASsD,gBACTtD,EAASuD,UAOlB,OAAOvD,EAAW,GAAI9E,GAIpB,OAFKA,KAAOA,EAAM8E,GAAY,CAACA,EAAU,OAElCjW,KAAK8a,WAAWhB,WAAW3b,OAAO2H,OAAO3H,OAAOY,OAAO,MAAOiB,KAAKwa,UAAWvE,GAAW9X,OAAO2H,OAAO3H,OAAOY,OAAO,MAAOiB,KAAKya,MAAOtJ,KAS5I,SAASwJ,EAAUxB,GACxB,MAAgC,mBAAlBA,EAAOA,OAAwBA,EAAS,CACpDA,UAOG,SAAS0B,EAAWva,GACzB,MAAkC,mBAApBA,EAAQA,QAAyBA,EAAU,CACvD0Z,WACA1Z,WAIJ,SAAS0Z,IACP,OAAO,EAtBT,EAAYU,gBAAkBA,E,WClD9B,MAAM,GAAEK,GAAOpY,EAAQ,YASR,MAAMqY,EAGnB9O,aAAY,eAAE+O,EAAiB,sBAAyB,IAAI,KAF5DC,aAAc,EAGZlb,KAAKib,eAAiBA,EAGxB9B,OAAOlI,EAAUpD,GACf,MAAMhO,EAAOG,MACP,KAAEgV,GAASnH,GACToI,UAAU,YAAEU,IAAkB1F,EAGtC,MAAO,CAAC3M,EAAUyW,EAAF,SAAepJ,GAAkBd,kBAE/C,IAAIsK,EACJ,IACEA,QAAanG,EAAKmG,KAEpB,MAAOlT,GACL,GAAIpI,EAAKqb,YACP,MAAMjT,EACR,OAIF,MAAMmT,QAAgBpG,EAAKmG,KAAKE,YAC1BC,EAAW,IAAIC,IAAI1b,EAAKob,eAAgBG,GAAWD,GAAMK,KAGzD1F,EAAU,GACV2F,EAAQpM,oBAAU8L,GACxB7W,EAAO+K,oBAAU/K,GACjB,UAAW,MAAMnF,KAAU0O,EACzB,GAAwB,cAApB1O,EAAO0C,SAA0B,CACnC,MAAM6Z,EAAW,CAAED,QAAOnX,OAAMnF,UAChC,UAAW,MAAM0B,KAAUhB,EAAK8b,cAAcD,EAAUJ,EAAU3E,GAChEb,EAAQ1L,KAAKvJ,GAKnB,IAAK,MAAM4B,WAAc5C,EAAK+b,eAAe9F,EAASwF,EAAU3E,SACxD3B,EAAKvS,EAAK/D,UAItB,qBAAqBoX,GACnB,OAAOA,GC3DJ,MAAM,aAAElB,GAAiBf,EAAcxU,UAEvC,SAASwc,EAAiBC,EAAUC,GACzC,IAAK,MAAM/d,KAAQ+d,EACjBD,EAAWA,EAAS1Q,QAAQ,IAAI4Q,OAAQ,KAAIhe,EAAQ,KAAM4W,EAAamH,EAAM/d,KAC/E,OAAO8d,EAIF,SAASG,KAAUhV,GACxB,MAAO,CACLgQ,KAAMhQ,EAAMpE,OACZwH,OAAQ,KAAM,CACZ3J,KAAM,KAAM,CAAGhC,MAAOuI,EAAME,aCVlC,IAAI+U,EAAmC,oBAAVC,QAAyBA,OAAOD,iBAAmBC,OAAOD,gBAAgBjd,KAAKkd,SAA8B,oBAAZC,UAA8D,mBAA5BA,SAASF,iBAAiCE,SAASF,gBAAgBjd,KAAKmd,UACpOC,EAAQ,IAAI3T,WAAW,IAEZ,SAAS4T,IACtB,IAAKJ,EACH,MAAM,IAAI1a,MAAM,4GAGlB,OAAO0a,EAAgBG,GCPzB,IAFA,IAAIE,EAAY,GAEP,EAAI,EAAG,EAAI,MAAO,EACzBA,EAAU,IAAM,EAAI,KAAO5V,SAAS,IAAI3D,OAAO,GAUlC,MAPf,SAAqBwF,EAAKgU,GACxB,IAAI/e,EAAI+e,GAAU,EACdC,EAAMF,EAEV,MAAO,CAACE,EAAIjU,EAAI/K,MAAOgf,EAAIjU,EAAI/K,MAAOgf,EAAIjU,EAAI/K,MAAOgf,EAAIjU,EAAI/K,MAAO,IAAKgf,EAAIjU,EAAI/K,MAAOgf,EAAIjU,EAAI/K,MAAO,IAAKgf,EAAIjU,EAAI/K,MAAOgf,EAAIjU,EAAI/K,MAAO,IAAKgf,EAAIjU,EAAI/K,MAAOgf,EAAIjU,EAAI/K,MAAO,IAAKgf,EAAIjU,EAAI/K,MAAOgf,EAAIjU,EAAI/K,MAAOgf,EAAIjU,EAAI/K,MAAOgf,EAAIjU,EAAI/K,MAAOgf,EAAIjU,EAAI/K,MAAOgf,EAAIjU,EAAI/K,OAAOsH,KAAK,KCYpQ,MAvBf,SAAY5C,EAASqG,EAAKgU,GACxB,IAAI/e,EAAI+K,GAAOgU,GAAU,EAEH,iBAAXra,IACTqG,EAAkB,WAAZrG,EAAuB,IAAIyB,MAAM,IAAM,KAC7CzB,EAAU,MAIZ,IAAIua,GADJva,EAAUA,GAAW,IACFwa,SAAWxa,EAAQma,KAAOA,KAK7C,GAHAI,EAAK,GAAe,GAAVA,EAAK,GAAY,GAC3BA,EAAK,GAAe,GAAVA,EAAK,GAAY,IAEvBlU,EACF,IAAK,IAAIoU,EAAK,EAAGA,EAAK,KAAMA,EAC1BpU,EAAI/K,EAAImf,GAAMF,EAAKE,GAIvB,OAAOpU,GAAO,EAAYkU,I,MChBtB,IAAEG,GAAQla,EAAQ,Y,MCHlBma,EAAa,CAAC,WAAY,aAAc,WCS/B,MAAMC,EACnB7Q,YAAY8Q,EAAaC,GACvBjd,KAAKkd,OAASF,EACdhd,KAAKmd,QAAUF,EAIjBjD,SAAS5a,GACP,MAA2B,iBAAbA,EAGhBkB,QAAQlB,GAAU,SAAE6W,IAClB,OAAOjW,KAAKod,mBAAmB/N,oBAAUjQ,GAAW6W,GAGtDmH,mBAAmBvN,GAAS,kBAAEwN,IAC5B,MACM1G,EAAc0G,EADLrd,KAAKmd,SAAW9c,QAAQC,QAAQuP,GAASyN,MAAM,IAAM,OAEpE,OAAOtd,KAAKkd,OAAOne,OAAO,CAAE4X,eAAe,CAAE9G,aC5BlC,MAAM0N,EACnBrR,YAAY8Q,GACVhd,KAAKkd,OAASF,EAGhB7D,QAAO,SAAElD,IACP,OAAOgH,GAAU,IAAIO,EAAY,CAC/BjE,SAAU,IAAKmB,GACflB,UAAW,CAAC,IAAIuD,EAAoB/c,KAAKkd,OAAQD,MAChDle,OAAOkX,EAAU,K,oBCLT,MAAMwH,UAAwBV,EAC3C5D,QAAO,SAAElD,IACP,MAAMpG,EAAU7P,KAAK0d,WAAW3c,KAAKsO,aACrC,OAAOrP,KAAKod,mBAAmBvN,EAASoG,GAI1C,iBACE,MAAM0H,QAAgBC,IAAKC,iBAC3B,IAAKF,EACH,MAAM,IAAInc,MAAM,+CAClB,OAAOmc,EAAQG,OCPnB,MAAQ/C,GAAEA,GAAKpY,EAAQ,YACjBob,GAAkB,ICFT,cAA8BC,EAC3C9R,YAAYvJ,GACVmQ,MAAMnQ,GAGN,MAAMsb,EAAiBje,KAAKke,gBAAkB/f,OAAOY,OAAO4D,EAAQ,aAEpExE,OAAOC,eAAe6f,EAAgB,SAAU,CAC9Cvf,MAAO,IAAIub,IAAaja,KAAKma,iBAAiBF,KAGhD9b,OAAOC,eAAe6f,EAAgB,OAAQ,CAC5Cvf,MAAO,CAAC4B,EAASC,IAAWP,KAAKka,SAASnZ,KAAKT,EAASC,KAI5D4Y,SACE,OAAOnZ,KAAKke,kBDf4Bvb,GAGtCwb,GAAkB,IACnBzD,EAGHxC,OAAQ,IERK,cAAyCkG,EACtD,qBAAqBnN,EAAUpD,EAAMsE,GAEnC,MAAMO,QAAgBI,MAAMH,eAAe1B,EAAUpD,EAAMsE,GAGrDkM,EAAW,GACjB,UAAW,MAAM5b,KAAQoL,EACD,cAAlBpL,EAAKZ,UACPwc,EAASjU,KAAK3H,GAIlB,OAAQiQ,EAAqB2L,EAASC,OAAO3d,GAAK+R,EAAQ6L,KAAKrgB,GAAKA,EAAEyD,OAAOhB,KAA3D0d,IFFpBG,aAAc,IGXD,cAAkCxD,EAAgB,mCAC/DE,aAAc,EAGd,oBAAqBQ,EAAUJ,EAAU3E,GACvC,MAAMC,EAAQiF,E,qLAAgCH,GAC9C,UAAW,MAAM1E,KAAWL,EAAYG,QAAQF,EAAO0E,SAC/CtE,EAAQ3M,SAAS3J,OAAOhC,QHKlC+f,MAAO,CAAC9F,EAAG9K,IAASA,EAAK2Q,aAAgBzD,EAAF,QACvC2D,SAAU,CAAC/F,EAAG9K,IAASA,EAAK2Q,aAAgBzD,EAAF,WAC1C4D,QAAS,CAAChG,EAAG9K,IAASA,EAAK2Q,aAAgBzD,EAAF,UAGzC6D,eAAgB,ILZH,cAAoC5D,EAEjD,oBAAqBU,EAAUJ,GAC7B,MAAMpY,EAAKmM,oBAAU,IAAIkM,IAAK,IAAGsD,IAAYvD,GAAUE,MAIjDsD,EAASjD,E,iNAFfH,EAAW,CAAExY,KAAI6b,UADCxP,mBAAQ,IAAIyP,MAAOC,cAAkBpC,EAAF,eACtBnB,SAGzB,CAAExY,KAAI4b,UAId,qBAAqBhJ,EAASwF,EAAU3E,GACtC,MAAMH,EAAU,aAAYV,EAAQvQ,IAAIhH,GAAKA,EAAEugB,QAAQ/Z,KAAK,OAE5D,aADM4R,EAAYuI,cAAc1I,EAAQ8E,GAAU5a,OAC3CoV,EAAQvQ,IAAIhH,GAAKA,EAAE2E,MKF5Bic,KAAM,CAACxG,EAAG9K,IAAS,IAAMA,EAAK+Q,eAAkB7D,EAAF,QAC9CqE,QAAS,CAACzG,EAAG9K,IAAS,IAAMA,EAAK+Q,eAAkB7D,EAAF,WACjDsE,OAAQ,CAAC1G,EAAG9K,IAAS,IAAMA,EAAK+Q,eAAkB7D,EAAF,UAGhDuE,eAAgB,IJrBH,cAAoCtE,EAEjD,oBAAqBU,EAAUJ,EAAU3E,GACvC,MAAMC,EAAQiF,E,sOAAgCH,GAC9C,UAAW,MAAM9L,KAAU+G,EAAYG,QAAQF,EAAO0E,GAAW,CAC/D,MAAMS,EAAQe,EAAWvX,IAAIzH,GAAK8W,EAAahF,EAAOtR,IAAIR,WACjDie,EAAMhX,KAAK,KAAb,OAKX,qBAAqB+Q,EAASwF,EAAU3E,GACtC,MAAMH,EAAU,aAAYV,EAAQ/Q,KAAK,OAEzC,aADM4R,EAAYuI,cAAc1I,EAAQ8E,GAAU5a,OAC3C,KIQT6e,OAAQ,CAAC5G,EAAG9K,IAAS,IAAMA,EAAKyR,eAAkBvE,EAAF,QAChDyE,UAAW,CAAC7G,EAAG9K,IAAS,IAAMA,EAAKyR,eAAkBvE,EAAF,WACnD0E,SAAU,CAAC9G,EAAG9K,IAAS,IAAMA,EAAKyR,eAAkBvE,EAAF,WI9BrC,MAAM2E,GAInBxT,YAAYyT,EAASC,GAEnB5f,KAAKmd,QAAUnd,KAAK6f,gBAAgBF,GACpC3f,KAAKmd,QAAQG,MAAM,IAAM,MACzBtd,KAAK8f,QAAUF,EAMjB,cAAepJ,EAAQmJ,SACd,yBAAyB5b,KAAKyS,GACnCxW,KAAKkf,cAAc1I,EAAQmJ,GAC3B3f,KAAK8f,QAAQhJ,QAAQN,EAAQmJ,GAMjCT,cAAc1I,EAAQmJ,GACpB,IAAI7e,GAAO,EAwBX,MAAO,CACLJ,KAxBWmQ,UACX,GAAI/P,EACF,MAAO,CAAEA,QACXA,GAAO,EAGP,MAAMmc,QAAgB0C,EAAU3f,KAAK6f,gBAAgBF,GAAW3f,KAAKmd,UAC/D,GAAE7b,EAAF,OAAMkK,EAAN,WAAc/J,SAAqBmc,IAAK9d,MAAMmd,EAAQ,CAC1DvS,OAAQ,QACRtJ,QAAS,CACP,eAAgB,6BAElBuG,KAAM6O,IAER,IAAKlV,EACH,MAAM,IAAIE,MAAO,wBAAuBgK,OAAY/J,KAMtD,aAHMzB,KAAK+f,WAAW9C,GAGf,CAAEve,MAAOud,EAAO,CAAE3a,SAIzB,CAAC9C,OAAOgS,iBAAmB,OAAOxQ,OAOtC,sBAAsB2f,GACpB,IAAI1C,QAAe0C,EASnB,GANI1C,aAAkB1B,IACpB0B,EAASA,EAAOzB,KACTyB,GAAkC,iBAAjBA,EAAOve,QAC/Bue,EAASA,EAAOve,OAGI,iBAAXue,EAAqB,CAC9B,IAAK,eAAelZ,KAAKkZ,GACvB,MAAM,IAAIzb,MAAM,wCAClB,OAAOyb,EAAO7R,QAAQ,MAAO,IAI/B,GAAIxH,MAAMC,QAAQoZ,GAAS,CAGzB,GAFAA,QAAe5c,QAAQiF,IAAI2X,EAAO1X,IAAI/F,GAAKQ,KAAK6f,gBAAgBrgB,KAChEyd,EAAS,GAAG7K,UAAU6K,GAAQqB,OAAO9e,KAAOA,GACtB,IAAlByd,EAAOpa,OACT,MAAM,IAAIrB,MAAM,oCAClB,OAAOyb,EAAO,GAIhB,MAAM,IAAIzb,MAAO,uBAAsByb,GAOzC8C,WAAWzE,GACT,OAAOtb,KAAK8f,QAAQC,WAAWzE,I,YCjGpB,OCQA,MAIb,YAAY0E,GAEVhgB,KAAKigB,cAAgBjgB,KAAKkgB,YAAYF,GACtChgB,KAAKigB,cAAc3C,MAAM,IAAM,MAMjC,cAAe9G,EAAQmJ,GACjB,yBAA2B5b,KAAKyS,WAC3BxW,KAAKkf,cAAc1I,EAAQmJ,IAGpC,MAAM/I,EAAQ,yBAAcJ,GAAQ,EAAM,oBAEpC2J,QAAeR,EAAU3f,KAAKkgB,YAAYP,GAAW3f,KAAKigB,eAEhEE,EAAMC,QAAU,KAGhB,MAAMtK,EAAU,SACV,IAAIzV,QAAQ,CAACC,EAASC,KAC1B4f,EAAMvJ,MAAMA,EAAO/V,GAAUiV,EAAQ1L,KAAKvJ,GAAS,KACjDoH,GAASA,EAAQ1H,EAAO0H,GAAS3H,EAAQwV,MAI7C,MAAMuB,EAAO,IAAIgJ,IAAIzJ,EAAMS,KAAK9R,IAAI+a,GAAK,IAAIA,EAAE5hB,QAC/C,IAAK,MAAMmC,KAAUiV,EAAS,CAG5B,MAAMe,EAAW1Y,OAAOmM,QAAQzJ,GAAQyd,OAAO,EAAEgC,KAAOjJ,EAAKnN,IAAIoW,UAC3D,IAAIC,IAAI1J,IAOlB,oBAAqBL,EAAQmJ,GAC3B,MAAM,IAAIne,MAAM,oDAAoDgV,GAMtE,kBAAkBgK,EAAYL,EAAQ,oBACpC,IAAIlD,QAAeuD,EACnB,GAAIvD,EAQF,GANIA,aAAkB1B,IACpB0B,EAASA,EAAOzB,KACW,cAApByB,EAAOpb,WACdob,EAASA,EAAOve,OAGI,iBAAXue,EAAqB,CAC9B,MAAM3B,EAAW2B,EAAO7R,QAAQ,MAAO,IACjCgV,EAAU,IAAI,WAAQD,SACtBC,EAAQhb,KAAKkW,QAGhB,GAAI1X,MAAMC,QAAQoZ,SACf5c,QAAQiF,IAAI2X,EAAO1X,IAAI/F,GAAKQ,KAAKkgB,YAAY1gB,EAAG2gB,SAGnD,IAA4B,mBAAjBlD,EAAOtH,MA0BrB,MAAM,IAAInU,MAAM,uBAAuByb,GA1BI,CAC3C,MAAMnH,EAAUmH,EAAOtH,MAAM,KAAM,KAAM,KAAM,YACzC,IAAItV,QAAQ,CAACC,EAASC,KAK1B,SAASkgB,EAAQ1Q,GACf,IACEoQ,EAAMlI,IAAIlI,EAAKF,QAASE,EAAKD,UAAWC,EAAK5Q,OAAQ4Q,EAAKC,OAE5D,MAAO/H,GACLyY,EAAOzY,IAIX,SAASyY,EAAOzY,GAId,OAHA6N,EAAQ6K,eAAe,OAAQF,GAC/B3K,EAAQ6K,eAAe,MAAOD,GAC9B5K,EAAQ6K,eAAe,QAASD,GACzBzY,EAAQ1H,EAAO0H,GAAS3H,EAAQ,MAjBzCwV,EAAQ8K,GAAG,OAAQH,GACnB3K,EAAQ8K,GAAG,MAAOF,GAClB5K,EAAQ8K,GAAG,QAASF,MAwB1B,OAAOP,EAOT,iBAAiB7E,MC/GJ,cPoCA,SAAwBuF,GACrC,IAAIC,EAAW,KAGf,MAAMC,EAAqB,IAAIvD,EAAY,CACzCjE,SAAU,IAAK4E,GAAiBnJ,KAAM,IAAM8L,GAC5CtH,UAAW,CAACuE,MA4Bd,OAxBA+C,EAAW,IAAItD,EAAY,CAEzBjE,SAAU,IACLmB,EAGHsG,KAAM,IAAIzD,EAAkBwD,GAE5B5F,KAAM,IAAIsC,EAAgBsD,GAG1BhB,WAAY,EAAG9J,cAAegL,GAC5BhL,EAASoH,oBAAoB0C,WAAWkB,GAG1Cte,QAASob,IAGXvE,UAAW,CAET,IAAIuD,EAAoBgE,OAEvBF,IACF9hB,SACI+hB,EOtEM,CAAa,CAC1BzD,kBAAmBsC,GACjB,IAAID,GAAkBC,EAAS,IAAIuB,GAAkBvB,S","file":"solid-query-ldflex.rdflib.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 19);\n","var DataFactory = require('./lib/data-factory')\n\nmodule.exports = DataFactory\n","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./lib/ContextParser\"));\n__export(require(\"./lib/FetchDocumentLoader\"));\n//# sourceMappingURL=index.js.map","module.exports = $rdf;","module.exports = solid[\"auth\"];","// the whatwg-fetch polyfill installs the fetch() function\n// on the global object (window or self)\n//\n// Return that as the export for use in Webpack, Browserify etc.\nrequire('whatwg-fetch');\nmodule.exports = self.fetch.bind(self);\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nrequire(\"isomorphic-fetch\");\n/**\n * Loads documents via the fetch API.\n */\nclass FetchDocumentLoader {\n    load(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch(url, { headers: { accept: 'application/ld+json' } });\n            if (response.ok) {\n                return (yield response.json());\n            }\n            else {\n                throw new Error(`No valid context was found at ${url}: ${response.statusText}`);\n            }\n        });\n    }\n}\nexports.FetchDocumentLoader = FetchDocumentLoader;\n//# sourceMappingURL=FetchDocumentLoader.js.map","function DefaultGraph () {\n  this.value = ''\n}\n\nDefaultGraph.prototype.equals = function (other) {\n  return !!other && other.termType === this.termType\n}\n\nDefaultGraph.prototype.termType = 'DefaultGraph'\n\nmodule.exports = DefaultGraph\n","function NamedNode (iri) {\n  this.value = iri\n}\n\nNamedNode.prototype.equals = function (other) {\n  return !!other && other.termType === this.termType && other.value === this.value\n}\n\nNamedNode.prototype.termType = 'NamedNode'\n\nmodule.exports = NamedNode\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nrequire(\"isomorphic-fetch\");\nconst relative_to_absolute_iri_1 = require(\"relative-to-absolute-iri\");\nconst FetchDocumentLoader_1 = require(\"./FetchDocumentLoader\");\n/**\n * Parses JSON-LD contexts.\n */\nclass ContextParser {\n    constructor(options) {\n        options = options || {};\n        this.documentLoader = options.documentLoader || new FetchDocumentLoader_1.FetchDocumentLoader();\n        this.documentCache = {};\n        this.validate = !options.skipValidation;\n        this.expandContentTypeToBase = options.expandContentTypeToBase;\n    }\n    /**\n     * Check if the given term is a valid compact IRI.\n     * Otherwise, it may be an IRI.\n     * @param {string} term A term.\n     * @return {boolean} If it is a compact IRI.\n     */\n    static isCompactIri(term) {\n        return term.indexOf(':') >= 0 && !(term && term[0] === '#');\n    }\n    /**\n     * Get the prefix from the given term.\n     * @see https://json-ld.org/spec/latest/json-ld/#compact-iris\n     * @param {string} term A term that is an URL or a prefixed URL.\n     * @param {IJsonLdContextNormalized} context A context.\n     * @return {string} The prefix or null.\n     */\n    static getPrefix(term, context) {\n        // Do not consider relative IRIs starting with a hash as compact IRIs\n        if (term && term[0] === '#') {\n            return null;\n        }\n        const separatorPos = term.indexOf(':');\n        if (separatorPos >= 0) {\n            // Suffix can not begin with two slashes\n            if (term.length > separatorPos + 1\n                && term.charAt(separatorPos + 1) === '/'\n                && term.charAt(separatorPos + 2) === '/') {\n                return null;\n            }\n            const prefix = term.substr(0, separatorPos);\n            // Prefix can not be an underscore (this is a blank node)\n            if (prefix === '_') {\n                return null;\n            }\n            // Prefix must match a term in the active context\n            if (context[prefix]) {\n                return prefix;\n            }\n        }\n        return null;\n    }\n    /**\n     * From a given context entry value, get the string value, or the @id field.\n     * @param contextValue A value for a term in a context.\n     * @return {string} The id value, or null.\n     */\n    static getContextValueId(contextValue) {\n        if (contextValue === null || typeof contextValue === 'string') {\n            return contextValue;\n        }\n        const id = contextValue['@id'];\n        return id ? id : null;\n    }\n    /**\n     * Expand the term or prefix of the given term if it has one,\n     * otherwise return the term as-is.\n     *\n     * This will try to expand the IRI as much as possible.\n     *\n     * Iff in vocab-mode, then other references to other terms in the context can be used,\n     * such as to `myTerm`:\n     * ```\n     * {\n     *   \"myTerm\": \"http://example.org/myLongTerm\"\n     * }\n     * ```\n     *\n     * @param {string} term A term that is an URL or a prefixed URL.\n     * @param {IJsonLdContextNormalized} context A context.\n     * @param {boolean} vocab If the term is a predicate or type and should be expanded based on @vocab,\n     *                        otherwise it is considered a regular term that is expanded based on @base.\n     * @return {string} The expanded term, the term as-is, or null if it was explicitly disabled in the context.\n     */\n    static expandTerm(term, context, vocab) {\n        ContextParser.assertNormalized(context);\n        const contextValue = context[term];\n        // Immediately return if the term was disabled in the context\n        if (contextValue === null || (contextValue && contextValue['@id'] === null)) {\n            return null;\n        }\n        // Check the @id\n        if (contextValue && vocab) {\n            const value = this.getContextValueId(contextValue);\n            if (value && value !== term) {\n                return value;\n            }\n        }\n        // Check if the term is prefixed\n        const prefix = ContextParser.getPrefix(term, context);\n        if (prefix) {\n            const value = this.getContextValueId(context[prefix]);\n            if (value) {\n                return value + term.substr(prefix.length + 1);\n            }\n        }\n        else if (vocab && context['@vocab'] && term.charAt(0) !== '@' && !ContextParser.isCompactIri(term)) {\n            return context['@vocab'] + term;\n        }\n        else if (!vocab && context['@base'] && term.charAt(0) !== '@' && !ContextParser.isCompactIri(term)) {\n            return relative_to_absolute_iri_1.resolve(term, context['@base']);\n        }\n        return term;\n    }\n    /**\n     * Compact the given term using @base, @vocab, an aliased term, or a prefixed term.\n     *\n     * This will try to compact the IRI as much as possible.\n     *\n     * @param {string} iri An IRI to compact.\n     * @param {IJsonLdContextNormalized} context The context to compact with.\n     * @param {boolean} vocab If the term is a predicate or type and should be compacted based on @vocab,\n     *                        otherwise it is considered a regular term that is compacted based on @base.\n     * @return {string} The compacted term or the IRI as-is.\n     */\n    static compactIri(iri, context, vocab) {\n        ContextParser.assertNormalized(context);\n        // Try @vocab compacting\n        if (vocab && context['@vocab'] && iri.startsWith(context['@vocab'])) {\n            return iri.substr(context['@vocab'].length);\n        }\n        // Try @base compacting\n        if (!vocab && context['@base'] && iri.startsWith(context['@base'])) {\n            return iri.substr(context['@base'].length);\n        }\n        // Loop over all terms in the context\n        // This will try to prefix as short as possible.\n        // Once a fully compacted alias is found, return immediately, as we can not go any shorter.\n        const shortestPrefixing = { prefix: '', suffix: iri };\n        for (const key in context) {\n            const value = context[key];\n            if (value && !key.startsWith('@')) {\n                const contextIri = this.getContextValueId(value);\n                if (iri.startsWith(contextIri)) {\n                    const suffix = iri.substr(contextIri.length);\n                    if (!suffix) {\n                        if (vocab) {\n                            // Immediately return on compacted alias\n                            return key;\n                        }\n                    }\n                    else if (suffix.length < shortestPrefixing.suffix.length) {\n                        // Overwrite the shortest prefix\n                        shortestPrefixing.prefix = key;\n                        shortestPrefixing.suffix = suffix;\n                    }\n                }\n            }\n        }\n        // Return the shortest prefix\n        if (shortestPrefixing.prefix) {\n            return shortestPrefixing.prefix + ':' + shortestPrefixing.suffix;\n        }\n        return iri;\n    }\n    /**\n     * An an assert to check if the given context has been normalized.\n     * An error will be thrown otherwise.\n     * @param {JsonLdContext} context A context.\n     */\n    static assertNormalized(context) {\n        if (typeof context === 'string' || Array.isArray(context) || context['@context']) {\n            throw new Error('The given context is not normalized. Make sure to call ContextParser.parse() first.');\n        }\n    }\n    /**\n     * Check if the given context value can be a prefix value.\n     * @param value A context value.\n     * @return {boolean} If it can be a prefix value.\n     */\n    static isPrefixValue(value) {\n        return value && (typeof value === 'string' || value['@id'] || value['@type']);\n    }\n    /**\n     * Check if the given IRI is valid.\n     * @param {string} iri A potential IRI.\n     * @return {boolean} If the given IRI is valid.\n     */\n    static isValidIri(iri) {\n        return ContextParser.IRI_REGEX.test(iri);\n    }\n    /**\n     * Add an @id term for all @reverse terms.\n     * @param {IJsonLdContextNormalized} context A context.\n     * @return {IJsonLdContextNormalized} The mutated input context.\n     */\n    static idifyReverseTerms(context) {\n        for (const key of Object.keys(context)) {\n            const value = context[key];\n            if (value && typeof value === 'object') {\n                if (value['@reverse'] && !value['@id']) {\n                    if (typeof value['@reverse'] !== 'string') {\n                        throw new Error(`Invalid @reverse value: '${value['@reverse']}'`);\n                    }\n                    value['@id'] = value['@reverse'];\n                    value['@reverse'] = true;\n                }\n            }\n        }\n        return context;\n    }\n    /**\n     * Expand all prefixed terms in the given context.\n     * @param {IJsonLdContextNormalized} context A context.\n     * @param {boolean} expandContentTypeToBase If @type inside the context may be expanded\n     *                                          via @base if @vocab is set to null.\n     * @return {IJsonLdContextNormalized} The mutated input context.\n     */\n    static expandPrefixedTerms(context, expandContentTypeToBase) {\n        for (const key of Object.keys(context)) {\n            // Only expand allowed keys\n            if (ContextParser.EXPAND_KEYS_BLACKLIST.indexOf(key) < 0) {\n                // Error if we try to alias a keyword to something else.\n                if (key[0] === '@' && ContextParser.ALIAS_KEYS_BLACKLIST.indexOf(key) >= 0) {\n                    throw new Error(`Keywords can not be aliased to something else.\nTried mapping ${key} to ${context[key]}`);\n                }\n                // Loop because prefixes might be nested\n                while (ContextParser.isPrefixValue(context[key])) {\n                    const value = context[key];\n                    let changed = false;\n                    if (typeof value === 'string') {\n                        context[key] = ContextParser.expandTerm(value, context, true);\n                        changed = changed || value !== context[key];\n                    }\n                    else {\n                        const id = value['@id'];\n                        const type = value['@type'];\n                        if (id) {\n                            context[key]['@id'] = ContextParser.expandTerm(id, context, true);\n                            changed = changed || id !== context[key]['@id'];\n                        }\n                        if (type && type !== '@vocab') {\n                            // First check @vocab, then fallback to @base\n                            context[key]['@type'] = ContextParser.expandTerm(type, context, true);\n                            if (expandContentTypeToBase && type === context[key]['@type']) {\n                                context[key]['@type'] = ContextParser.expandTerm(type, context, false);\n                            }\n                            changed = changed || type !== context[key]['@type'];\n                        }\n                    }\n                    if (!changed) {\n                        break;\n                    }\n                }\n            }\n        }\n        return context;\n    }\n    /**\n     * Normalize the @language entries in the given context to lowercase.\n     * @param {IJsonLdContextNormalized} context A context.\n     * @return {IJsonLdContextNormalized} The mutated input context.\n     */\n    static normalize(context) {\n        for (const key of Object.keys(context)) {\n            if (key === '@language' && typeof context[key] === 'string') {\n                context[key] = context[key].toLowerCase();\n            }\n            else {\n                const value = context[key];\n                if (value && typeof value === 'object') {\n                    if (typeof value['@language'] === 'string') {\n                        value['@language'] = value['@language'].toLowerCase();\n                    }\n                }\n            }\n        }\n        return context;\n    }\n    /**\n     * Validate the entries of the given context.\n     * @param {IJsonLdContextNormalized} context A context.\n     */\n    static validate(context) {\n        for (const key of Object.keys(context)) {\n            const value = context[key];\n            const valueType = typeof value;\n            // First check if the key is a keyword\n            if (key[0] === '@') {\n                switch (key.substr(1)) {\n                    case 'vocab':\n                        if (value !== null && valueType !== 'string') {\n                            throw new Error(`Found an invalid @vocab IRI: ${value}`);\n                        }\n                        break;\n                    case 'base':\n                        if (value !== null && valueType !== 'string') {\n                            throw new Error(`Found an invalid @base IRI: ${context[key]}`);\n                        }\n                        break;\n                    case 'language':\n                        if (value !== null && valueType !== 'string') {\n                            throw new Error(`Found an invalid @language string: ${value}`);\n                        }\n                        break;\n                }\n            }\n            // Otherwise, consider the key a term\n            if (value !== null) {\n                switch (valueType) {\n                    case 'string':\n                        // Always valid\n                        break;\n                    case 'object':\n                        if (!ContextParser.isCompactIri(key) && !('@id' in value)\n                            && (value['@type'] === '@id' ? !context['@base'] : !context['@vocab'])) {\n                            throw new Error(`Missing @id in context entry: '${key}': '${JSON.stringify(value)}'`);\n                        }\n                        for (const objectKey of Object.keys(value)) {\n                            const objectValue = value[objectKey];\n                            if (!objectValue) {\n                                continue;\n                            }\n                            switch (objectKey) {\n                                case '@id':\n                                    if (objectValue[0] === '@' && objectValue !== '@type' && objectValue !== '@id') {\n                                        throw new Error(`Illegal keyword alias in term value, found: '${key}': '${JSON.stringify(value)}'`);\n                                    }\n                                    break;\n                                case '@type':\n                                    if (objectValue !== '@id' && objectValue !== '@vocab'\n                                        && (objectValue[0] === '_' || !ContextParser.isValidIri(objectValue))) {\n                                        throw new Error(`A context @type must be an absolute IRI, found: '${key}': '${objectValue}'`);\n                                    }\n                                    break;\n                                case '@reverse':\n                                    if (typeof objectValue === 'string' && value['@id'] && value['@id'] !== objectValue) {\n                                        throw new Error(`Found non-matching @id and @reverse term values in '${key}':\\\n'${objectValue}' and '${value['@id']}'`);\n                                    }\n                                    break;\n                                case '@container':\n                                    if (objectValue === '@list' && value['@reverse']) {\n                                        throw new Error(`Term value can not be @container: @list and @reverse at the same time on '${key}'`);\n                                    }\n                                    if (ContextParser.CONTAINERS.indexOf(objectValue) < 0) {\n                                        throw new Error(`Invalid term @container for '${key}' ('${objectValue}'), \\\nmust be one of ${ContextParser.CONTAINERS.join(', ')}`);\n                                    }\n                                    break;\n                                case '@language':\n                                    if (objectValue !== null && typeof objectValue !== 'string') {\n                                        throw new Error(`Found an invalid term @language string in: '${key}': '${JSON.stringify(value)}'`);\n                                    }\n                                    break;\n                            }\n                        }\n                        break;\n                    default:\n                        throw new Error(`Found an invalid term value: '${key}': '${value}'`);\n                }\n            }\n        }\n    }\n    /**\n     * Resolve relative context IRIs, or return full IRIs as-is.\n     * @param {string} contextIri A context IRI.\n     * @param {string} baseIri A base IRI.\n     * @return {string} The normalized context IRI.\n     */\n    static normalizeContextIri(contextIri, baseIri) {\n        if (!ContextParser.isValidIri(contextIri)) {\n            contextIri = relative_to_absolute_iri_1.resolve(contextIri, baseIri);\n            if (!ContextParser.isValidIri(contextIri)) {\n                throw new Error(`Invalid context IRI: ${contextIri}`);\n            }\n        }\n        return contextIri;\n    }\n    /**\n     * Parse a JSON-LD context in any form.\n     * @param {JsonLdContext} context A context, URL to a context, or an array of contexts/URLs.\n     * @param {IParseOptions} options Optional parsing options.\n     * @return {Promise<IJsonLdContextNormalized>} A promise resolving to the context.\n     */\n    parse(context, { baseIri, parentContext, external } = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (context === null || context === undefined) {\n                // Context that are explicitly set to null are empty.\n                return baseIri ? { '@base': baseIri } : {};\n            }\n            else if (typeof context === 'string') {\n                return this.parse(yield this.load(ContextParser.normalizeContextIri(context, baseIri)), { baseIri, parentContext, external: true });\n            }\n            else if (Array.isArray(context)) {\n                // As a performance consideration, first load all external contexts in parallel.\n                const contexts = yield Promise.all(context.map((subContext) => {\n                    if (typeof subContext === 'string') {\n                        return this.load(ContextParser.normalizeContextIri(subContext, baseIri));\n                    }\n                    else {\n                        return subContext;\n                    }\n                }));\n                return contexts.reduce((accContextPromise, contextEntry) => accContextPromise\n                    .then((accContext) => this.parse(contextEntry, {\n                    baseIri: accContext && accContext['@base'] || baseIri,\n                    external,\n                    parentContext: accContext,\n                })), Promise.resolve(parentContext));\n            }\n            else if (typeof context === 'object') {\n                if (context['@context']) {\n                    return yield this.parse(context['@context'], { baseIri, parentContext, external });\n                }\n                // Make a deep clone of the given context, to avoid modifying it.\n                context = JSON.parse(JSON.stringify(context)); // No better way in JS at the moment...\n                // We have an actual context object.\n                let newContext = {};\n                // According to the JSON-LD spec, @base must be ignored from external contexts.\n                if (external) {\n                    delete context['@base'];\n                }\n                // Override the base IRI if provided.\n                if (baseIri) {\n                    if (!('@base' in context)) {\n                        // The context base is the document base\n                        context['@base'] = baseIri;\n                    }\n                    else if (context['@base'] !== null && !ContextParser.isValidIri(context['@base'])) {\n                        // The context base is relative to the document base\n                        context['@base'] = relative_to_absolute_iri_1.resolve(context['@base'], baseIri);\n                    }\n                }\n                newContext = Object.assign({}, newContext, parentContext, context);\n                ContextParser.idifyReverseTerms(newContext);\n                ContextParser.expandPrefixedTerms(newContext, this.expandContentTypeToBase);\n                ContextParser.normalize(newContext);\n                if (this.validate) {\n                    ContextParser.validate(newContext);\n                }\n                return newContext;\n            }\n            else {\n                throw new Error(`Tried parsing a context that is not a string, array or object, but got ${context}`);\n            }\n        });\n    }\n    load(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cached = this.documentCache[url];\n            if (cached) {\n                return Array.isArray(cached) ? cached.slice() : Object.assign({}, cached);\n            }\n            return this.documentCache[url] = (yield this.documentLoader.load(url))['@context'];\n        });\n    }\n}\n// Regex for valid IRIs\nContextParser.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ \"<>{}|\\\\\\[\\]`]*$/;\n// Keys in the contexts that will not be expanded based on the base IRI\nContextParser.EXPAND_KEYS_BLACKLIST = [\n    '@base',\n    '@vocab',\n    '@language',\n];\n// Keys in the contexts that may not be aliased\nContextParser.ALIAS_KEYS_BLACKLIST = [\n    '@container',\n    '@graph',\n    '@id',\n    '@index',\n    '@list',\n    '@nest',\n    '@none',\n    '@prefix',\n    '@reverse',\n    '@set',\n    '@type',\n    '@value',\n];\n// All valid @container values\nContextParser.CONTAINERS = [\n    '@list',\n    '@set',\n    '@index',\n    '@language',\n];\nexports.ContextParser = ContextParser;\n//# sourceMappingURL=ContextParser.js.map","var support = {\n  searchParams: 'URLSearchParams' in self,\n  iterable: 'Symbol' in self && 'iterator' in Symbol,\n  blob:\n    'FileReader' in self &&\n    'Blob' in self &&\n    (function() {\n      try {\n        new Blob()\n        return true\n      } catch (e) {\n        return false\n      }\n    })(),\n  formData: 'FormData' in self,\n  arrayBuffer: 'ArrayBuffer' in self\n}\n\nfunction isDataView(obj) {\n  return obj && DataView.prototype.isPrototypeOf(obj)\n}\n\nif (support.arrayBuffer) {\n  var viewClasses = [\n    '[object Int8Array]',\n    '[object Uint8Array]',\n    '[object Uint8ClampedArray]',\n    '[object Int16Array]',\n    '[object Uint16Array]',\n    '[object Int32Array]',\n    '[object Uint32Array]',\n    '[object Float32Array]',\n    '[object Float64Array]'\n  ]\n\n  var isArrayBufferView =\n    ArrayBuffer.isView ||\n    function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n}\n\nfunction normalizeName(name) {\n  if (typeof name !== 'string') {\n    name = String(name)\n  }\n  if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n    throw new TypeError('Invalid character in header field name')\n  }\n  return name.toLowerCase()\n}\n\nfunction normalizeValue(value) {\n  if (typeof value !== 'string') {\n    value = String(value)\n  }\n  return value\n}\n\n// Build a destructive iterator for the value list\nfunction iteratorFor(items) {\n  var iterator = {\n    next: function() {\n      var value = items.shift()\n      return {done: value === undefined, value: value}\n    }\n  }\n\n  if (support.iterable) {\n    iterator[Symbol.iterator] = function() {\n      return iterator\n    }\n  }\n\n  return iterator\n}\n\nexport function Headers(headers) {\n  this.map = {}\n\n  if (headers instanceof Headers) {\n    headers.forEach(function(value, name) {\n      this.append(name, value)\n    }, this)\n  } else if (Array.isArray(headers)) {\n    headers.forEach(function(header) {\n      this.append(header[0], header[1])\n    }, this)\n  } else if (headers) {\n    Object.getOwnPropertyNames(headers).forEach(function(name) {\n      this.append(name, headers[name])\n    }, this)\n  }\n}\n\nHeaders.prototype.append = function(name, value) {\n  name = normalizeName(name)\n  value = normalizeValue(value)\n  var oldValue = this.map[name]\n  this.map[name] = oldValue ? oldValue + ', ' + value : value\n}\n\nHeaders.prototype['delete'] = function(name) {\n  delete this.map[normalizeName(name)]\n}\n\nHeaders.prototype.get = function(name) {\n  name = normalizeName(name)\n  return this.has(name) ? this.map[name] : null\n}\n\nHeaders.prototype.has = function(name) {\n  return this.map.hasOwnProperty(normalizeName(name))\n}\n\nHeaders.prototype.set = function(name, value) {\n  this.map[normalizeName(name)] = normalizeValue(value)\n}\n\nHeaders.prototype.forEach = function(callback, thisArg) {\n  for (var name in this.map) {\n    if (this.map.hasOwnProperty(name)) {\n      callback.call(thisArg, this.map[name], name, this)\n    }\n  }\n}\n\nHeaders.prototype.keys = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push(name)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.values = function() {\n  var items = []\n  this.forEach(function(value) {\n    items.push(value)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.entries = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push([name, value])\n  })\n  return iteratorFor(items)\n}\n\nif (support.iterable) {\n  Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n}\n\nfunction consumed(body) {\n  if (body.bodyUsed) {\n    return Promise.reject(new TypeError('Already read'))\n  }\n  body.bodyUsed = true\n}\n\nfunction fileReaderReady(reader) {\n  return new Promise(function(resolve, reject) {\n    reader.onload = function() {\n      resolve(reader.result)\n    }\n    reader.onerror = function() {\n      reject(reader.error)\n    }\n  })\n}\n\nfunction readBlobAsArrayBuffer(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsArrayBuffer(blob)\n  return promise\n}\n\nfunction readBlobAsText(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsText(blob)\n  return promise\n}\n\nfunction readArrayBufferAsText(buf) {\n  var view = new Uint8Array(buf)\n  var chars = new Array(view.length)\n\n  for (var i = 0; i < view.length; i++) {\n    chars[i] = String.fromCharCode(view[i])\n  }\n  return chars.join('')\n}\n\nfunction bufferClone(buf) {\n  if (buf.slice) {\n    return buf.slice(0)\n  } else {\n    var view = new Uint8Array(buf.byteLength)\n    view.set(new Uint8Array(buf))\n    return view.buffer\n  }\n}\n\nfunction Body() {\n  this.bodyUsed = false\n\n  this._initBody = function(body) {\n    this._bodyInit = body\n    if (!body) {\n      this._bodyText = ''\n    } else if (typeof body === 'string') {\n      this._bodyText = body\n    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n      this._bodyBlob = body\n    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n      this._bodyFormData = body\n    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n      this._bodyText = body.toString()\n    } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n      this._bodyArrayBuffer = bufferClone(body.buffer)\n      // IE 10-11 can't handle a DataView body.\n      this._bodyInit = new Blob([this._bodyArrayBuffer])\n    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n      this._bodyArrayBuffer = bufferClone(body)\n    } else {\n      this._bodyText = body = Object.prototype.toString.call(body)\n    }\n\n    if (!this.headers.get('content-type')) {\n      if (typeof body === 'string') {\n        this.headers.set('content-type', 'text/plain;charset=UTF-8')\n      } else if (this._bodyBlob && this._bodyBlob.type) {\n        this.headers.set('content-type', this._bodyBlob.type)\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n      }\n    }\n  }\n\n  if (support.blob) {\n    this.blob = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return Promise.resolve(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as blob')\n      } else {\n        return Promise.resolve(new Blob([this._bodyText]))\n      }\n    }\n\n    this.arrayBuffer = function() {\n      if (this._bodyArrayBuffer) {\n        return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n      } else {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n    }\n  }\n\n  this.text = function() {\n    var rejected = consumed(this)\n    if (rejected) {\n      return rejected\n    }\n\n    if (this._bodyBlob) {\n      return readBlobAsText(this._bodyBlob)\n    } else if (this._bodyArrayBuffer) {\n      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n    } else if (this._bodyFormData) {\n      throw new Error('could not read FormData body as text')\n    } else {\n      return Promise.resolve(this._bodyText)\n    }\n  }\n\n  if (support.formData) {\n    this.formData = function() {\n      return this.text().then(decode)\n    }\n  }\n\n  this.json = function() {\n    return this.text().then(JSON.parse)\n  }\n\n  return this\n}\n\n// HTTP methods whose capitalization should be normalized\nvar methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\nfunction normalizeMethod(method) {\n  var upcased = method.toUpperCase()\n  return methods.indexOf(upcased) > -1 ? upcased : method\n}\n\nexport function Request(input, options) {\n  options = options || {}\n  var body = options.body\n\n  if (input instanceof Request) {\n    if (input.bodyUsed) {\n      throw new TypeError('Already read')\n    }\n    this.url = input.url\n    this.credentials = input.credentials\n    if (!options.headers) {\n      this.headers = new Headers(input.headers)\n    }\n    this.method = input.method\n    this.mode = input.mode\n    this.signal = input.signal\n    if (!body && input._bodyInit != null) {\n      body = input._bodyInit\n      input.bodyUsed = true\n    }\n  } else {\n    this.url = String(input)\n  }\n\n  this.credentials = options.credentials || this.credentials || 'same-origin'\n  if (options.headers || !this.headers) {\n    this.headers = new Headers(options.headers)\n  }\n  this.method = normalizeMethod(options.method || this.method || 'GET')\n  this.mode = options.mode || this.mode || null\n  this.signal = options.signal || this.signal\n  this.referrer = null\n\n  if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n    throw new TypeError('Body not allowed for GET or HEAD requests')\n  }\n  this._initBody(body)\n}\n\nRequest.prototype.clone = function() {\n  return new Request(this, {body: this._bodyInit})\n}\n\nfunction decode(body) {\n  var form = new FormData()\n  body\n    .trim()\n    .split('&')\n    .forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n  return form\n}\n\nfunction parseHeaders(rawHeaders) {\n  var headers = new Headers()\n  // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n  // https://tools.ietf.org/html/rfc7230#section-3.2\n  var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ')\n  preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n    var parts = line.split(':')\n    var key = parts.shift().trim()\n    if (key) {\n      var value = parts.join(':').trim()\n      headers.append(key, value)\n    }\n  })\n  return headers\n}\n\nBody.call(Request.prototype)\n\nexport function Response(bodyInit, options) {\n  if (!options) {\n    options = {}\n  }\n\n  this.type = 'default'\n  this.status = options.status === undefined ? 200 : options.status\n  this.ok = this.status >= 200 && this.status < 300\n  this.statusText = 'statusText' in options ? options.statusText : 'OK'\n  this.headers = new Headers(options.headers)\n  this.url = options.url || ''\n  this._initBody(bodyInit)\n}\n\nBody.call(Response.prototype)\n\nResponse.prototype.clone = function() {\n  return new Response(this._bodyInit, {\n    status: this.status,\n    statusText: this.statusText,\n    headers: new Headers(this.headers),\n    url: this.url\n  })\n}\n\nResponse.error = function() {\n  var response = new Response(null, {status: 0, statusText: ''})\n  response.type = 'error'\n  return response\n}\n\nvar redirectStatuses = [301, 302, 303, 307, 308]\n\nResponse.redirect = function(url, status) {\n  if (redirectStatuses.indexOf(status) === -1) {\n    throw new RangeError('Invalid status code')\n  }\n\n  return new Response(null, {status: status, headers: {location: url}})\n}\n\nexport var DOMException = self.DOMException\ntry {\n  new DOMException()\n} catch (err) {\n  DOMException = function(message, name) {\n    this.message = message\n    this.name = name\n    var error = Error(message)\n    this.stack = error.stack\n  }\n  DOMException.prototype = Object.create(Error.prototype)\n  DOMException.prototype.constructor = DOMException\n}\n\nexport function fetch(input, init) {\n  return new Promise(function(resolve, reject) {\n    var request = new Request(input, init)\n\n    if (request.signal && request.signal.aborted) {\n      return reject(new DOMException('Aborted', 'AbortError'))\n    }\n\n    var xhr = new XMLHttpRequest()\n\n    function abortXhr() {\n      xhr.abort()\n    }\n\n    xhr.onload = function() {\n      var options = {\n        status: xhr.status,\n        statusText: xhr.statusText,\n        headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n      }\n      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n      var body = 'response' in xhr ? xhr.response : xhr.responseText\n      resolve(new Response(body, options))\n    }\n\n    xhr.onerror = function() {\n      reject(new TypeError('Network request failed'))\n    }\n\n    xhr.ontimeout = function() {\n      reject(new TypeError('Network request failed'))\n    }\n\n    xhr.onabort = function() {\n      reject(new DOMException('Aborted', 'AbortError'))\n    }\n\n    xhr.open(request.method, request.url, true)\n\n    if (request.credentials === 'include') {\n      xhr.withCredentials = true\n    } else if (request.credentials === 'omit') {\n      xhr.withCredentials = false\n    }\n\n    if ('responseType' in xhr && support.blob) {\n      xhr.responseType = 'blob'\n    }\n\n    request.headers.forEach(function(value, name) {\n      xhr.setRequestHeader(name, value)\n    })\n\n    if (request.signal) {\n      request.signal.addEventListener('abort', abortXhr)\n\n      xhr.onreadystatechange = function() {\n        // DONE (success or failure)\n        if (xhr.readyState === 4) {\n          request.signal.removeEventListener('abort', abortXhr)\n        }\n      }\n    }\n\n    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n  })\n}\n\nfetch.polyfill = true\n\nif (!self.fetch) {\n  self.fetch = fetch\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n}\n","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./lib/Resolve\"));\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Convert the given relative IRI to an absolute IRI\n * by taking into account the given optional baseIRI.\n *\n * @param {string} relativeIRI The relative IRI to convert to an absolute IRI.\n * @param {string} baseIRI The optional base IRI.\n * @return {string} an absolute IRI.\n */\nfunction resolve(relativeIRI, baseIRI) {\n    baseIRI = baseIRI || '';\n    const baseFragmentPos = baseIRI.indexOf('#');\n    // Ignore any fragments in the base IRI\n    if (baseFragmentPos > 0) {\n        baseIRI = baseIRI.substr(0, baseFragmentPos);\n    }\n    // Convert empty value directly to base IRI\n    if (!relativeIRI.length) {\n        return baseIRI;\n    }\n    // If the value starts with a query character, concat directly (but strip the existing query)\n    if (relativeIRI.startsWith('?')) {\n        const baseQueryPos = baseIRI.indexOf('?');\n        if (baseQueryPos > 0) {\n            baseIRI = baseIRI.substr(0, baseQueryPos);\n        }\n        return baseIRI + relativeIRI;\n    }\n    // If the value starts with a fragment character, concat directly\n    if (relativeIRI.startsWith('#')) {\n        return baseIRI + relativeIRI;\n    }\n    // Ignore baseIRI if it is empty\n    if (!baseIRI.length) {\n        return removeDotSegmentsOfPath(relativeIRI, relativeIRI.indexOf(':'));\n    }\n    // Ignore baseIRI if the value is absolute\n    const valueColonPos = relativeIRI.indexOf(':');\n    if (valueColonPos >= 0) {\n        return removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // At this point, the baseIRI MUST be absolute, otherwise we error\n    const baseColonPos = baseIRI.indexOf(':');\n    if (baseColonPos < 0) {\n        throw new Error(`Found invalid baseIRI '${baseIRI}' for value '${relativeIRI}'`);\n    }\n    const baseIRIScheme = baseIRI.substr(0, baseColonPos + 1);\n    // Inherit the baseIRI scheme if the value starts with '//'\n    if (relativeIRI.indexOf('//') === 0) {\n        return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n    }\n    // Check cases where '://' occurs in the baseIRI, and where there is no '/' after a ':' anymore.\n    let baseSlashAfterColonPos;\n    if (baseIRI.indexOf('//', baseColonPos) === baseColonPos + 1) {\n        // If there is no additional '/' after the '//'.\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 3);\n        if (baseSlashAfterColonPos < 0) {\n            // If something other than a '/' follows the '://', append the value after a '/',\n            // otherwise, prefix the value with only the baseIRI scheme.\n            if (baseIRI.length > baseColonPos + 3) {\n                return baseIRI + '/' + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n            else {\n                return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n            }\n        }\n    }\n    else {\n        // If there is not even a single '/' after the ':'\n        baseSlashAfterColonPos = baseIRI.indexOf('/', baseColonPos + 1);\n        if (baseSlashAfterColonPos < 0) {\n            // If we don't have a '/' after the ':',\n            // prefix the value with only the baseIRI scheme.\n            return baseIRIScheme + removeDotSegmentsOfPath(relativeIRI, valueColonPos);\n        }\n    }\n    // If the value starts with a '/', then prefix it with everything before the first effective slash of the base IRI.\n    if (relativeIRI.indexOf('/') === 0) {\n        return baseIRI.substr(0, baseSlashAfterColonPos) + removeDotSegments(relativeIRI);\n    }\n    let baseIRIPath = baseIRI.substr(baseSlashAfterColonPos);\n    const baseIRILastSlashPos = baseIRIPath.lastIndexOf('/');\n    // Ignore everything after the last '/' in the baseIRI path\n    if (baseIRILastSlashPos >= 0 && baseIRILastSlashPos < baseIRIPath.length - 1) {\n        baseIRIPath = baseIRIPath.substr(0, baseIRILastSlashPos + 1);\n        // Also remove the first character of the relative path if it starts with '.' (and not '..' or './')\n        // This change is only allowed if there is something else following the path\n        if (relativeIRI[0] === '.' && relativeIRI[1] !== '.' && relativeIRI[1] !== '/' && relativeIRI[2]) {\n            relativeIRI = relativeIRI.substr(1);\n        }\n    }\n    // Prefix the value with the baseIRI path where\n    relativeIRI = baseIRIPath + relativeIRI;\n    // Remove dot segment from the IRI\n    relativeIRI = removeDotSegments(relativeIRI);\n    // Prefix our transformed value with the part of the baseIRI until the first '/' after the first ':'.\n    return baseIRI.substr(0, baseSlashAfterColonPos) + relativeIRI;\n}\nexports.resolve = resolve;\n/**\n * Remove dot segments from the given path,\n * as described in https://www.ietf.org/rfc/rfc3986.txt (page 32).\n * @param {string} path An IRI path.\n * @return {string} A path, will always start with a '/'.\n */\nfunction removeDotSegments(path) {\n    // Prepare a buffer with segments between each '/.\n    // Each segment represents an array of characters.\n    const segmentBuffers = [];\n    let i = 0;\n    while (i < path.length) {\n        // Remove '/.' or '/..'\n        switch (path[i]) {\n            case '/':\n                if (path[i + 1] === '.') {\n                    if (path[i + 2] === '.') {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 3])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Go to parent directory,\n                        // so we remove a parent segment\n                        segmentBuffers.pop();\n                        // Ensure that we end with a slash if there is a trailing '/..'\n                        if (!path[i + 3]) {\n                            segmentBuffers.push([]);\n                        }\n                        i += 3;\n                    }\n                    else {\n                        // Start a new segment if we find an invalid character after the '.'\n                        if (!isCharacterAllowedAfterRelativePathSegment(path[i + 2])) {\n                            segmentBuffers.push([]);\n                            i++;\n                            break;\n                        }\n                        // Ensure that we end with a slash if there is a trailing '/.'\n                        if (!path[i + 2]) {\n                            segmentBuffers.push([]);\n                        }\n                        // Go to the current directory,\n                        // so we do nothing\n                        i += 2;\n                    }\n                }\n                else {\n                    // Start a new segment\n                    segmentBuffers.push([]);\n                    i++;\n                }\n                break;\n            case '#':\n            case '?':\n                // Query and fragment string should be appended unchanged\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path.substr(i));\n                // Break the while loop\n                i = path.length;\n                break;\n            default:\n                // Not a special character, just append it to our buffer\n                if (!segmentBuffers.length) {\n                    segmentBuffers.push([]);\n                }\n                segmentBuffers[segmentBuffers.length - 1].push(path[i]);\n                i++;\n                break;\n        }\n    }\n    return '/' + segmentBuffers.map((buffer) => buffer.join('')).join('/');\n}\nexports.removeDotSegments = removeDotSegments;\n/**\n * Removes dot segments of the given IRI.\n * @param {string} iri An IRI (or part of IRI).\n * @param {number} colonPosition The position of the first ':' in the IRI.\n * @return {string} The IRI where dot segments were removed.\n */\nfunction removeDotSegmentsOfPath(iri, colonPosition) {\n    // Determine where we should start looking for the first '/' that indicates the start of the path\n    let searchOffset = colonPosition + 1;\n    if (colonPosition >= 0) {\n        if (iri[colonPosition + 1] === '/' && iri[colonPosition + 2] === '/') {\n            searchOffset = colonPosition + 3;\n        }\n    }\n    else {\n        if (iri[0] === '/' && iri[1] === '/') {\n            searchOffset = 2;\n        }\n    }\n    // Determine the path\n    const pathSeparator = iri.indexOf('/', searchOffset);\n    if (pathSeparator < 0) {\n        return iri;\n    }\n    const base = iri.substr(0, pathSeparator);\n    const path = iri.substr(pathSeparator);\n    // Remove dot segments from the path\n    return base + removeDotSegments(path);\n}\nexports.removeDotSegmentsOfPath = removeDotSegmentsOfPath;\nfunction isCharacterAllowedAfterRelativePathSegment(character) {\n    return !character || character === '#' || character === '?' || character === '/';\n}\n//# sourceMappingURL=Resolve.js.map","var BlankNode = require('./blank-node')\nvar DefaultGraph = require('./default-graph')\nvar Literal = require('./literal')\nvar NamedNode = require('./named-node')\nvar Quad = require('./quad')\nvar Variable = require('./variable')\n\nfunction DataFactory () {}\n\nDataFactory.namedNode = function (value) {\n  return new NamedNode(value)\n}\n\nDataFactory.blankNode = function (value) {\n  return new BlankNode(value)\n}\n\nDataFactory.literal = function (value, languageOrDatatype) {\n  if (typeof languageOrDatatype === 'string') {\n    if (languageOrDatatype.indexOf(':') === -1) {\n      return new Literal(value, languageOrDatatype)\n    }\n\n    return new Literal(value, null, DataFactory.namedNode(languageOrDatatype))\n  }\n\n  return new Literal(value, null, languageOrDatatype)\n}\n\nDataFactory.defaultGraph = function () {\n  return DataFactory.defaultGraphInstance\n}\n\nDataFactory.variable = function (value) {\n  return new Variable(value)\n}\n\nDataFactory.triple = function (subject, predicate, object) {\n  return DataFactory.quad(subject, predicate, object)\n}\n\nDataFactory.quad = function (subject, predicate, object, graph) {\n  return new Quad(subject, predicate, object, graph || DataFactory.defaultGraphInstance)\n}\n\nDataFactory.defaultGraphInstance = new DefaultGraph()\n\nmodule.exports = DataFactory\n","function BlankNode (id) {\n  this.value = id || ('b' + (++BlankNode.nextId))\n}\n\nBlankNode.prototype.equals = function (other) {\n  return !!other && other.termType === this.termType && other.value === this.value\n}\n\nBlankNode.prototype.termType = 'BlankNode'\n\nBlankNode.nextId = 0\n\nmodule.exports = BlankNode\n","var NamedNode = require('./named-node')\n\nfunction Literal (value, language, datatype) {\n  this.value = value\n  this.datatype = Literal.stringDatatype\n  this.language = ''\n\n  if (language) {\n    this.language = language\n    this.datatype = Literal.langStringDatatype\n  } else if (datatype) {\n    this.datatype = datatype\n  }\n}\n\nLiteral.prototype.equals = function (other) {\n  return !!other && other.termType === this.termType && other.value === this.value &&\n    other.language === this.language && other.datatype.equals(this.datatype)\n}\n\nLiteral.prototype.termType = 'Literal'\nLiteral.langStringDatatype = new NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString')\nLiteral.stringDatatype = new NamedNode('http://www.w3.org/2001/XMLSchema#string')\n\nmodule.exports = Literal\n","var DefaultGraph = require('./default-graph')\n\nfunction Quad (subject, predicate, object, graph) {\n  this.subject = subject\n  this.predicate = predicate\n  this.object = object\n\n  if (graph) {\n    this.graph = graph\n  } else {\n    this.graph = new DefaultGraph()\n  }\n}\n\nQuad.prototype.equals = function (other) {\n  return !!other && other.subject.equals(this.subject) && other.predicate.equals(this.predicate) &&\n    other.object.equals(this.object) && other.graph.equals(this.graph)\n}\n\nmodule.exports = Quad\n","function Variable (name) {\n  this.value = name\n}\n\nVariable.prototype.equals = function (other) {\n  return !!other && other.termType === this.termType && other.value === this.value\n}\n\nVariable.prototype.termType = 'Variable'\n\nmodule.exports = Variable\n","const done = {};\n/**\n * Gets the first element of the iterable.\n */\n\nexport function getFirstItem(iterable) {\n  const iterator = iterable[Symbol.asyncIterator]();\n  return iterator.next().then(item => item.value);\n}\n/**\n * Creates an async iterator with the item as only element.\n */\n\nexport function iteratorFor(item) {\n  return {\n    async next() {\n      if (item !== done) {\n        const value = await item;\n        item = done;\n        return {\n          value\n        };\n      }\n\n      return {\n        done: true\n      };\n    }\n\n  };\n}","/**\n * Resolves to the given item in the path data.\n * For example, new DataHandler({}, 'foo', 'bar')\n * will return pathData.foo.bar.\n *\n * Resolution can optionally be async,\n * and/or be behind a function call.\n */\nexport default class DataHandler {\n  constructor(options, ...dataProperties) {\n    this._isAsync = options.async;\n    this._isFunction = options.function;\n    this._dataProperties = dataProperties;\n  }\n\n  static sync(...dataProperties) {\n    return new DataHandler({\n      async: false\n    }, ...dataProperties);\n  }\n\n  static syncFunction(...dataProperties) {\n    return new DataHandler({\n      async: false,\n      function: true\n    }, ...dataProperties);\n  }\n\n  static async(...dataProperties) {\n    return new DataHandler({\n      async: true\n    }, ...dataProperties);\n  }\n\n  static asyncFunction(...dataProperties) {\n    return new DataHandler({\n      async: true,\n      function: true\n    }, ...dataProperties);\n  } // Resolves the data path, or returns a function that does so\n\n\n  handle(pathData) {\n    return !this._isFunction ? this._resolveDataPath(pathData) : () => this._resolveDataPath(pathData);\n  } // Resolves the data path\n\n\n  _resolveDataPath(data) {\n    return !this._isAsync ? this._resolveSyncDataPath(data) : this._resolveAsyncDataPath(data);\n  } // Resolves synchronous property access\n\n\n  _resolveSyncDataPath(data) {\n    for (const property of this._dataProperties) data = data && data[property];\n\n    return data;\n  } // Resolves asynchronous property access\n\n\n  async _resolveAsyncDataPath(data) {\n    for (const property of this._dataProperties) data = data && (await data[property]);\n\n    return data;\n  }\n\n}","import { getFirstItem } from './iterableUtils';\n/**\n * Returns a lazy thenable to the created promise.\n */\n\nexport function lazyThenable(createPromise) {\n  return {\n    then: getThen(createPromise)\n  };\n}\n/**\n * Lazily returns the `then` function of the created promise.\n */\n\nexport function getThen(createPromise) {\n  return (onResolved, onRejected) => createPromise().then(onResolved, onRejected);\n}\n/**\n * Returns an iterable that is also a promise to the first element.\n */\n\nexport function toIterablePromise(iterable) {\n  // If called with a generator function,\n  // memoize it to enable multiple iterations\n  if (typeof iterable === 'function') iterable = memoizeIterable(iterable()); // Return an object that is iterable and a promise\n\n  return {\n    [Symbol.asyncIterator]() {\n      return iterable[Symbol.asyncIterator]();\n    },\n\n    get then() {\n      return getThen(() => getFirstItem(this));\n    },\n\n    catch(onRejected) {\n      return this.then(null, onRejected);\n    },\n\n    finally(callback) {\n      return this.then().finally(callback);\n    }\n\n  };\n}\n/**\n * Returns a memoized version of the iterable\n * that can be iterated over as many times as needed.\n */\n\nexport function memoizeIterable(iterable) {\n  const cache = [];\n  let iterator = iterable[Symbol.asyncIterator]();\n  return {\n    [Symbol.asyncIterator]() {\n      let i = 0;\n      return {\n        async next() {\n          // Return the item if it has been read already\n          if (i < cache.length) return cache[i++]; // Stop if there are no more items\n\n          if (!iterator) return {\n            done: true\n          }; // Read and cache an item from the iterable otherwise\n\n          const item = cache[i++] = iterator.next();\n          if ((await item).done) iterator = null;\n          return item;\n        }\n\n      };\n    }\n\n  };\n}","import { literal } from '@rdfjs/data-model';\nimport { lazyThenable } from './promiseUtils';\n/**\n * Returns a function that, when called with arguments,\n * extends the path with mutationExpressions.\n *\n * It uses the current path expression as domain expression\n * and the given arguments as range expression.\n * These arguments can either be raw, or other path expressions.\n *\n * Requires:\n * - a pathExpression property on the path proxy and all non-raw arguments.\n */\n\nexport default class MutationFunctionHandler {\n  constructor(mutationType, allowZeroArgs) {\n    this._mutationType = mutationType;\n    this._allowZeroArgs = allowZeroArgs;\n  }\n\n  handle(pathData, path) {\n    return (...args) => {\n      // Check if the given arguments are valid\n      if (!this._allowZeroArgs && !args.length) throw new Error(\"Mutation on \".concat(pathData, \" can not be invoked without arguments\")); // Create a lazy Promise to the mutation expressions\n\n      const mutationExpressions = lazyThenable(() => this.createMutationExpressions(pathData, path, args));\n      return pathData.extendPath({\n        mutationExpressions\n      });\n    };\n  }\n\n  async createMutationExpressions(pathData, path, args) {\n    // Check if we have a valid path\n    const conditions = await path.pathExpression;\n    if (!Array.isArray(conditions)) throw new Error(\"\".concat(pathData, \" has no pathExpression property\"));\n    if (conditions.length < 2) throw new Error(\"\".concat(pathData, \" should at least contain a subject and a predicate\")); // The arguments are the affected objects\n\n    const objects = await this.extractObjects(pathData, path, args); // If no objects were specified, mutate all objects in the domain\n\n    const mutationType = this._mutationType;\n    if (!objects) return [{\n      mutationType,\n      conditions\n    }]; // If no objects are affected, do not perform any mutations\n\n    if (objects.length === 0) return []; // Otherwise, mutate the affected objects\n\n    const {\n      predicate\n    } = conditions.pop();\n    if (!predicate) throw new Error(\"Expected predicate in \".concat(pathData));\n    return [{\n      mutationType,\n      conditions,\n      predicate,\n      objects\n    }];\n  }\n\n  async extractObjects(pathData, path, args) {\n    // No arguments means a wildcard\n    if (args.length === 0) return null; // Expand strings, promises, and paths\n\n    const objects = [];\n\n    for (const arg of args) {\n      // Process an asynchronously iterable argument\n      if (arg && arg[Symbol.asyncIterator]) {\n        for await (const item of arg) objects.push(this.extractObject(pathData, path, item));\n      } else {\n        // Process a (promise to) a string or term\n        objects.push(this.extractObject(pathData, path, (await arg)));\n      }\n    }\n\n    return objects;\n  }\n\n  extractObject(pathData, path, arg) {\n    if (typeof arg === 'string') return literal(arg);\n    if (arg && arg.termType) return arg;\n    throw new Error(\"Invalid object: \".concat(arg));\n  }\n\n}","import MutationFunctionHandler from './MutationFunctionHandler';\n/**\n * A MutationFunctionHandler for deletions.\n */\n\nexport default class DeleteFunctionHandler extends MutationFunctionHandler {\n  constructor() {\n    super('DELETE', true);\n  }\n\n}","const VARIABLE = /(SELECT\\s+)(\\?\\S+)/;\nconst QUERY_TAIL = /\\}[^}]*$/;\n/**\n * Returns a function that preloads and caches\n * certain properties of results on the current path.\n *\n * Requires:\n * - a predicate handler on the path proxy\n * - a queryEngine property in the path settings\n *\n * Creates:\n * - a resultsCache property on the path data\n */\n\nexport default class PreloadHandler {\n  /**\n   * Creates a preload function.\n   */\n  handle(pathData, pathProxy) {\n    return async (...properties) => {\n      if (properties.length > 0) {\n        // Map the properties to predicates\n        const predicates = await Promise.all(properties.map(async p => (await pathProxy[p].predicate).value)); // Create and attach the results cache to the path data\n\n        pathData.resultsCache = await this.createResultsCache(predicates, pathData, pathProxy);\n      }\n\n      return pathProxy;\n    };\n  }\n  /**\n   * Creates a cache for the results of\n   * resolving the given predicates against the path.\n   */\n\n\n  async createResultsCache(predicates, pathData, path) {\n    // Execute the preloading query\n    const {\n      query,\n      vars,\n      resultVar\n    } = await this.createQuery(predicates, path);\n    const {\n      settings: {\n        queryEngine\n      }\n    } = pathData;\n    const bindings = queryEngine.execute(query); // Extract all results and their preloaded property values\n\n    const resultsCache = {};\n    const propertyCaches = {};\n\n    for await (const binding of bindings) {\n      // Initialize the result's cache if needed\n      const result = binding.get(resultVar),\n            hash = hashTerm(result);\n\n      if (!(hash in resultsCache)) {\n        // Create the property cache\n        const propertyCache = propertyCaches[hash] = {};\n\n        for (const predicate of predicates) propertyCache[predicate] = []; // Create the result path\n\n\n        const resultData = {\n          subject: result,\n          propertyCache\n        };\n        resultsCache[hash] = pathData.extendPath(resultData, null);\n      } // Create and cache a possible property value path from the binding\n\n\n      const propertyCache = propertyCaches[hash];\n\n      for (let i = 0; i < vars.length; i++) {\n        const value = binding.get(vars[i]);\n\n        if (value) {\n          const valuePath = pathData.extendPath({\n            subject: value\n          }, null);\n          propertyCache[predicates[i]].push(valuePath);\n        }\n      }\n    }\n\n    return Object.values(resultsCache);\n  }\n  /**\n   * Creates the query for preloading the given predicates on the path\n   */\n\n\n  async createQuery(predicates, path) {\n    // Obtain the query for the current path, and its main variable\n    const parentQuery = await path.sparql;\n    const variableMatch = VARIABLE.exec(parentQuery);\n    if (!variableMatch) throw new Error(\"Unexpected path query: \".concat(parentQuery));\n    const resultVar = variableMatch[2]; // Modify the query to include the preload clauses\n    // TODO: instead of query manipulation, adjust the query generator\n\n    const vars = predicates.map((p, i) => \"?preload_\".concat(i));\n    const preloadClauses = predicates.map((predicate, i) => \"    { \".concat(resultVar, \" <\").concat(predicate, \"> \").concat(vars[i], \". }\")).join('\\n    UNION\\n');\n    const query = parentQuery.replace(VARIABLE, \"$1$2 \".concat(vars.join(' '))).replace(QUERY_TAIL, \"  OPTIONAL {\\n\".concat(preloadClauses, \"\\n  }\\n$&\"));\n    return {\n      query,\n      vars,\n      resultVar\n    };\n  }\n\n} // Returns a unique string representation of the term\n\nfunction hashTerm(term) {\n  const {\n    termType,\n    value\n  } = term;\n\n  switch (termType) {\n    case 'NamedNode':\n      return value;\n\n    case 'Literal':\n      const {\n        language,\n        datatype\n      } = term;\n      return \"\".concat(termType, \"|\").concat(language, \"|\").concat(datatype.value, \"|\").concat(value);\n\n    default:\n      return \"\".concat(termType, \"|\").concat(value);\n  }\n}","/**\n * Returns a function that creates a new path with the same values,\n * but sorted on the given property.\n * The function accepts multiple properties to sort on a deeper path.\n *\n * Requires:\n *  - a predicate on the path proxy\n *  - a sort function on the path proxy (for multi-property sorting)\n */\nexport default class SortHandler {\n  constructor(order = 'ASC') {\n    this.order = order;\n  }\n\n  handle(pathData, pathProxy) {\n    return (...properties) => {\n      // Do nothing if no sort properties were given\n      if (properties.length === 0) return pathProxy; // Split off the first sort property and obtain its predicate\n\n      const [property, ...rest] = properties;\n      const {\n        predicate\n      } = pathProxy[property]; // Sort on the first property, and create paths for the next one\n\n      const childData = {\n        property,\n        predicate,\n        sort: this.order\n      };\n      const childPath = pathData.extendPath(childData);\n      return rest.length === 0 ? childPath : childPath.sort(...rest);\n    };\n  }\n\n}","import { namedNode } from '@rdfjs/data-model';\nconst NEEDS_ESCAPE = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019\\ud800-\\udbff]/,\n      ESCAPE_ALL = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019]|[\\ud800-\\udbff][\\udc00-\\udfff]/g,\n      ESCAPED_CHARS = {\n  '\\\\': '\\\\\\\\',\n  '\"': '\\\\\"',\n  '\\t': '\\\\t',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\b': '\\\\b',\n  '\\f': '\\\\f'\n};\n/**\n * Expresses a path or mutation as a SPARQL query.\n *\n * Requires:\n * - a mutationExpressions or pathExpression property on the path proxy\n */\n\nexport default class SparqlHandler {\n  async handle(pathData, path) {\n    // First check if we have a mutation expression\n    const mutationExpressions = await path.mutationExpressions;\n    if (Array.isArray(mutationExpressions) && mutationExpressions.length) return mutationExpressions.map(e => this.mutationExpressionToQuery(e)).join('\\n;\\n'); // Otherwise, fall back to checking for a path expression\n\n    const pathExpression = await path.pathExpression;\n    if (!Array.isArray(pathExpression)) throw new Error(\"\".concat(pathData, \" has no pathExpression property\"));\n    return this.pathExpressionToQuery(pathData, path, pathExpression);\n  }\n\n  pathExpressionToQuery(pathData, path, pathExpression) {\n    if (pathExpression.length < 2 && !pathData.finalClause) throw new Error(\"\".concat(pathData, \" should at least contain a subject and a predicate\")); // Create triple patterns\n\n    let queryVar = '?subject',\n        sorts = [],\n        clauses = [];\n\n    if (pathExpression.length > 1) {\n      queryVar = this.createVar(pathData.property);\n      ({\n        queryVar,\n        sorts,\n        clauses\n      } = this.expressionToTriplePatterns(pathExpression, queryVar));\n    }\n\n    if (pathData.finalClause) clauses.push(pathData.finalClause(queryVar)); // Create SPARQL query body\n\n    const distinct = pathData.distinct ? 'DISTINCT ' : '';\n    const select = \"SELECT \".concat(distinct).concat(pathData.select ? pathData.select : queryVar);\n    const where = \" WHERE {\\n  \".concat(clauses.join('\\n  '), \"\\n}\");\n    const orderClauses = sorts.map(({\n      order,\n      variable\n    }) => \"\".concat(order, \"(\").concat(variable, \")\"));\n    const orderBy = orderClauses.length === 0 ? '' : \"\\nORDER BY \".concat(orderClauses.join(' '));\n    return \"\".concat(select).concat(where).concat(orderBy);\n  }\n\n  mutationExpressionToQuery({\n    mutationType,\n    conditions,\n    predicate,\n    objects\n  }) {\n    // If the only condition is a subject, we need no WHERE clause\n    const scope = {};\n    let subject, where;\n\n    if (conditions.length === 1) {\n      subject = this.termToString(conditions[0].subject);\n      where = [];\n    } // Otherwise, create a WHERE clause from all conditions\n    else {\n        const lastPredicate = conditions[conditions.length - 1].predicate;\n        subject = this.createVar(lastPredicate.value, scope);\n        ({\n          queryVar: subject,\n          clauses: where\n        } = this.expressionToTriplePatterns(conditions, subject, scope));\n      } // If a list of objects was specified, the mutation is \"<s> <p> objects\"\n\n\n    const objectList = objects && objects.map(o => this.termToString(o)).join(', ');\n    const mutationPattern = objectList ? \"\".concat(subject, \" \").concat(this.termToString(predicate), \" \").concat(objectList, \".\") : // Otherwise, the mutation is the unconstrained last segment\n    where[where.length - 1];\n    return where.length === 0 ? // If there are no WHERE clauses, just mutate raw data\n    \"\".concat(mutationType, \" DATA {\\n  \").concat(mutationPattern, \"\\n}\") : // Otherwise, return a DELETE/INSERT ... WHERE ... query\n    \"\".concat(mutationType, \" {\\n  \").concat(mutationPattern, \"\\n} WHERE {\\n  \").concat(where.join('\\n  '), \"\\n}\");\n  }\n\n  expressionToTriplePatterns([root, ...pathExpression], lastVar, scope = {}) {\n    const lastIndex = pathExpression.length - 1;\n    let object = this.termToString(skolemize(root.subject));\n    let queryVar = object;\n    const sorts = [];\n    const clauses = pathExpression.map((segment, index) => {\n      // Obtain components and generate triple pattern\n      const subject = object;\n      const {\n        predicate\n      } = segment;\n      object = index < lastIndex ? this.createVar(\"v\".concat(index), scope) : lastVar;\n      const result = \"\".concat(subject, \" \").concat(this.termToString(predicate), \" \").concat(object, \".\"); // If the sort option was not set, use this object as a query variable\n\n      if (!segment.sort) {\n        queryVar = object;\n      } // If sort was set, use this object as a sorting variable\n      else {\n          // TODO: handle when an object is used for sorting, and later also for querying\n          sorts.push({\n            variable: object,\n            order: segment.sort\n          }); // TODO: use a descriptive lastVar in case of sorting\n\n          object = queryVar;\n        }\n\n      return result;\n    });\n    return {\n      queryVar,\n      sorts,\n      clauses\n    };\n  } // Creates a unique query variable within the given scope, based on the suggestion\n\n\n  createVar(suggestion = '', scope) {\n    let counter = 0;\n    let label = \"?\".concat(suggestion.match(/[a-z0-9]*$/i)[0] || 'result');\n\n    if (scope) {\n      while (scope[label]) label = \"?\".concat(suggestion, \"_\").concat(counter++);\n\n      scope[label] = true;\n    }\n\n    return label;\n  } // Converts an RDFJS term to a string that we can use in a query\n\n\n  termToString(term) {\n    // Determine escaped value\n    let {\n      value\n    } = term;\n    if (NEEDS_ESCAPE.test(value)) value = value.replace(ESCAPE_ALL, escapeCharacter);\n\n    switch (term.termType) {\n      case 'NamedNode':\n        return \"<\".concat(value, \">\");\n\n      case 'BlankNode':\n        return \"_:\".concat(value);\n\n      case 'Literal':\n        // Determine optional language or datatype\n        let suffix = '';\n        if (term.language) suffix = \"@\".concat(term.language);else if (term.datatype.value !== 'http://www.w3.org/2001/XMLSchema#string') suffix = \"^^<\".concat(term.datatype.value, \">\");\n        return \"\\\"\".concat(value, \"\\\"\").concat(suffix);\n\n      default:\n        throw new Error(\"Could not convert a term of type \".concat(term.termType));\n    }\n  }\n\n} // Replaces a character by its escaped version\n// (borrowed from https://www.npmjs.com/package/n3)\n\nfunction escapeCharacter(character) {\n  // Replace a single character by its escaped version\n  let result = ESCAPED_CHARS[character];\n\n  if (result === undefined) {\n    // Replace a single character with its 4-bit unicode escape sequence\n    if (character.length === 1) {\n      result = character.charCodeAt(0).toString(16);\n      result = '\\\\u0000'.substr(0, 6 - result.length) + result;\n    } // Replace a surrogate pair with its 8-bit unicode escape sequence\n    else {\n        result = ((character.charCodeAt(0) - 0xD800) * 0x400 + character.charCodeAt(1) + 0x2400).toString(16);\n        result = '\\\\U00000000'.substr(0, 10 - result.length) + result;\n      }\n  }\n\n  return result;\n} // Skolemizes the given term if it is a blank node\n\n\nlet skolemId = 0;\n\nfunction skolemize(term) {\n  if (term.termType !== 'BlankNode') return term;\n  if (!term.skolemized) term.skolemized = namedNode(\"urn:ldflex:sk\".concat(skolemId++));\n  return term.skolemized;\n}","import AsyncIteratorHandler from './AsyncIteratorHandler';\nimport DataHandler from './DataHandler';\nimport DeleteFunctionHandler from './DeleteFunctionHandler';\nimport ExecuteQueryHandler from './ExecuteQueryHandler';\nimport InsertFunctionHandler from './InsertFunctionHandler';\nimport MutationExpressionsHandler from './MutationExpressionsHandler';\nimport PathExpressionHandler from './PathExpressionHandler';\nimport PredicateHandler from './PredicateHandler';\nimport PredicatesHandler from './PredicatesHandler';\nimport PreloadHandler from './PreloadHandler';\nimport PropertiesHandler from './PropertiesHandler';\nimport ReplaceFunctionHandler from './ReplaceFunctionHandler';\nimport SetFunctionHandler from './SetFunctionHandler';\nimport SortHandler from './SortHandler';\nimport SparqlHandler from './SparqlHandler';\nimport StringToLDflexHandler from './StringToLDflexHandler';\nimport SubjectHandler from './SubjectHandler';\nimport SubjectsHandler from './SubjectsHandler';\nimport ThenHandler from './ThenHandler';\nimport ToArrayHandler from './ToArrayHandler';\n/**\n * A map with default property handlers.\n */\n\nexport default {\n  // Flag to loaders that exported paths are not ES6 modules\n  __esModule: () => undefined,\n  // Add thenable and async iterable behavior\n  then: new ThenHandler(),\n  [Symbol.asyncIterator]: new AsyncIteratorHandler(),\n  // Add read and query functionality\n  subject: new SubjectHandler(),\n  predicate: new PredicateHandler(),\n  properties: new PropertiesHandler(),\n  predicates: new PredicatesHandler(),\n  pathExpression: new PathExpressionHandler(),\n  sparql: new SparqlHandler(),\n  subjects: new SubjectsHandler(),\n  results: new ExecuteQueryHandler(),\n  sort: new SortHandler('ASC'),\n  sortDesc: new SortHandler('DESC'),\n  preload: new PreloadHandler(),\n  // Add write functionality\n  mutationExpressions: new MutationExpressionsHandler(),\n  add: new InsertFunctionHandler(),\n  set: new SetFunctionHandler(),\n  replace: new ReplaceFunctionHandler(),\n  delete: new DeleteFunctionHandler(),\n  // Add RDFJS term handling\n  termType: termPropertyHandler('termType'),\n  value: termPropertyHandler('value'),\n  datatype: termPropertyHandler('datatype'),\n  language: termPropertyHandler('language'),\n  equals: DataHandler.sync('subject', 'equals'),\n  toString: DataHandler.syncFunction('subject', 'value'),\n  toPrimitive: DataHandler.syncFunction('subject', 'value'),\n  // Add iteration helpers\n  toArray: new ToArrayHandler(),\n  termTypes: handler((_, path) => path.toArray(t => t.termType)),\n  values: handler((_, path) => path.toArray(t => t.value)),\n  datatypes: handler((_, path) => path.toArray(t => t.datatype)),\n  languages: handler((_, path) => path.toArray(t => t.language)),\n  // Parse a string into an LDflex object\n  resolve: new StringToLDflexHandler()\n}; // Creates a handler from the given function\n\nfunction handler(handle) {\n  return {\n    handle\n  };\n} // Creates a handler for the given RDF/JS Term property\n\n\nfunction termPropertyHandler(property) {\n  return handler((pathData, path) => {\n    // If a resolved subject is present,\n    // synchronously expose the RDF/JS property\n    const {\n      subject\n    } = pathData;\n    const subjectValue = subject && subject[property];\n    if (typeof subjectValue !== 'undefined') return subjectValue; // Otherwise, return a promise to the property value\n\n    return path.then(term => term && term[property]);\n  });\n}","import { getThen } from './promiseUtils';\nimport { getFirstItem } from './iterableUtils';\n/**\n * Thenable handler that resolves to either the subject\n * of the first item of the results.\n *\n * Requires:\n *  - (optional) a subject on the path data\n *  - (optional) a subject on the path proxy\n *  - (optional) results on the path proxy\n */\n\nexport default class ThenHandler {\n  handle({\n    subject\n  }, pathProxy) {\n    // Resolve to either the subject (zero-length path) or the first result\n    return subject ? // If the subject is not a promise, it has already been resolved;\n    // consumers should not resolve it, but access its properties directly.\n    // This avoids infinite `then` chains when `await`ing this path.\n    subject.then && getThen(() => pathProxy.subject) : // Otherwise, return the first result of this path\n    getThen(() => getFirstItem(pathProxy.results));\n  }\n\n}","import { iteratorFor } from './iterableUtils';\n/**\n * AsyncIterator handler that yields either the subject or all results.\n *\n * Requires:\n *  - (optional) a subject on the path data\n *  - (optional) a subject on the path proxy\n *  - (optional) results on the path proxy\n */\n\nexport default class AsyncIteratorHandler {\n  handle({\n    subject\n  }, pathProxy) {\n    // Return a one-item iterator of the subject if present;\n    // otherwise, return all results of this path\n    return subject ? () => iteratorFor(pathProxy.subject) : () => pathProxy.results[Symbol.asyncIterator]();\n  }\n\n}","/**\n * Returns a new path starting from the subject of the current path.\n *\n * Requires:\n * - (optional) a subject property on the path data\n * - (optional) a parent property on the path data\n */\nexport default class SubjectHandler {\n  handle(pathData) {\n    // Traverse parents until we find a subject\n    let {\n      subject,\n      parent\n    } = pathData;\n\n    while (!subject && parent) ({\n      subject,\n      parent\n    } = parent); // Resolve the subject if it exists,\n    // and return a path starting from that subject\n\n\n    return !subject ? undefined : Promise.resolve(subject).then(value => pathData.extendPath({\n      subject: value\n    }, null));\n  }\n\n}","/**\n * Returns a new path starting from the predicate of the current path.\n *\n * Requires:\n * - (optional) a predicate property on the path data\n */\nexport default class PredicateHandler {\n  handle(pathData) {\n    const {\n      predicate\n    } = pathData;\n    return !predicate ? undefined : Promise.resolve(predicate).then(subject => pathData.extendPath({\n      subject\n    }, null));\n  }\n\n}","/**\n * Queries for all compacted predicates of a path subject\n */\nimport { ContextParser } from 'jsonld-context-parser';\nimport { toIterablePromise } from './promiseUtils';\nexport default class PropertiesHandler {\n  handle(pathData, path) {\n    return toIterablePromise(this._handle(pathData, path));\n  }\n\n  async *_handle(pathData, path) {\n    const context = (await pathData.settings.parsedContext) || {};\n\n    for await (const predicate of path.predicates) yield ContextParser.compactIri(\"\".concat((await predicate)), context, true);\n  }\n\n}","/**\n * Queries for all predicates of a path subject\n */\nexport default class PredicatesHandler {\n  handle(pathData) {\n    return pathData.extendPath({\n      distinct: true,\n      select: '?predicate',\n      finalClause: queryVar => \"\".concat(queryVar, \" ?predicate ?object.\"),\n      property: pathData.property\n    });\n  }\n\n}","/**\n * Traverses a path to collect links and nodes into an expression.\n */\nexport default class PathExpressionHandler {\n  async handle(pathData) {\n    const segments = [];\n    let current = pathData; // Add all predicates to the path\n\n    while (current.parent) {\n      // Obtain and store predicate\n      if (current.predicate) {\n        segments.unshift({\n          predicate: await current.predicate,\n          sort: current.sort\n        });\n      } // Move to parent link\n\n\n      current = current.parent;\n    } // Add the root subject to the path\n\n\n    if (!current.subject) throw new Error(\"Expected root subject in \".concat(current));\n    const subject = await current.subject;\n    segments.unshift({\n      subject\n    });\n    return segments;\n  }\n\n}","/**\n * Queries for all subjects of a document\n */\nexport default class SubjectsHandler {\n  handle(pathData) {\n    return pathData.extendPath({\n      distinct: true,\n      select: '?subject',\n      finalClause: () => '?subject ?predicate ?object.',\n      property: pathData.property\n    });\n  }\n\n}","/**\n * Executes the query represented by a path.\n *\n * Requires:\n * - a queryEngine property in the path settings\n * - a sparql property on the path proxy\n * - (optional) a resultsCache property on the path data\n */\nexport default class ExecuteQueryHandler {\n  async *handle(pathData, path) {\n    // Try to retrieve the result from cache\n    const resultsCache = await pathData.resultsCache;\n\n    if (resultsCache) {\n      for (const result of resultsCache) yield result;\n\n      return;\n    } // Retrieve the query engine and query\n\n\n    const {\n      queryEngine\n    } = pathData.settings;\n    if (!queryEngine) throw new Error(\"\".concat(pathData, \" has no queryEngine setting\"));\n    const query = await path.sparql;\n    if (!query) throw new Error(\"\".concat(pathData, \" has no sparql property\")); // Extract the term from every query result\n\n    for await (const bindings of queryEngine.execute(query)) yield this.extractTerm(bindings, pathData);\n  }\n  /**\n   * Extracts the first term from a query result binding as a new path.\n   */\n\n\n  extractTerm(binding, pathData) {\n    // Extract the first term from the binding map\n    if (binding.size !== 1) throw new Error('Only single-variable queries are supported');\n    const subject = binding.values().next().value; // Each result is a new path that starts from the term as subject\n\n    return pathData.extendPath({\n      subject\n    }, null);\n  }\n\n}","/**\n * Traverses a path to collect mutationExpressions into an expression.\n * This is needed because mutations can be chained.\n *\n * Requires:\n * - a mutationExpressions property on the path proxy\n */\nexport default class MutationExpressionsHandler {\n  async handle(pathData) {\n    const mutationExpressions = []; // Add all mutationExpressions to the path\n\n    let current = pathData;\n\n    while (current) {\n      // Obtain and store mutationExpressions\n      if (current.mutationExpressions) mutationExpressions.unshift(...(await current.mutationExpressions)); // Move to parent link\n\n      current = current.parent;\n    }\n\n    return mutationExpressions;\n  }\n\n}","import MutationFunctionHandler from './MutationFunctionHandler';\n/**\n * A MutationFunctionHandler for insertions.\n */\n\nexport default class InsertFunctionHandler extends MutationFunctionHandler {\n  constructor() {\n    super('INSERT', false);\n  }\n\n}","/**\n * Returns a function that deletes all existing values\n * for the path, and then adds the given values to the path.\n *\n * Requires:\n * - a delete function on the path proxy.\n * - an add function on the path proxy.\n */\nexport default class SetFunctionHandler {\n  handle(pathData, path) {\n    return (...args) => path.delete().add(...args);\n  }\n\n}","/**\n * Returns a function that deletes the given value\n * for the path, and then adds the given values to the path.\n *\n * Requires:\n * - a delete function on the path proxy.\n * - an add function on the path proxy.\n */\nexport default class ReplaceFunctionHandler {\n  handle(pathData, path) {\n    return function (oldValue, ...newValues) {\n      if (!oldValue || !newValues.length) throw new Error('Replacing values requires at least two arguments, old value followed by all new values');\n      return path.delete(oldValue).add(...newValues);\n    };\n  }\n\n}","/**\n * Converts an asynchronously iterable path into an array.\n *\n * Requires:\n * - (optional) an iterable path\n */\nexport default class ToArrayHandler {\n  handle(pathData, path) {\n    return async map => {\n      const items = []; // Verify the path is async iterable\n\n      if (path && typeof path[Symbol.asyncIterator] === 'function') {\n        // Ensure the mapping function is valid\n        if (typeof map !== 'function') map = item => item; // Retrieve and map all elements\n\n        let index = 0;\n\n        for await (const item of path) items.push((await map(item, index++)));\n      }\n\n      return items;\n    };\n  }\n\n}","/**\n * Yields a function that interprets a string expression as an LDflex path.\n */\nexport default class StringToLDflexHandler {\n  handle(pathData, path) {\n    // Resolves the given string expression against the LDflex object\n    return (expression = '', ldflex = path) => {\n      // An expression starts with a property access in dot or bracket notation\n      const propertyPath = expression // Add brackets around a single URL\n      .replace(/^(https?:\\/\\/[^()[\\]'\"]+)$/, '[\"$1\"]') // Add the starting dot if omitted\n      .replace(/^(?=[a-z$_])/i, '.') // Add quotes inside of brackets if omitted\n      .replace(/\\[([^'\"`\\](]*)\\]/g, '[\"$1\"]'); // Create a function to evaluate the expression\n\n      const body = \"\\\"use strict\\\";return ldflex\".concat(propertyPath);\n      let evaluator;\n\n      try {\n        /* eslint no-new-func: off */\n        evaluator = Function('ldflex', body);\n      } catch ({\n        message\n      }) {\n        throw new Error(\"Expression \\\"\".concat(expression, \"\\\" is invalid: \").concat(message));\n      } // Evaluate the function\n\n\n      return evaluator(ldflex);\n    };\n  }\n\n}","const EMPTY = Object.create(null);\n/**\n * A PathProxy creates path expressions,\n * to which functionality can be attached.\n *\n * To users, these paths act as regular JavaScript objects\n * (such as `path.foo.bar.prop`) thanks to Proxy.\n * Behind the scenes, they carry around internal data\n * that can be used to influence their functionality.\n *\n * A path's functionality is realized by:\n * - handlers, which handle a specific named property\n * - resolvers, which can handle arbitrary properties\n * Only handlers and resolvers see the internal data.\n *\n * A path can have arbitrary internal data fields, but these are reserved:\n * - settings, an object that is passed on as-is to child paths\n * - proxy, a reference to the proxied object the user sees\n * - parent, a reference to the parent path\n * - extendPath, a method to create a child path with this path as parent\n */\n\nexport default class PathProxy {\n  constructor({\n    handlers = EMPTY,\n    resolvers = []\n  } = {}) {\n    this._handlers = handlers;\n    this._resolvers = resolvers;\n  }\n  /**\n   * Creates a path Proxy with the given settings and internal data fields.\n   */\n\n\n  createPath(settings = {}, data) {\n    // The settings parameter is optional\n    if (data === undefined) [data, settings] = [settings, {}]; // Create the path's internal data object and the proxy that wraps it\n\n    const path = {\n      settings,\n      ...data\n    };\n    const proxy = path.proxy = new Proxy(path, this); // Add an extendPath method to create child paths\n\n    if (!path.extendPath) {\n      const pathProxy = this;\n\n      path.extendPath = function extendPath(newData, parent = this) {\n        return pathProxy.createPath(settings, {\n          parent,\n          extendPath,\n          ...newData\n        });\n      };\n    } // Return the proxied path\n\n\n    return proxy;\n  }\n  /**\n   * Handles access to a property\n   */\n\n\n  get(pathData, property) {\n    // Handlers provide functionality for a specific property,\n    // so check if we find a handler first\n    const handler = this._handlers[property];\n    if (handler && typeof handler.handle === 'function') return handler.handle(pathData, pathData.proxy); // Resolvers provide functionality for arbitrary properties,\n    // so find a resolver that can handle this property\n\n    for (const resolver of this._resolvers) {\n      if (resolver.supports(property)) return resolver.resolve(property, pathData, pathData.proxy);\n    } // Otherwise, the property does not exist\n\n\n    return undefined;\n  }\n\n}","import { ContextParser } from 'jsonld-context-parser';\nimport { namedNode } from '@rdfjs/data-model';\nimport { lazyThenable } from './promiseUtils';\n/**\n * Resolves property names of a path\n * to their corresponding IRIs through a JSON-LD context.\n */\n\nexport default class JSONLDResolver {\n  /**\n   * Creates a new resolver for the given context(s).\n   */\n  constructor(...contexts) {\n    this._context = Promise.resolve({});\n    this.extendContext(...contexts);\n  }\n  /**\n   * The JSON-LD resolver supports all string properties.\n   */\n\n\n  supports(property) {\n    return typeof property === 'string';\n  }\n  /**\n   * Resolves the property by extending the query path with it.\n   */\n\n\n  resolve(property, pathData) {\n    const predicate = lazyThenable(() => this.expandProperty(property));\n    const resultsCache = this.getResultsCache(pathData, predicate);\n    return pathData.extendPath({\n      property,\n      predicate,\n      resultsCache\n    });\n  }\n  /**\n   * Expands a JSON property key into a full IRI.\n   */\n\n\n  async expandProperty(property) {\n    // JavaScript requires keys containing colons to be quoted,\n    // so prefixed names would need to written as path['foaf:knows'].\n    // We thus allow writing path.foaf_knows or path.foaf$knows instead.\n    property = property.replace(/^([a-z][a-z0-9]*)[_$]/i, '$1:'); // Expand the property to a full IRI\n\n    const context = await this._context;\n    const expandedProperty = ContextParser.expandTerm(property, context, true);\n    if (!ContextParser.isValidIri(expandedProperty)) throw new Error(\"The JSON-LD context cannot expand the '\".concat(property, \"' property\"));\n    return namedNode(expandedProperty);\n  }\n  /**\n   * Extends the current JSON-LD context with the given context(s).\n   */\n\n\n  async extendContext(...contexts) {\n    await (this._context = this._context.then(currentContext => new ContextParser().parse([currentContext, ...contexts])));\n  }\n  /**\n   * Gets the results cache for the given predicate.\n   */\n\n\n  getResultsCache(pathData, predicate) {\n    let {\n      propertyCache\n    } = pathData;\n    return propertyCache && lazyThenable(async () => {\n      propertyCache = await propertyCache;\n      return propertyCache && propertyCache[(await predicate).value];\n    });\n  }\n\n}","import PathProxy from './PathProxy';\nimport JSONLDResolver from './JSONLDResolver';\nimport defaultHandlers from './defaultHandlers';\nimport { ContextParser } from 'jsonld-context-parser';\n/**\n * A PathFactory creates paths with default settings.\n */\n\nexport default class PathFactory {\n  constructor(settings, data) {\n    // Store settings and data\n    this._settings = settings = { ...settings\n    };\n    this._data = data = { ...data\n    }; // Prepare the handlers\n\n    const handlers = settings.handlers || defaultHandlers;\n\n    for (const key in handlers) handlers[key] = toHandler(handlers[key]);\n\n    for (const key of Object.getOwnPropertySymbols(handlers)) handlers[key] = toHandler(handlers[key]); // Prepare the resolvers\n\n\n    const resolvers = (settings.resolvers || []).map(toResolver);\n\n    if (settings.context) {\n      resolvers.push(new JSONLDResolver(settings.context));\n      settings.parsedContext = new ContextParser().parse(settings.context);\n    } else {\n      settings.context = settings.parsedContext = {};\n    } // Instantiate PathProxy that will create the paths\n\n\n    this._pathProxy = new PathProxy({\n      handlers,\n      resolvers\n    }); // Remove PathProxy settings from the settings object\n\n    delete settings.handlers;\n    delete settings.resolvers;\n  }\n  /**\n   * Creates a path with the given (optional) settings and data.\n   */\n\n\n  create(settings = {}, data) {\n    // The settings parameter is optional\n    if (!data) [data, settings] = [settings, null]; // Apply defaults on settings and data\n\n    return this._pathProxy.createPath(Object.assign(Object.create(null), this._settings, settings), Object.assign(Object.create(null), this._data, data));\n  }\n\n}\nPathFactory.defaultHandlers = defaultHandlers;\n/**\n * Converts a handler function into a handler object.\n */\n\nexport function toHandler(handle) {\n  return typeof handle.handle === 'function' ? handle : {\n    handle\n  };\n}\n/**\n * Converts a resolver function into a catch-all resolver object.\n */\n\nexport function toResolver(resolve) {\n  return typeof resolve.resolve === 'function' ? resolve : {\n    supports,\n    resolve\n  };\n} // Catch-all resolvers support everything\n\nfunction supports() {\n  return true;\n}","import { toIterablePromise } from 'ldflex';\nimport { namedNode } from '@rdfjs/data-model';\nimport context from '@solid/context';\n\nconst { as } = context['@context'];\n\n/**\n * Base class for handlers that manipulate activities\n * Requires:\n * - the `root.user` handler\n * - the `root[...]` resolver\n * - a queryEngine property in the path settings\n */\nexport default class ActivityHandler {\n  requireUser = true;\n\n  constructor({ activitiesPath = '/public/activities' } = {}) {\n    this.activitiesPath = activitiesPath;\n  }\n\n  handle(pathData, path) {\n    const self = this;\n    const { root } = path;\n    const { settings: { queryEngine } } = pathData;\n\n    // Return an iterator over the activity paths\n    return (type = `${as}Like`) => toIterablePromise(async function* () {\n      // Only process activities if a user is logged in\n      let user;\n      try {\n        user = await root.user;\n      }\n      catch (error) {\n        if (self.requireUser)\n          throw error;\n        return;\n      }\n\n      // Determine the storage location\n      const storage = await root.user.pim$storage;\n      const document = new URL(self.activitiesPath, storage || user).href;\n\n      // Obtain results for every activity on the path\n      const results = [];\n      const actor = namedNode(user);\n      type = namedNode(type);\n      for await (const object of path) {\n        if (object.termType === 'NamedNode') {\n          const activity = { actor, type, object };\n          for await (const result of self.createResults(activity, document, queryEngine))\n            results.push(result);\n        }\n      }\n\n      // Process all results and return paths starting from the returned terms\n      for (const term of await self.processResults(results, document, queryEngine))\n        yield root[term.value];\n    });\n  }\n\n  async processResults(results) {\n    return results;\n  }\n}\n","import { SparqlHandler } from 'ldflex';\n\nexport const { termToString } = SparqlHandler.prototype;\n\nexport function replaceVariables(template, terms) {\n  for (const name in terms)\n    template = template.replace(new RegExp(`_:${name}`, 'g'), termToString(terms[name]));\n  return template;\n}\n\n// Transforms the arguments into an Immutable.js-style list\nexport function asList(...items) {\n  return {\n    size: items.length,\n    values: () => ({\n      next: () => ({ value: items.shift() }),\n    }),\n  };\n}\n","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n// find the complete implementation of crypto (msCrypto) on IE11.\nvar getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);\nvar rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\nexport default function rng() {\n  if (!getRandomValues) {\n    throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n  }\n\n  return getRandomValues(rnds8);\n}","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\n  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');\n}\n\nexport default bytesToUuid;","import rng from './rng.js';\nimport bytesToUuid from './bytesToUuid.js';\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof options == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nexport default v4;","import ActivityHandler from './ActivityHandler';\nimport activityTemplate from './activity.ttl';\nimport { replaceVariables } from '../util';\nimport { namedNode, literal } from '@rdfjs/data-model';\nimport { v4 as uuidv4 } from 'uuid';\nimport context from '@solid/context';\n\nconst { xsd } = context['@context'];\n\n/**\n * Handler that creates an activity in the user's data pod\n * Requires:\n * - the `root.user` handler\n * - the `root[...]` resolver\n * - a queryEngine property in the path settings\n */\nexport default class CreateActivityHandler extends ActivityHandler {\n  // Creates an activity for insertion in the given document\n  async* createResults(activity, document) {\n    const id = namedNode(new URL(`#${uuidv4()}`, document).href);\n    const published = literal(new Date().toISOString(), `${xsd}dateTime`);\n    activity = { id, published, ...activity };\n\n    const insert = replaceVariables(activityTemplate, activity);\n    yield { id, insert };\n  }\n\n  // Inserts the activities into the document\n  async processResults(results, document, queryEngine) {\n    const sparql = `INSERT {\\n${results.map(r => r.insert).join('')}}`;\n    await queryEngine.executeUpdate(sparql, document).next();\n    return results.map(r => r.id);\n  }\n}\n","import ActivityHandler from './ActivityHandler';\nimport queryTemplate from './activity-triples.sparql';\nimport { replaceVariables, termToString } from '../util';\n\nconst components = ['?subject', '?predicate', '?object'];\n\n/**\n * Handler that deletes an activity in the user's data pod\n * Requires:\n * - the `root.user` handler\n * - the `root[...]` resolver\n * - a queryEngine property in the path settings\n */\nexport default class DeleteActivityHandler extends ActivityHandler {\n  // Finds activity triples for deletion\n  async* createResults(activity, document, queryEngine) {\n    const query = replaceVariables(queryTemplate, activity);\n    for await (const triple of queryEngine.execute(query, document)) {\n      const terms = components.map(c => termToString(triple.get(c)));\n      yield `${terms.join(' ')}.\\n`;\n    }\n  }\n\n  // Deletes the activity triples from the document\n  async processResults(results, document, queryEngine) {\n    const sparql = `DELETE {\\n${results.join('')}}`;\n    await queryEngine.executeUpdate(sparql, document).next();\n    return [];\n  }\n}\n","import { namedNode } from '@rdfjs/data-model';\n\n/**\n * LDflex property resolver that returns a new path\n * starting from the property name as a subject.\n *\n * For example, when triggered as\n *     data['http://person.example/#me'].friends.firstName\n * it will create a path with `http://person.example/#me` as subject\n * and then resolve `friends` and `firstName` against the JSON-LD context.\n *\n * In case a source object is given as input, data will be pulled from there.\n */\nexport default class SubjectPathResolver {\n  constructor(pathFactory, source) {\n    this._paths = pathFactory;\n    this._source = source;\n  }\n\n  /** Resolve all string properties (not Symbols) */\n  supports(property) {\n    return typeof property === 'string';\n  }\n\n  resolve(property, { settings }) {\n    return this._createSubjectPath(namedNode(property), settings);\n  }\n\n  _createSubjectPath(subject, { createQueryEngine }) {\n    const source = this._source || Promise.resolve(subject).catch(() => null);\n    const queryEngine = createQueryEngine(source);\n    return this._paths.create({ queryEngine }, { subject });\n  }\n}\n","import { PathFactory, defaultHandlers } from 'ldflex';\nimport SubjectPathResolver from '../resolvers/SubjectPathResolver';\n\nexport default class SourcePathHandler {\n  constructor(pathFactory) {\n    this._paths = pathFactory;\n  }\n\n  handle({ settings }) {\n    return source => new PathFactory({\n      handlers: { ...defaultHandlers },\n      resolvers: [new SubjectPathResolver(this._paths, source)],\n    }).create(settings, {});\n  }\n}\n","import SubjectPathResolver from '../resolvers/SubjectPathResolver';\nimport auth from 'solid-auth-client';\nimport { namedNode } from '@rdfjs/data-model';\n\n/**\n * Creates a path with the current user as a subject.\n */\nexport default class UserPathHandler extends SubjectPathResolver {\n  handle({ settings }) {\n    const subject = this.getWebId().then(namedNode);\n    return this._createSubjectPath(subject, settings);\n  }\n\n  /** Gets the WebID of the logged in user */\n  async getWebId() {\n    const session = await auth.currentSession();\n    if (!session)\n      throw new Error('Cannot resolve user path: no user logged in');\n    return session.webId;\n  }\n}\n","import { PathFactory, defaultHandlers } from 'ldflex';\nimport context from '@solid/context';\nimport SolidDeleteFunctionHandler from './handlers/SolidDeleteFunctionHandler';\nimport FindActivityHandler from './handlers/FindActivityHandler';\nimport CreateActivityHandler from './handlers/CreateActivityHandler';\nimport DeleteActivityHandler from './handlers/DeleteActivityHandler';\nimport SourcePathHandler from './handlers/SourcePathHandler';\nimport UserPathHandler from './handlers/UserPathHandler';\nimport ContextResolver from './resolvers/ContextResolver';\nimport SubjectPathResolver from './resolvers/SubjectPathResolver';\n\nconst { as } = context['@context'];\nconst contextResolver = new ContextResolver(context);\n\n// Handlers for subject paths\nconst subjectHandlers = {\n  ...defaultHandlers,\n\n  // Custom delete handler to match node-solid-server behavior\n  delete: new SolidDeleteFunctionHandler(),\n\n  // Find activities\n  findActivity: new FindActivityHandler(),\n  likes: (_, path) => path.findActivity(`${as}Like`),\n  dislikes: (_, path) => path.findActivity(`${as}Dislike`),\n  follows: (_, path) => path.findActivity(`${as}Follow`),\n\n  // Create activities\n  createActivity: new CreateActivityHandler(),\n  like: (_, path) => () => path.createActivity(`${as}Like`),\n  dislike: (_, path) => () => path.createActivity(`${as}Dislike`),\n  follow: (_, path) => () => path.createActivity(`${as}Follow`),\n\n  // Delete activities\n  deleteActivity: new DeleteActivityHandler(),\n  unlike: (_, path) => () => path.deleteActivity(`${as}Like`),\n  undislike: (_, path) => () => path.deleteActivity(`${as}Dislike`),\n  unfollow: (_, path) => () => path.deleteActivity(`${as}Follow`),\n};\n\n// Creates an LDflex for Solid root path with the given settings\nexport default function createRootPath(defaultSettings) {\n  let rootPath = null;\n\n  // Factory for data paths that start from a given subject\n  const subjectPathFactory = new PathFactory({\n    handlers: { ...subjectHandlers, root: () => rootPath },\n    resolvers: [contextResolver],\n  });\n\n  // Root path that resolves the first property access\n  rootPath = new PathFactory({\n    // Handlers of specific named properties\n    handlers: {\n      ...defaultHandlers,\n\n      // The `from` function takes a source as input\n      from: new SourcePathHandler(subjectPathFactory),\n      // The `user` property starts a path with the current user as subject\n      user: new UserPathHandler(subjectPathFactory),\n\n      // Clears the cache for the given document (or everything, if undefined)\n      clearCache: ({ settings }) => doc =>\n        settings.createQueryEngine().clearCache(doc),\n\n      // Expose the JSON-LD context\n      context: contextResolver,\n    },\n    // Resolvers for all remaining properties\n    resolvers: [\n      // `data[url]` starts a path with the property as subject\n      new SubjectPathResolver(subjectPathFactory),\n    ],\n    ...defaultSettings,\n  }).create();\n  return rootPath;\n}\n","import { JSONLDResolver } from 'ldflex';\n\n/**\n * A ContextResolver is a combined resolver/handler that:\n * - resolves a JSON-LD context\n * - handles by returning an object that\n *   - is the initial context passed to the constructor\n *   - allows extending that context by calling `.extend`\n *   - when `await`ed, resolves to the expanded context\n */\nexport default class ContextResolver extends JSONLDResolver {\n  constructor(context) {\n    super(context);\n\n    // Create an exposed version of the initial context, with additional functionality\n    const exposedContext = this._exposedContext = Object.create(context['@context']);\n    // Allow extending the context\n    Object.defineProperty(exposedContext, 'extend', {\n      value: (...contexts) => this.extendContext(...contexts),\n    });\n    // Resolve to the expanded context\n    Object.defineProperty(exposedContext, 'then', {\n      value: (resolve, reject) => this._context.then(resolve, reject),\n    });\n  }\n\n  handle() {\n    return this._exposedContext;\n  }\n}\n","import { DeleteFunctionHandler } from 'ldflex';\n\n/**\n * node-solid-server deviates from the SPARQL UPDATE spec:\n * whereas the spec asks for DELETE on non-existing triples to silently succeed,\n * node-solid-server will only DELETE if exactly one triple matches.\n *\n * This delete handler works around that limitation\n * by first requesting all existing values for a path,\n * and then only issuing DELETE statements for those that exist.\n */\nexport default class SolidDeleteFunctionHandler extends DeleteFunctionHandler {\n  async extractObjects(pathData, path, args) {\n    // Obtain all values whose deletion was requested\n    const objects = await super.extractObjects(pathData, path, args);\n\n    // Obtain all values that currently exist\n    const existing = [];\n    for await (const term of path) {\n      if (term.termType !== 'BlankNode')\n        existing.push(term);\n    }\n\n    // Perform deletions only for values that exist\n    return !objects ? existing : existing.filter(e => objects.some(o => o.equals(e)));\n  }\n}\n","import ActivityHandler from './ActivityHandler';\nimport queryTemplate from './activity.sparql';\nimport { replaceVariables } from '../util';\n\n/**\n * Handler that finds an activity in the user's data pod\n * Requires:\n * - the `root.user` handler\n * - the `root[...]` resolver\n * - a queryEngine property in the path settings\n */\nexport default class FindActivityHandler extends ActivityHandler {\n  requireUser = false;\n\n  // Finds all activities in the document matching the given pattern\n  async* createResults(activity, document, queryEngine) {\n    const query = replaceVariables(queryTemplate, activity);\n    for await (const binding of queryEngine.execute(query, document))\n      yield binding.values().next().value;\n  }\n}\n","import auth from 'solid-auth-client';\nimport { asList } from './util';\n\n/**\n * A wrapper around a query engine\n * that uses Solid authenticated requests for updates.\n */\nexport default class SolidUpdateEngine {\n  /**\n   * Creates a wrapper around the given query engine.\n   */\n  constructor(sources, baseEngine) {\n    // Preload source but silence errors; they will be thrown during execution\n    this._source = this.getUpdateSource(sources);\n    this._source.catch(() => null);\n    this._engine = baseEngine;\n  }\n\n  /**\n   * Creates an asynchronous iterable of results for the given SPARQL query.\n   */\n  async* execute(sparql, sources) {\n    yield* /^\\s*(?:INSERT|DELETE)/i.test(sparql) ?\n      this.executeUpdate(sparql, sources) :\n      this._engine.execute(sparql, sources);\n  }\n\n  /**\n   * Creates an asynchronous iterable with the results of the SPARQL UPDATE query.\n   */\n  executeUpdate(sparql, sources) {\n    let done = false;\n    const next = async () => {\n      if (done)\n        return { done };\n      done = true;\n\n      // Send authenticated PATCH request to the document\n      const source = await (sources ? this.getUpdateSource(sources) : this._source);\n      const { ok, status, statusText } = await auth.fetch(source, {\n        method: 'PATCH',\n        headers: {\n          'Content-Type': 'application/sparql-update',\n        },\n        body: sparql,\n      });\n      if (!ok)\n        throw new Error(`Update query failed (${status}): ${statusText}`);\n\n      // Clear stale cached versions of the document\n      await this.clearCache(source);\n\n      // Return success\n      return { value: asList({ ok }) };\n    };\n    return {\n      next,\n      [Symbol.asyncIterator]() { return this; },\n    };\n  }\n\n  /**\n   * Parses the source(s) into the source to update.\n   */\n  async getUpdateSource(sources) {\n    let source = await sources;\n\n    // Transform URLs or terms into strings\n    if (source instanceof URL)\n      source = source.href;\n    else if (source && typeof source.value === 'string')\n      source = source.value;\n\n    // Parse a string URL source\n    if (typeof source === 'string') {\n      if (!/^https?:\\/\\//.test(source))\n        throw new Error('Can only update an HTTP(S) document.');\n      return source.replace(/#.*/, '');\n    }\n\n    // Flatten recursive calls to this function\n    if (Array.isArray(source)) {\n      source = await Promise.all(source.map(s => this.getUpdateSource(s)));\n      source = [].concat(...source).filter(s => !!s);\n      if (source.length !== 1)\n        throw new Error('Can only update a single source.');\n      return source[0];\n    }\n\n    // Error on unsupported sources\n    throw new Error(`Unsupported source: ${source}`);\n  }\n\n  /**\n   * Removes the given document (or all, if not specified) from the cache,\n   * such that fresh results are obtained next time.\n   */\n  clearCache(document) {\n    return this._engine.clearCache(document);\n  }\n}\n","import RdflibQueryEngine from './RdflibQueryEngine';\nexport default RdflibQueryEngine;\n","import {\n  graph,\n  Fetcher,\n  SPARQLToQuery as sparqlToQuery,\n} from 'rdflib';\n\n/**\n * Asynchronous iterator wrapper for the rdflib.js SPARQL query engine.\n */\nexport default class RdflibQueryEngine {\n  /**\n   * Creates a query engine with the given sources as default.\n   */\n  constructor(defaultSources) {\n    // Preload sources but silence errors; they will be thrown during execution\n    this._defaultStore = this.readSources(defaultSources);\n    this._defaultStore.catch(() => null);\n  }\n\n  /**\n   * Creates an asynchronous iterable of results for the given SPARQL query.\n   */\n  async* execute(sparql, sources) {\n    if ((/^\\s*(?:INSERT|DELETE)/i).test(sparql))\n      yield* this.executeUpdate(sparql, sources);\n\n    // Parse the SPARQL query\n    const query = sparqlToQuery(sparql, true, graph());\n    // Load the sources if passed, the default sources otherwise\n    const store = await (sources ? this.readSources(sources) : this._defaultStore);\n    // Disable link traversal for now (slow, and unreliable error handling)\n    store.fetcher = null;\n\n    // Execute the query and store the results in an array\n    const results = [];\n    await new Promise((resolve, reject) => {\n      store.query(query, result => results.push(result), null,\n        error => error ? reject(error) : resolve(results));\n    });\n\n    // Convert every result to a map\n    const vars = new Set(query.vars.map(v => `?${v.value}`));\n    for (const result of results) {\n      // Only return explicitly requested variables\n      // (workaround for https://github.com/linkeddata/rdflib.js/issues/393)\n      const bindings = Object.entries(result).filter(([v]) => vars.has(v));\n      yield new Map(bindings);\n    }\n  }\n\n  /**\n   * Creates an asynchronous iterable with the results of the SPARQL UPDATE query.\n   */\n  async* executeUpdate(sparql, sources) {\n    throw new Error(`SPARQL UPDATE queries are unsupported, received: ${sparql}`);\n  }\n\n  /**\n   * Reads the specified stores into a store.\n   */\n  async readSources(sourceList, store = graph()) {\n    let source = await sourceList;\n    if (source) {\n      // Transform URLs or terms into strings\n      if (source instanceof URL)\n        source = source.href;\n      else if (source.termType === 'NamedNode')\n        source = source.value;\n\n      // Read a document from a URL\n      if (typeof source === 'string') {\n        const document = source.replace(/#.*/, '');\n        const fetcher = new Fetcher(store);\n        await fetcher.load(document);\n      }\n      // Read an array of sources\n      else if (Array.isArray(source)) {\n        await Promise.all(source.map(s => this.readSources(s, store)));\n      }\n      // Read an RDF/JS source\n      else if (typeof source.match === 'function') {\n        const results = source.match(null, null, null, null);\n        await new Promise((resolve, reject) => {\n          results.on('data', addQuad);\n          results.on('end', finish);\n          results.on('error', finish);\n          // Adds a quad to the store\n          function addQuad(quad) {\n            try {\n              store.add(quad.subject, quad.predicate, quad.object, quad.graph);\n            }\n            catch (error) {\n              finish(error);\n            }\n          }\n          // Finishes reading the source\n          function finish(error) {\n            results.removeListener('data', addQuad);\n            results.removeListener('end', finish);\n            results.removeListener('error', finish);\n            return error ? reject(error) : resolve(null);\n          }\n        });\n      }\n      // Error on unsupported sources\n      else {\n        throw new Error(`Unsupported source: ${source}`);\n      }\n    }\n    return store;\n  }\n\n  /**\n   * Removes the given document (or all, if not specified) from the cache,\n   * such that fresh results are obtained next time.\n   */\n  async clearCache(document) {\n    // No action required, since we need a new fetcher for every store\n  }\n}\n","import RootPath from '../RootPath';\nimport SolidUpdateEngine from '../SolidUpdateEngine';\nimport RdflibQueryEngine from '@ldflex/rdflib';\n\n// Export the root path with rdflib.js as query engine\nexport default new RootPath({\n  createQueryEngine: sources =>\n    new SolidUpdateEngine(sources, new RdflibQueryEngine(sources)),\n});\n"],"sourceRoot":""}